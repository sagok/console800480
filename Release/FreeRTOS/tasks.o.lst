   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"tasks.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.global	pxCurrentTCB
  19              		.bss
  20              		.align	2
  23              	pxCurrentTCB:
  24 0000 00000000 		.space	4
  25              		.align	2
  26              	pxReadyTasksLists:
  27 0004 00000000 		.space	100
  27      00000000 
  27      00000000 
  27      00000000 
  27      00000000 
  28              		.align	2
  29              	xDelayedTaskList1:
  30 0068 00000000 		.space	20
  30      00000000 
  30      00000000 
  30      00000000 
  30      00000000 
  31              		.align	2
  32              	xDelayedTaskList2:
  33 007c 00000000 		.space	20
  33      00000000 
  33      00000000 
  33      00000000 
  33      00000000 
  34              		.align	2
  35              	pxDelayedTaskList:
  36 0090 00000000 		.space	4
  37              		.align	2
  38              	pxOverflowDelayedTaskList:
  39 0094 00000000 		.space	4
  40              		.align	2
  41              	xPendingReadyList:
  42 0098 00000000 		.space	20
  42      00000000 
  42      00000000 
  42      00000000 
  42      00000000 
  43              		.align	2
  44              	xTasksWaitingTermination:
  45 00ac 00000000 		.space	20
  45      00000000 
  45      00000000 
  45      00000000 
  45      00000000 
  46              		.align	2
  47              	uxTasksDeleted:
  48 00c0 00000000 		.space	4
  49              		.align	2
  50              	xSuspendedTaskList:
  51 00c4 00000000 		.space	20
  51      00000000 
  51      00000000 
  51      00000000 
  51      00000000 
  52              		.align	2
  53              	uxCurrentNumberOfTasks:
  54 00d8 00000000 		.space	4
  55              		.align	2
  56              	xTickCount:
  57 00dc 00000000 		.space	4
  58              		.align	2
  59              	uxTopReadyPriority:
  60 00e0 00000000 		.space	4
  61              		.align	2
  62              	xSchedulerRunning:
  63 00e4 00000000 		.space	4
  64              		.align	2
  65              	uxPendedTicks:
  66 00e8 00000000 		.space	4
  67              		.align	2
  68              	xYieldPending:
  69 00ec 00000000 		.space	4
  70              		.align	2
  71              	xNumOfOverflows:
  72 00f0 00000000 		.space	4
  73              		.align	2
  74              	uxTaskNumber:
  75 00f4 00000000 		.space	4
  76              		.data
  77              		.align	2
  80              	xNextTaskUnblockTime:
  81 0000 FFFFFFFF 		.word	-1
  82              		.bss
  83              		.align	2
  84              	uxSchedulerSuspended:
  85 00f8 00000000 		.space	4
  86              		.text
  87              		.align	2
  88              		.global	xTaskGenericCreate
  89              		.thumb
  90              		.thumb_func
  92              	xTaskGenericCreate:
  93              	.LFB0:
  94              		.file 1 "../FreeRTOS/tasks.c"
   1:../FreeRTOS/tasks.c **** /*
   2:../FreeRTOS/tasks.c ****     FreeRTOS V8.0.1 - Copyright (C) 2014 Real Time Engineers Ltd.
   3:../FreeRTOS/tasks.c ****     All rights reserved
   4:../FreeRTOS/tasks.c **** 
   5:../FreeRTOS/tasks.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:../FreeRTOS/tasks.c **** 
   7:../FreeRTOS/tasks.c ****     ***************************************************************************
   8:../FreeRTOS/tasks.c ****      *                                                                       *
   9:../FreeRTOS/tasks.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  10:../FreeRTOS/tasks.c ****      *    robust, strictly quality controlled, supported, and cross          *
  11:../FreeRTOS/tasks.c ****      *    platform software that has become a de facto standard.             *
  12:../FreeRTOS/tasks.c ****      *                                                                       *
  13:../FreeRTOS/tasks.c ****      *    Help yourself get started quickly and support the FreeRTOS         *
  14:../FreeRTOS/tasks.c ****      *    project by purchasing a FreeRTOS tutorial book, reference          *
  15:../FreeRTOS/tasks.c ****      *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
  16:../FreeRTOS/tasks.c ****      *                                                                       *
  17:../FreeRTOS/tasks.c ****      *    Thank you!                                                         *
  18:../FreeRTOS/tasks.c ****      *                                                                       *
  19:../FreeRTOS/tasks.c ****     ***************************************************************************
  20:../FreeRTOS/tasks.c **** 
  21:../FreeRTOS/tasks.c ****     This file is part of the FreeRTOS distribution.
  22:../FreeRTOS/tasks.c **** 
  23:../FreeRTOS/tasks.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  24:../FreeRTOS/tasks.c ****     the terms of the GNU General Public License (version 2) as published by the
  25:../FreeRTOS/tasks.c ****     Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
  26:../FreeRTOS/tasks.c **** 
  27:../FreeRTOS/tasks.c ****     >>!   NOTE: The modification to the GPL is included to allow you to     !<<
  28:../FreeRTOS/tasks.c ****     >>!   distribute a combined work that includes FreeRTOS without being   !<<
  29:../FreeRTOS/tasks.c ****     >>!   obliged to provide the source code for proprietary components     !<<
  30:../FreeRTOS/tasks.c ****     >>!   outside of the FreeRTOS kernel.                                   !<<
  31:../FreeRTOS/tasks.c **** 
  32:../FreeRTOS/tasks.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  33:../FreeRTOS/tasks.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  34:../FreeRTOS/tasks.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available from the following
  35:../FreeRTOS/tasks.c ****     link: http://www.freertos.org/a00114.html
  36:../FreeRTOS/tasks.c **** 
  37:../FreeRTOS/tasks.c ****     1 tab == 4 spaces!
  38:../FreeRTOS/tasks.c **** 
  39:../FreeRTOS/tasks.c ****     ***************************************************************************
  40:../FreeRTOS/tasks.c ****      *                                                                       *
  41:../FreeRTOS/tasks.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  42:../FreeRTOS/tasks.c ****      *    not run, what could be wrong?"                                     *
  43:../FreeRTOS/tasks.c ****      *                                                                       *
  44:../FreeRTOS/tasks.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  45:../FreeRTOS/tasks.c ****      *                                                                       *
  46:../FreeRTOS/tasks.c ****     ***************************************************************************
  47:../FreeRTOS/tasks.c **** 
  48:../FreeRTOS/tasks.c ****     http://www.FreeRTOS.org - Documentation, books, training, latest versions,
  49:../FreeRTOS/tasks.c ****     license and Real Time Engineers Ltd. contact details.
  50:../FreeRTOS/tasks.c **** 
  51:../FreeRTOS/tasks.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  52:../FreeRTOS/tasks.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  53:../FreeRTOS/tasks.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  54:../FreeRTOS/tasks.c **** 
  55:../FreeRTOS/tasks.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
  56:../FreeRTOS/tasks.c ****     Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
  57:../FreeRTOS/tasks.c ****     licenses offer ticketed support, indemnification and middleware.
  58:../FreeRTOS/tasks.c **** 
  59:../FreeRTOS/tasks.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  60:../FreeRTOS/tasks.c ****     engineered and independently SIL3 certified version for use in safety and
  61:../FreeRTOS/tasks.c ****     mission critical applications that require provable dependability.
  62:../FreeRTOS/tasks.c **** 
  63:../FreeRTOS/tasks.c ****     1 tab == 4 spaces!
  64:../FreeRTOS/tasks.c **** */
  65:../FreeRTOS/tasks.c **** 
  66:../FreeRTOS/tasks.c **** /* Standard includes. */
  67:../FreeRTOS/tasks.c **** #include <stdlib.h>
  68:../FreeRTOS/tasks.c **** #include <string.h>
  69:../FreeRTOS/tasks.c **** 
  70:../FreeRTOS/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  71:../FreeRTOS/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  72:../FreeRTOS/tasks.c **** task.h is included from an application file. */
  73:../FreeRTOS/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  74:../FreeRTOS/tasks.c **** 
  75:../FreeRTOS/tasks.c **** /* FreeRTOS includes. */
  76:../FreeRTOS/tasks.c **** #include "FreeRTOS.h"
  77:../FreeRTOS/tasks.c **** #include "task.h"
  78:../FreeRTOS/tasks.c **** #include "timers.h"
  79:../FreeRTOS/tasks.c **** #include "StackMacros.h"
  80:../FreeRTOS/tasks.c **** 
  81:../FreeRTOS/tasks.c **** /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
  82:../FreeRTOS/tasks.c **** MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
  83:../FreeRTOS/tasks.c **** header files above, but not in this file, in order to generate the correct
  84:../FreeRTOS/tasks.c **** privileged Vs unprivileged linkage and placement. */
  85:../FreeRTOS/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
  86:../FreeRTOS/tasks.c **** 
  87:../FreeRTOS/tasks.c **** #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
  88:../FreeRTOS/tasks.c **** 	/* At the bottom of this file are two optional functions that can be used
  89:../FreeRTOS/tasks.c **** 	to generate human readable text from the raw data generated by the
  90:../FreeRTOS/tasks.c **** 	uxTaskGetSystemState() function.  Note the formatting functions are provided
  91:../FreeRTOS/tasks.c **** 	for convenience only, and are NOT considered part of the kernel. */
  92:../FreeRTOS/tasks.c **** 	#include <stdio.h>
  93:../FreeRTOS/tasks.c **** #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
  94:../FreeRTOS/tasks.c **** 
  95:../FreeRTOS/tasks.c **** /* Sanity check the configuration. */
  96:../FreeRTOS/tasks.c **** #if configUSE_TICKLESS_IDLE != 0
  97:../FreeRTOS/tasks.c **** 	#if INCLUDE_vTaskSuspend != 1
  98:../FreeRTOS/tasks.c **** 		#error INCLUDE_vTaskSuspend must be set to 1 if configUSE_TICKLESS_IDLE is not set to 0
  99:../FreeRTOS/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
 100:../FreeRTOS/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
 101:../FreeRTOS/tasks.c **** 
 102:../FreeRTOS/tasks.c **** /*
 103:../FreeRTOS/tasks.c ****  * Defines the size, in words, of the stack allocated to the idle task.
 104:../FreeRTOS/tasks.c ****  */
 105:../FreeRTOS/tasks.c **** #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
 106:../FreeRTOS/tasks.c **** 
 107:../FreeRTOS/tasks.c **** #if( configUSE_PREEMPTION == 0 )
 108:../FreeRTOS/tasks.c **** 	/* If the cooperative scheduler is being used then a yield should not be
 109:../FreeRTOS/tasks.c **** 	performed just because a higher priority task has been woken. */
 110:../FreeRTOS/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION()
 111:../FreeRTOS/tasks.c **** #else
 112:../FreeRTOS/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
 113:../FreeRTOS/tasks.c **** #endif
 114:../FreeRTOS/tasks.c **** 
 115:../FreeRTOS/tasks.c **** /*
 116:../FreeRTOS/tasks.c ****  * Task control block.  A task control block (TCB) is allocated for each task,
 117:../FreeRTOS/tasks.c ****  * and stores task state information, including a pointer to the task's context
 118:../FreeRTOS/tasks.c ****  * (the task's run time environment, including register values)
 119:../FreeRTOS/tasks.c ****  */
 120:../FreeRTOS/tasks.c **** typedef struct tskTaskControlBlock
 121:../FreeRTOS/tasks.c **** {
 122:../FreeRTOS/tasks.c **** 	volatile StackType_t	*pxTopOfStack;	/*< Points to the location of the last item placed on the task
 123:../FreeRTOS/tasks.c **** 
 124:../FreeRTOS/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 125:../FreeRTOS/tasks.c **** 		xMPU_SETTINGS	xMPUSettings;		/*< The MPU settings are defined as part of the port layer.  THIS MU
 126:../FreeRTOS/tasks.c **** 	#endif
 127:../FreeRTOS/tasks.c **** 
 128:../FreeRTOS/tasks.c **** 	ListItem_t			xGenericListItem;	/*< The list that the state list item of a task is reference from d
 129:../FreeRTOS/tasks.c **** 	ListItem_t			xEventListItem;		/*< Used to reference a task from an event list. */
 130:../FreeRTOS/tasks.c **** 	UBaseType_t			uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
 131:../FreeRTOS/tasks.c **** 	StackType_t			*pxStack;			/*< Points to the start of the stack. */
 132:../FreeRTOS/tasks.c **** 	char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.
 133:../FreeRTOS/tasks.c **** 
 134:../FreeRTOS/tasks.c **** 	#if ( portSTACK_GROWTH > 0 )
 135:../FreeRTOS/tasks.c **** 		StackType_t		*pxEndOfStack;		/*< Points to the end of the stack on architectures where the stack 
 136:../FreeRTOS/tasks.c **** 	#endif
 137:../FreeRTOS/tasks.c **** 
 138:../FreeRTOS/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 139:../FreeRTOS/tasks.c **** 		UBaseType_t 	uxCriticalNesting; 	/*< Holds the critical section nesting depth for ports that do n
 140:../FreeRTOS/tasks.c **** 	#endif
 141:../FreeRTOS/tasks.c **** 
 142:../FreeRTOS/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 143:../FreeRTOS/tasks.c **** 		UBaseType_t		uxTCBNumber;		/*< Stores a number that increments each time a TCB is created.  It al
 144:../FreeRTOS/tasks.c **** 		UBaseType_t  	uxTaskNumber;		/*< Stores a number specifically for use by third party trace code. 
 145:../FreeRTOS/tasks.c **** 	#endif
 146:../FreeRTOS/tasks.c **** 
 147:../FreeRTOS/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 148:../FreeRTOS/tasks.c **** 		UBaseType_t 	uxBasePriority;		/*< The priority last assigned to the task - used by the priority i
 149:../FreeRTOS/tasks.c **** 	#endif
 150:../FreeRTOS/tasks.c **** 
 151:../FreeRTOS/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 152:../FreeRTOS/tasks.c **** 		TaskHookFunction_t pxTaskTag;
 153:../FreeRTOS/tasks.c **** 	#endif
 154:../FreeRTOS/tasks.c **** 
 155:../FreeRTOS/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 156:../FreeRTOS/tasks.c **** 		uint32_t		ulRunTimeCounter;	/*< Stores the amount of time the task has spent in the Running state
 157:../FreeRTOS/tasks.c **** 	#endif
 158:../FreeRTOS/tasks.c **** 
 159:../FreeRTOS/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
 160:../FreeRTOS/tasks.c **** 		/* Allocate a Newlib reent structure that is specific to this task.
 161:../FreeRTOS/tasks.c **** 		Note Newlib support has been included by popular demand, but is not
 162:../FreeRTOS/tasks.c **** 		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
 163:../FreeRTOS/tasks.c **** 		responsible for resulting newlib operation.  User must be familiar with
 164:../FreeRTOS/tasks.c **** 		newlib and must provide system-wide implementations of the necessary
 165:../FreeRTOS/tasks.c **** 		stubs. Be warned that (at the time of writing) the current newlib design
 166:../FreeRTOS/tasks.c **** 		implements a system-wide malloc() that must be provided with locks. */
 167:../FreeRTOS/tasks.c **** 		struct 	_reent xNewLib_reent;
 168:../FreeRTOS/tasks.c **** 	#endif
 169:../FreeRTOS/tasks.c **** 
 170:../FreeRTOS/tasks.c **** } tskTCB;
 171:../FreeRTOS/tasks.c **** 
 172:../FreeRTOS/tasks.c **** /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
 173:../FreeRTOS/tasks.c **** below to enable the use of older kernel aware debuggers. */
 174:../FreeRTOS/tasks.c **** typedef tskTCB TCB_t;
 175:../FreeRTOS/tasks.c **** 
 176:../FreeRTOS/tasks.c **** /*
 177:../FreeRTOS/tasks.c ****  * Some kernel aware debuggers require the data the debugger needs access to to
 178:../FreeRTOS/tasks.c ****  * be global, rather than file scope.
 179:../FreeRTOS/tasks.c ****  */
 180:../FreeRTOS/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 181:../FreeRTOS/tasks.c **** 	#define static
 182:../FreeRTOS/tasks.c **** #endif
 183:../FreeRTOS/tasks.c **** 
 184:../FreeRTOS/tasks.c **** /*lint -e956 A manual analysis and inspection has been used to determine which
 185:../FreeRTOS/tasks.c **** static variables must be declared volatile. */
 186:../FreeRTOS/tasks.c **** 
 187:../FreeRTOS/tasks.c **** PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
 188:../FreeRTOS/tasks.c **** 
 189:../FreeRTOS/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 190:../FreeRTOS/tasks.c **** PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks
 191:../FreeRTOS/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList1;						/*< Delayed tasks. */
 192:../FreeRTOS/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList2;						/*< Delayed tasks (two lists are used - one f
 193:../FreeRTOS/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				/*< Points to the delayed task list 
 194:../FreeRTOS/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task
 195:../FreeRTOS/tasks.c **** PRIVILEGED_DATA static List_t xPendingReadyList;						/*< Tasks that have been readied while the sc
 196:../FreeRTOS/tasks.c **** 
 197:../FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 198:../FreeRTOS/tasks.c **** 
 199:../FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				/*< Tasks that have been deleted - but 
 200:../FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static volatile UBaseType_t uxTasksDeleted = ( UBaseType_t ) 0U;
 201:../FreeRTOS/tasks.c **** 
 202:../FreeRTOS/tasks.c **** #endif
 203:../FreeRTOS/tasks.c **** 
 204:../FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 205:../FreeRTOS/tasks.c **** 
 206:../FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static List_t xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 207:../FreeRTOS/tasks.c **** 
 208:../FreeRTOS/tasks.c **** #endif
 209:../FreeRTOS/tasks.c **** 
 210:../FreeRTOS/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
 211:../FreeRTOS/tasks.c **** 
 212:../FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle = NULL;			/*< Holds the handle of the idle tas
 213:../FreeRTOS/tasks.c **** 
 214:../FreeRTOS/tasks.c **** #endif
 215:../FreeRTOS/tasks.c **** 
 216:../FreeRTOS/tasks.c **** /* Other file private variables. --------------------------------*/
 217:../FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
 218:../FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) 0U;
 219:../FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
 220:../FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
 221:../FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;
 222:../FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
 223:../FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
 224:../FreeRTOS/tasks.c **** PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
 225:../FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= portMAX_DELAY;
 226:../FreeRTOS/tasks.c **** 
 227:../FreeRTOS/tasks.c **** /* Context switches are held pending while the scheduler is suspended.  Also,
 228:../FreeRTOS/tasks.c **** interrupts must not manipulate the xStateListItem of a TCB, or any of the
 229:../FreeRTOS/tasks.c **** lists the xStateListItem can be referenced from, if the scheduler is suspended.
 230:../FreeRTOS/tasks.c **** If an interrupt needs to unblock a task while the scheduler is suspended then it
 231:../FreeRTOS/tasks.c **** moves the task's event list item into the xPendingReadyList, ready for the
 232:../FreeRTOS/tasks.c **** kernel to move the task from the pending ready list into the real ready list
 233:../FreeRTOS/tasks.c **** when the scheduler is unsuspended.  The pending ready list itself can only be
 234:../FreeRTOS/tasks.c **** accessed from a critical section. */
 235:../FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
 236:../FreeRTOS/tasks.c **** 
 237:../FreeRTOS/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 238:../FreeRTOS/tasks.c **** 
 239:../FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter
 240:../FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		/*< Holds the total amount of execution tim
 241:../FreeRTOS/tasks.c **** 
 242:../FreeRTOS/tasks.c **** #endif
 243:../FreeRTOS/tasks.c **** 
 244:../FreeRTOS/tasks.c **** /*lint +e956 */
 245:../FreeRTOS/tasks.c **** 
 246:../FreeRTOS/tasks.c **** /* Debugging and trace facilities private variables and macros. ------------*/
 247:../FreeRTOS/tasks.c **** 
 248:../FreeRTOS/tasks.c **** /*
 249:../FreeRTOS/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
 250:../FreeRTOS/tasks.c ****  * is used purely for checking the high water mark for tasks.
 251:../FreeRTOS/tasks.c ****  */
 252:../FreeRTOS/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
 253:../FreeRTOS/tasks.c **** 
 254:../FreeRTOS/tasks.c **** /*
 255:../FreeRTOS/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 256:../FreeRTOS/tasks.c ****  */
 257:../FreeRTOS/tasks.c **** #define tskBLOCKED_CHAR		( 'B' )
 258:../FreeRTOS/tasks.c **** #define tskREADY_CHAR		( 'R' )
 259:../FreeRTOS/tasks.c **** #define tskDELETED_CHAR		( 'D' )
 260:../FreeRTOS/tasks.c **** #define tskSUSPENDED_CHAR	( 'S' )
 261:../FreeRTOS/tasks.c **** 
 262:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 263:../FreeRTOS/tasks.c **** 
 264:../FreeRTOS/tasks.c **** #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
 265:../FreeRTOS/tasks.c **** 
 266:../FreeRTOS/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
 267:../FreeRTOS/tasks.c **** 	performed in a generic way that is not optimised to any particular
 268:../FreeRTOS/tasks.c **** 	microcontroller architecture. */
 269:../FreeRTOS/tasks.c **** 
 270:../FreeRTOS/tasks.c **** 	/* uxTopReadyPriority holds the priority of the highest priority ready
 271:../FreeRTOS/tasks.c **** 	state task. */
 272:../FreeRTOS/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )														\
 273:../FreeRTOS/tasks.c **** 	{																									\
 274:../FreeRTOS/tasks.c **** 		if( ( uxPriority ) > uxTopReadyPriority )														\
 275:../FreeRTOS/tasks.c **** 		{																								\
 276:../FreeRTOS/tasks.c **** 			uxTopReadyPriority = ( uxPriority );														\
 277:../FreeRTOS/tasks.c **** 		}																								\
 278:../FreeRTOS/tasks.c **** 	} /* taskRECORD_READY_PRIORITY */
 279:../FreeRTOS/tasks.c **** 
 280:../FreeRTOS/tasks.c **** 	/*-----------------------------------------------------------*/
 281:../FreeRTOS/tasks.c **** 
 282:../FreeRTOS/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
 283:../FreeRTOS/tasks.c **** 	{																									\
 284:../FreeRTOS/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */								\
 285:../FreeRTOS/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )						\
 286:../FreeRTOS/tasks.c **** 		{																								\
 287:../FreeRTOS/tasks.c **** 			configASSERT( uxTopReadyPriority );															\
 288:../FreeRTOS/tasks.c **** 			--uxTopReadyPriority;																		\
 289:../FreeRTOS/tasks.c **** 		}																								\
 290:../FreeRTOS/tasks.c **** 																										\
 291:../FreeRTOS/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of						\
 292:../FreeRTOS/tasks.c **** 		the	same priority get an equal share of the processor time. */									\
 293:../FreeRTOS/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );		\
 294:../FreeRTOS/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
 295:../FreeRTOS/tasks.c **** 
 296:../FreeRTOS/tasks.c **** 	/*-----------------------------------------------------------*/
 297:../FreeRTOS/tasks.c **** 
 298:../FreeRTOS/tasks.c **** 	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
 299:../FreeRTOS/tasks.c **** 	they are only required when a port optimised method of task selection is
 300:../FreeRTOS/tasks.c **** 	being used. */
 301:../FreeRTOS/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )
 302:../FreeRTOS/tasks.c **** 	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
 303:../FreeRTOS/tasks.c **** 
 304:../FreeRTOS/tasks.c **** #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 305:../FreeRTOS/tasks.c **** 
 306:../FreeRTOS/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
 307:../FreeRTOS/tasks.c **** 	performed in a way that is tailored to the particular microcontroller
 308:../FreeRTOS/tasks.c **** 	architecture being used. */
 309:../FreeRTOS/tasks.c **** 
 310:../FreeRTOS/tasks.c **** 	/* A port optimised version is provided.  Call the port defined macros. */
 311:../FreeRTOS/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyP
 312:../FreeRTOS/tasks.c **** 
 313:../FreeRTOS/tasks.c **** 	/*-----------------------------------------------------------*/
 314:../FreeRTOS/tasks.c **** 
 315:../FreeRTOS/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
 316:../FreeRTOS/tasks.c **** 	{																								\
 317:../FreeRTOS/tasks.c **** 	UBaseType_t uxTopPriority;																		\
 318:../FreeRTOS/tasks.c **** 																									\
 319:../FreeRTOS/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */							\
 320:../FreeRTOS/tasks.c **** 		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
 321:../FreeRTOS/tasks.c **** 		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
 322:../FreeRTOS/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
 323:../FreeRTOS/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
 324:../FreeRTOS/tasks.c **** 
 325:../FreeRTOS/tasks.c **** 	/*-----------------------------------------------------------*/
 326:../FreeRTOS/tasks.c **** 
 327:../FreeRTOS/tasks.c **** 	/* A port optimised version is provided, call it only if the TCB being reset
 328:../FreeRTOS/tasks.c **** 	is being referenced from a ready list.  If it is referenced from a delayed
 329:../FreeRTOS/tasks.c **** 	or suspended list then it won't be in a ready list. */
 330:../FreeRTOS/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )													\
 331:../FreeRTOS/tasks.c **** 	{																								\
 332:../FreeRTOS/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == 0 )				\
 333:../FreeRTOS/tasks.c **** 		{																							\
 334:../FreeRTOS/tasks.c **** 			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );						\
 335:../FreeRTOS/tasks.c **** 		}																							\
 336:../FreeRTOS/tasks.c **** 	}
 337:../FreeRTOS/tasks.c **** 
 338:../FreeRTOS/tasks.c **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 339:../FreeRTOS/tasks.c **** 
 340:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 341:../FreeRTOS/tasks.c **** 
 342:../FreeRTOS/tasks.c **** /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
 343:../FreeRTOS/tasks.c **** count overflows. */
 344:../FreeRTOS/tasks.c **** #define taskSWITCH_DELAYED_LISTS()																	\
 345:../FreeRTOS/tasks.c **** {																									\
 346:../FreeRTOS/tasks.c **** 	List_t *pxTemp;																					\
 347:../FreeRTOS/tasks.c **** 																									\
 348:../FreeRTOS/tasks.c **** 	/* The delayed tasks list should be empty when the lists are switched. */						\
 349:../FreeRTOS/tasks.c **** 	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
 350:../FreeRTOS/tasks.c **** 																									\
 351:../FreeRTOS/tasks.c **** 	pxTemp = pxDelayedTaskList;																		\
 352:../FreeRTOS/tasks.c **** 	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
 353:../FreeRTOS/tasks.c **** 	pxOverflowDelayedTaskList = pxTemp;																\
 354:../FreeRTOS/tasks.c **** 	xNumOfOverflows++;																				\
 355:../FreeRTOS/tasks.c **** 	prvResetNextTaskUnblockTime();																	\
 356:../FreeRTOS/tasks.c **** }
 357:../FreeRTOS/tasks.c **** 
 358:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 359:../FreeRTOS/tasks.c **** 
 360:../FreeRTOS/tasks.c **** /*
 361:../FreeRTOS/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready list for
 362:../FreeRTOS/tasks.c ****  * the task.  It is inserted at the end of the list.
 363:../FreeRTOS/tasks.c ****  */
 364:../FreeRTOS/tasks.c **** #define prvAddTaskToReadyList( pxTCB )																\
 365:../FreeRTOS/tasks.c **** 	traceMOVED_TASK_TO_READY_STATE( pxTCB )															\
 366:../FreeRTOS/tasks.c **** 	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
 367:../FreeRTOS/tasks.c **** 	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGenericListItem ) 
 368:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 369:../FreeRTOS/tasks.c **** 
 370:../FreeRTOS/tasks.c **** /*
 371:../FreeRTOS/tasks.c ****  * Several functions take an TaskHandle_t parameter that can optionally be NULL,
 372:../FreeRTOS/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 373:../FreeRTOS/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 374:../FreeRTOS/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 375:../FreeRTOS/tasks.c ****  */
 376:../FreeRTOS/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( TCB_t * ) pxCurrentTCB : ( T
 377:../FreeRTOS/tasks.c **** 
 378:../FreeRTOS/tasks.c **** /* The item value of the event list item is normally used to hold the priority
 379:../FreeRTOS/tasks.c **** of the task to which it belongs (coded to allow it to be held in reverse
 380:../FreeRTOS/tasks.c **** priority order).  However, it is occasionally borrowed for other purposes.  It
 381:../FreeRTOS/tasks.c **** is important its value is not updated due to a task priority change while it is
 382:../FreeRTOS/tasks.c **** being used for another purpose.  The following bit definition is used to inform
 383:../FreeRTOS/tasks.c **** the scheduler that the value should not be changed - in which case it is the
 384:../FreeRTOS/tasks.c **** responsibility of whichever module is using the value to ensure it gets set back
 385:../FreeRTOS/tasks.c **** to its original value when it is released. */
 386:../FreeRTOS/tasks.c **** #if configUSE_16_BIT_TICKS == 1
 387:../FreeRTOS/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
 388:../FreeRTOS/tasks.c **** #else
 389:../FreeRTOS/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
 390:../FreeRTOS/tasks.c **** #endif
 391:../FreeRTOS/tasks.c **** 
 392:../FreeRTOS/tasks.c **** /* Callback function prototypes. --------------------------*/
 393:../FreeRTOS/tasks.c **** #if configCHECK_FOR_STACK_OVERFLOW > 0
 394:../FreeRTOS/tasks.c **** 	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
 395:../FreeRTOS/tasks.c **** #endif
 396:../FreeRTOS/tasks.c **** 
 397:../FreeRTOS/tasks.c **** #if configUSE_TICK_HOOK > 0
 398:../FreeRTOS/tasks.c **** 	extern void vApplicationTickHook( void );
 399:../FreeRTOS/tasks.c **** #endif
 400:../FreeRTOS/tasks.c **** 
 401:../FreeRTOS/tasks.c **** /* File private functions. --------------------------------*/
 402:../FreeRTOS/tasks.c **** 
 403:../FreeRTOS/tasks.c **** /*
 404:../FreeRTOS/tasks.c ****  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
 405:../FreeRTOS/tasks.c ****  * into the TCB structure.
 406:../FreeRTOS/tasks.c ****  */
 407:../FreeRTOS/tasks.c **** static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t 
 408:../FreeRTOS/tasks.c **** 
 409:../FreeRTOS/tasks.c **** /**
 410:../FreeRTOS/tasks.c ****  * Utility task that simply returns pdTRUE if the task referenced by xTask is
 411:../FreeRTOS/tasks.c ****  * currently in the Suspended state, or pdFALSE if the task referenced by xTask
 412:../FreeRTOS/tasks.c ****  * is in any other state.
 413:../FreeRTOS/tasks.c ****  */
 414:../FreeRTOS/tasks.c **** static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
 415:../FreeRTOS/tasks.c **** 
 416:../FreeRTOS/tasks.c **** /*
 417:../FreeRTOS/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 418:../FreeRTOS/tasks.c ****  * automatically upon the creation of the first task.
 419:../FreeRTOS/tasks.c ****  */
 420:../FreeRTOS/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 421:../FreeRTOS/tasks.c **** 
 422:../FreeRTOS/tasks.c **** /*
 423:../FreeRTOS/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 424:../FreeRTOS/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 425:../FreeRTOS/tasks.c ****  * creation of the first user task.
 426:../FreeRTOS/tasks.c ****  *
 427:../FreeRTOS/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 428:../FreeRTOS/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 429:../FreeRTOS/tasks.c ****  *
 430:../FreeRTOS/tasks.c ****  * void prvIdleTask( void *pvParameters );
 431:../FreeRTOS/tasks.c ****  *
 432:../FreeRTOS/tasks.c ****  */
 433:../FreeRTOS/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 434:../FreeRTOS/tasks.c **** 
 435:../FreeRTOS/tasks.c **** /*
 436:../FreeRTOS/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 437:../FreeRTOS/tasks.c ****  * including the stack pointed to by the TCB.
 438:../FreeRTOS/tasks.c ****  *
 439:../FreeRTOS/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 440:../FreeRTOS/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 441:../FreeRTOS/tasks.c ****  */
 442:../FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 443:../FreeRTOS/tasks.c **** 
 444:../FreeRTOS/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
 445:../FreeRTOS/tasks.c **** 
 446:../FreeRTOS/tasks.c **** #endif
 447:../FreeRTOS/tasks.c **** 
 448:../FreeRTOS/tasks.c **** /*
 449:../FreeRTOS/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 450:../FreeRTOS/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 451:../FreeRTOS/tasks.c ****  * and its TCB deleted.
 452:../FreeRTOS/tasks.c ****  */
 453:../FreeRTOS/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 454:../FreeRTOS/tasks.c **** 
 455:../FreeRTOS/tasks.c **** /*
 456:../FreeRTOS/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 457:../FreeRTOS/tasks.c ****  * either the current or the overflow delayed task list.
 458:../FreeRTOS/tasks.c ****  */
 459:../FreeRTOS/tasks.c **** static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake ) PRIVILEGED_FUNCTION;
 460:../FreeRTOS/tasks.c **** 
 461:../FreeRTOS/tasks.c **** /*
 462:../FreeRTOS/tasks.c ****  * Allocates memory from the heap for a TCB and associated stack.  Checks the
 463:../FreeRTOS/tasks.c ****  * allocation was successful.
 464:../FreeRTOS/tasks.c ****  */
 465:../FreeRTOS/tasks.c **** static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuff
 466:../FreeRTOS/tasks.c **** 
 467:../FreeRTOS/tasks.c **** /*
 468:../FreeRTOS/tasks.c ****  * Fills an TaskStatus_t structure with information on each task that is
 469:../FreeRTOS/tasks.c ****  * referenced from the pxList list (which may be a ready list, a delayed list,
 470:../FreeRTOS/tasks.c ****  * a suspended list, etc.).
 471:../FreeRTOS/tasks.c ****  *
 472:../FreeRTOS/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 473:../FreeRTOS/tasks.c ****  * NORMAL APPLICATION CODE.
 474:../FreeRTOS/tasks.c ****  */
 475:../FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 476:../FreeRTOS/tasks.c **** 
 477:../FreeRTOS/tasks.c **** 	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, e
 478:../FreeRTOS/tasks.c **** 
 479:../FreeRTOS/tasks.c **** #endif
 480:../FreeRTOS/tasks.c **** 
 481:../FreeRTOS/tasks.c **** /*
 482:../FreeRTOS/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 483:../FreeRTOS/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 484:../FreeRTOS/tasks.c ****  * determining how much of the stack remains at the original preset value.
 485:../FreeRTOS/tasks.c ****  */
 486:../FreeRTOS/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 487:../FreeRTOS/tasks.c **** 
 488:../FreeRTOS/tasks.c **** 	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGED_FUNCTION;
 489:../FreeRTOS/tasks.c **** 
 490:../FreeRTOS/tasks.c **** #endif
 491:../FreeRTOS/tasks.c **** 
 492:../FreeRTOS/tasks.c **** /*
 493:../FreeRTOS/tasks.c ****  * Return the amount of time, in ticks, that will pass before the kernel will
 494:../FreeRTOS/tasks.c ****  * next move a task from the Blocked state to the Running state.
 495:../FreeRTOS/tasks.c ****  *
 496:../FreeRTOS/tasks.c ****  * This conditional compilation should use inequality to 0, not equality to 1.
 497:../FreeRTOS/tasks.c ****  * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
 498:../FreeRTOS/tasks.c ****  * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
 499:../FreeRTOS/tasks.c ****  * set to a value other than 1.
 500:../FreeRTOS/tasks.c ****  */
 501:../FreeRTOS/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
 502:../FreeRTOS/tasks.c **** 
 503:../FreeRTOS/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
 504:../FreeRTOS/tasks.c **** 
 505:../FreeRTOS/tasks.c **** #endif
 506:../FreeRTOS/tasks.c **** 
 507:../FreeRTOS/tasks.c **** /*
 508:../FreeRTOS/tasks.c ****  * Set xNextTaskUnblockTime to the time at which the next Blocked state task
 509:../FreeRTOS/tasks.c ****  * will exit the Blocked state.
 510:../FreeRTOS/tasks.c ****  */
 511:../FreeRTOS/tasks.c **** static void prvResetNextTaskUnblockTime( void );
 512:../FreeRTOS/tasks.c **** 
 513:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 514:../FreeRTOS/tasks.c **** 
 515:../FreeRTOS/tasks.c **** BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t
 516:../FreeRTOS/tasks.c **** {
  95              		.loc 1 516 0
  96              		.cfi_startproc
  97              		@ args = 16, pretend = 0, frame = 32
  98              		@ frame_needed = 1, uses_anonymous_args = 0
  99 0000 80B5     		push	{r7, lr}
 100              		.cfi_def_cfa_offset 8
 101              		.cfi_offset 7, -8
 102              		.cfi_offset 14, -4
 103 0002 8AB0     		sub	sp, sp, #40
 104              		.cfi_def_cfa_offset 48
 105 0004 02AF     		add	r7, sp, #8
 106              		.cfi_def_cfa 7, 40
 107 0006 F860     		str	r0, [r7, #12]
 108 0008 B960     		str	r1, [r7, #8]
 109 000a 3B60     		str	r3, [r7]
 110 000c 1346     		mov	r3, r2	@ movhi
 111 000e FB80     		strh	r3, [r7, #6]	@ movhi
 517:../FreeRTOS/tasks.c **** BaseType_t xReturn;
 518:../FreeRTOS/tasks.c **** TCB_t * pxNewTCB;
 519:../FreeRTOS/tasks.c **** 
 520:../FreeRTOS/tasks.c **** 	configASSERT( pxTaskCode );
 521:../FreeRTOS/tasks.c **** 	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
 522:../FreeRTOS/tasks.c **** 
 523:../FreeRTOS/tasks.c **** 	/* Allocate the memory required by the TCB and stack for the new task,
 524:../FreeRTOS/tasks.c **** 	checking that the allocation was successful. */
 525:../FreeRTOS/tasks.c **** 	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 112              		.loc 1 525 0
 113 0010 FB88     		ldrh	r3, [r7, #6]
 114 0012 1846     		mov	r0, r3
 115 0014 396B     		ldr	r1, [r7, #48]
 116 0016 01F0E1F8 		bl	prvAllocateTCBAndStack
 117 001a B861     		str	r0, [r7, #24]
 526:../FreeRTOS/tasks.c **** 
 527:../FreeRTOS/tasks.c **** 	if( pxNewTCB != NULL )
 118              		.loc 1 527 0
 119 001c BB69     		ldr	r3, [r7, #24]
 120 001e 002B     		cmp	r3, #0
 121 0020 00F08E80 		beq	.L2
 122              	.LBB2:
 528:../FreeRTOS/tasks.c **** 	{
 529:../FreeRTOS/tasks.c **** 		StackType_t *pxTopOfStack;
 530:../FreeRTOS/tasks.c **** 
 531:../FreeRTOS/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 532:../FreeRTOS/tasks.c **** 			/* Should the task be created in privileged mode? */
 533:../FreeRTOS/tasks.c **** 			BaseType_t xRunPrivileged;
 534:../FreeRTOS/tasks.c **** 			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 535:../FreeRTOS/tasks.c **** 			{
 536:../FreeRTOS/tasks.c **** 				xRunPrivileged = pdTRUE;
 537:../FreeRTOS/tasks.c **** 			}
 538:../FreeRTOS/tasks.c **** 			else
 539:../FreeRTOS/tasks.c **** 			{
 540:../FreeRTOS/tasks.c **** 				xRunPrivileged = pdFALSE;
 541:../FreeRTOS/tasks.c **** 			}
 542:../FreeRTOS/tasks.c **** 			uxPriority &= ~portPRIVILEGE_BIT;
 543:../FreeRTOS/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS == 1 */
 544:../FreeRTOS/tasks.c **** 
 545:../FreeRTOS/tasks.c **** 		/* Calculate the top of stack address.  This depends on whether the
 546:../FreeRTOS/tasks.c **** 		stack grows from high memory to low (as per the 80x86) or vice versa.
 547:../FreeRTOS/tasks.c **** 		portSTACK_GROWTH is used to make the result positive or negative as
 548:../FreeRTOS/tasks.c **** 		required by the port. */
 549:../FreeRTOS/tasks.c **** 		#if( portSTACK_GROWTH < 0 )
 550:../FreeRTOS/tasks.c **** 		{
 551:../FreeRTOS/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
 123              		.loc 1 551 0
 124 0024 BB69     		ldr	r3, [r7, #24]
 125 0026 1A6B     		ldr	r2, [r3, #48]
 126 0028 FB88     		ldrh	r3, [r7, #6]
 127 002a 03F18043 		add	r3, r3, #1073741824
 128 002e 013B     		subs	r3, r3, #1
 129 0030 9B00     		lsls	r3, r3, #2
 130 0032 1344     		add	r3, r3, r2
 131 0034 7B61     		str	r3, [r7, #20]
 552:../FreeRTOS/tasks.c **** 			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_
 132              		.loc 1 552 0
 133 0036 7B69     		ldr	r3, [r7, #20]
 134 0038 23F00703 		bic	r3, r3, #7
 135 003c 7B61     		str	r3, [r7, #20]
 553:../FreeRTOS/tasks.c **** 
 554:../FreeRTOS/tasks.c **** 			/* Check the alignment of the calculated top of stack is correct. */
 555:../FreeRTOS/tasks.c **** 			configASSERT( ( ( ( uint32_t ) pxTopOfStack & ( uint32_t ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
 556:../FreeRTOS/tasks.c **** 		}
 557:../FreeRTOS/tasks.c **** 		#else /* portSTACK_GROWTH */
 558:../FreeRTOS/tasks.c **** 		{
 559:../FreeRTOS/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack;
 560:../FreeRTOS/tasks.c **** 
 561:../FreeRTOS/tasks.c **** 			/* Check the alignment of the stack buffer is correct. */
 562:../FreeRTOS/tasks.c **** 			configASSERT( ( ( ( uint32_t ) pxNewTCB->pxStack & ( uint32_t ) portBYTE_ALIGNMENT_MASK ) == 0UL
 563:../FreeRTOS/tasks.c **** 
 564:../FreeRTOS/tasks.c **** 			/* If we want to use stack checking on architectures that use
 565:../FreeRTOS/tasks.c **** 			a positive stack growth direction then we also need to store the
 566:../FreeRTOS/tasks.c **** 			other extreme of the stack space. */
 567:../FreeRTOS/tasks.c **** 			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 568:../FreeRTOS/tasks.c **** 		}
 569:../FreeRTOS/tasks.c **** 		#endif /* portSTACK_GROWTH */
 570:../FreeRTOS/tasks.c **** 
 571:../FreeRTOS/tasks.c **** 		/* Setup the newly allocated TCB with the initial state of the task. */
 572:../FreeRTOS/tasks.c **** 		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 136              		.loc 1 572 0
 137 003e FB88     		ldrh	r3, [r7, #6]
 138 0040 0093     		str	r3, [sp]
 139 0042 B869     		ldr	r0, [r7, #24]
 140 0044 B968     		ldr	r1, [r7, #8]
 141 0046 BA6A     		ldr	r2, [r7, #40]
 142 0048 7B6B     		ldr	r3, [r7, #52]
 143 004a 00F0A5FF 		bl	prvInitialiseTCBVariables
 573:../FreeRTOS/tasks.c **** 
 574:../FreeRTOS/tasks.c **** 		/* Initialize the TCB stack to look as if the task was already running,
 575:../FreeRTOS/tasks.c **** 		but had been interrupted by the scheduler.  The return address is set
 576:../FreeRTOS/tasks.c **** 		to the start of the task function. Once the stack has been initialised
 577:../FreeRTOS/tasks.c **** 		the	top of stack variable is updated. */
 578:../FreeRTOS/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 579:../FreeRTOS/tasks.c **** 		{
 580:../FreeRTOS/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPriv
 581:../FreeRTOS/tasks.c **** 		}
 582:../FreeRTOS/tasks.c **** 		#else /* portUSING_MPU_WRAPPERS */
 583:../FreeRTOS/tasks.c **** 		{
 584:../FreeRTOS/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 144              		.loc 1 584 0
 145 004e 7869     		ldr	r0, [r7, #20]
 146 0050 F968     		ldr	r1, [r7, #12]
 147 0052 3A68     		ldr	r2, [r7]
 148 0054 FFF7FEFF 		bl	pxPortInitialiseStack
 149 0058 0246     		mov	r2, r0
 150 005a BB69     		ldr	r3, [r7, #24]
 151 005c 1A60     		str	r2, [r3]
 585:../FreeRTOS/tasks.c **** 		}
 586:../FreeRTOS/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS */
 587:../FreeRTOS/tasks.c **** 
 588:../FreeRTOS/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 152              		.loc 1 588 0
 153 005e FB6A     		ldr	r3, [r7, #44]
 154 0060 002B     		cmp	r3, #0
 155 0062 02D0     		beq	.L3
 589:../FreeRTOS/tasks.c **** 		{
 590:../FreeRTOS/tasks.c **** 			/* Pass the TCB out - in an anonymous way.  The calling function/
 591:../FreeRTOS/tasks.c **** 			task can use this as a handle to delete the task later if
 592:../FreeRTOS/tasks.c **** 			required.*/
 593:../FreeRTOS/tasks.c **** 			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 156              		.loc 1 593 0
 157 0064 FB6A     		ldr	r3, [r7, #44]
 158 0066 BA69     		ldr	r2, [r7, #24]
 159 0068 1A60     		str	r2, [r3]
 160              	.L3:
 594:../FreeRTOS/tasks.c **** 		}
 595:../FreeRTOS/tasks.c **** 		else
 596:../FreeRTOS/tasks.c **** 		{
 597:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 598:../FreeRTOS/tasks.c **** 		}
 599:../FreeRTOS/tasks.c **** 
 600:../FreeRTOS/tasks.c **** 		/* Ensure interrupts don't access the task lists while they are being
 601:../FreeRTOS/tasks.c **** 		updated. */
 602:../FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
 161              		.loc 1 602 0
 162 006a FFF7FEFF 		bl	vPortEnterCritical
 603:../FreeRTOS/tasks.c **** 		{
 604:../FreeRTOS/tasks.c **** 			uxCurrentNumberOfTasks++;
 163              		.loc 1 604 0
 164 006e 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 165 0072 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 166 0076 1B68     		ldr	r3, [r3]
 167 0078 5A1C     		adds	r2, r3, #1
 168 007a 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 169 007e C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 170 0082 1A60     		str	r2, [r3]
 605:../FreeRTOS/tasks.c **** 			if( pxCurrentTCB == NULL )
 171              		.loc 1 605 0
 172 0084 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 173 0088 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 174 008c 1B68     		ldr	r3, [r3]
 175 008e 002B     		cmp	r3, #0
 176 0090 0FD1     		bne	.L4
 606:../FreeRTOS/tasks.c **** 			{
 607:../FreeRTOS/tasks.c **** 				/* There are no other tasks, or all the other tasks are in
 608:../FreeRTOS/tasks.c **** 				the suspended state - make this the current task. */
 609:../FreeRTOS/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 177              		.loc 1 609 0
 178 0092 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 179 0096 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 180 009a BA69     		ldr	r2, [r7, #24]
 181 009c 1A60     		str	r2, [r3]
 610:../FreeRTOS/tasks.c **** 
 611:../FreeRTOS/tasks.c **** 				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 182              		.loc 1 611 0
 183 009e 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 184 00a2 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 185 00a6 1B68     		ldr	r3, [r3]
 186 00a8 012B     		cmp	r3, #1
 187 00aa 18D1     		bne	.L5
 612:../FreeRTOS/tasks.c **** 				{
 613:../FreeRTOS/tasks.c **** 					/* This is the first task to be created so do the preliminary
 614:../FreeRTOS/tasks.c **** 					initialisation required.  We will not recover if this call
 615:../FreeRTOS/tasks.c **** 					fails, but we will report the failure. */
 616:../FreeRTOS/tasks.c **** 					prvInitialiseTaskLists();
 188              		.loc 1 616 0
 189 00ac 00F0BCFF 		bl	prvInitialiseTaskLists
 190 00b0 15E0     		b	.L5
 191              	.L4:
 617:../FreeRTOS/tasks.c **** 				}
 618:../FreeRTOS/tasks.c **** 				else
 619:../FreeRTOS/tasks.c **** 				{
 620:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
 621:../FreeRTOS/tasks.c **** 				}
 622:../FreeRTOS/tasks.c **** 			}
 623:../FreeRTOS/tasks.c **** 			else
 624:../FreeRTOS/tasks.c **** 			{
 625:../FreeRTOS/tasks.c **** 				/* If the scheduler is not already running, make this task the
 626:../FreeRTOS/tasks.c **** 				current task if it is the highest priority task to be created
 627:../FreeRTOS/tasks.c **** 				so far. */
 628:../FreeRTOS/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 192              		.loc 1 628 0
 193 00b2 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 194 00b6 C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 195 00ba 1B68     		ldr	r3, [r3]
 196 00bc 002B     		cmp	r3, #0
 197 00be 0ED1     		bne	.L5
 629:../FreeRTOS/tasks.c **** 				{
 630:../FreeRTOS/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 198              		.loc 1 630 0
 199 00c0 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 200 00c4 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 201 00c8 1B68     		ldr	r3, [r3]
 202 00ca DA6A     		ldr	r2, [r3, #44]
 203 00cc BB6A     		ldr	r3, [r7, #40]
 204 00ce 9A42     		cmp	r2, r3
 205 00d0 05D8     		bhi	.L5
 631:../FreeRTOS/tasks.c **** 					{
 632:../FreeRTOS/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 206              		.loc 1 632 0
 207 00d2 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 208 00d6 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 209 00da BA69     		ldr	r2, [r7, #24]
 210 00dc 1A60     		str	r2, [r3]
 211              	.L5:
 633:../FreeRTOS/tasks.c **** 					}
 634:../FreeRTOS/tasks.c **** 					else
 635:../FreeRTOS/tasks.c **** 					{
 636:../FreeRTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
 637:../FreeRTOS/tasks.c **** 					}
 638:../FreeRTOS/tasks.c **** 				}
 639:../FreeRTOS/tasks.c **** 				else
 640:../FreeRTOS/tasks.c **** 				{
 641:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
 642:../FreeRTOS/tasks.c **** 				}
 643:../FreeRTOS/tasks.c **** 			}
 644:../FreeRTOS/tasks.c **** 
 645:../FreeRTOS/tasks.c **** 			uxTaskNumber++;
 212              		.loc 1 645 0
 213 00de 40F20003 		movw	r3, #:lower16:uxTaskNumber
 214 00e2 C0F20003 		movt	r3, #:upper16:uxTaskNumber
 215 00e6 1B68     		ldr	r3, [r3]
 216 00e8 5A1C     		adds	r2, r3, #1
 217 00ea 40F20003 		movw	r3, #:lower16:uxTaskNumber
 218 00ee C0F20003 		movt	r3, #:upper16:uxTaskNumber
 219 00f2 1A60     		str	r2, [r3]
 646:../FreeRTOS/tasks.c **** 
 647:../FreeRTOS/tasks.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 648:../FreeRTOS/tasks.c **** 			{
 649:../FreeRTOS/tasks.c **** 				/* Add a counter into the TCB for tracing only. */
 650:../FreeRTOS/tasks.c **** 				pxNewTCB->uxTCBNumber = uxTaskNumber;
 651:../FreeRTOS/tasks.c **** 			}
 652:../FreeRTOS/tasks.c **** 			#endif /* configUSE_TRACE_FACILITY */
 653:../FreeRTOS/tasks.c **** 			traceTASK_CREATE( pxNewTCB );
 654:../FreeRTOS/tasks.c **** 
 655:../FreeRTOS/tasks.c **** 			prvAddTaskToReadyList( pxNewTCB );
 220              		.loc 1 655 0
 221 00f4 BB69     		ldr	r3, [r7, #24]
 222 00f6 DA6A     		ldr	r2, [r3, #44]
 223 00f8 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 224 00fc C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 225 0100 1B68     		ldr	r3, [r3]
 226 0102 9A42     		cmp	r2, r3
 227 0104 06D9     		bls	.L6
 228              		.loc 1 655 0 is_stmt 0 discriminator 1
 229 0106 BB69     		ldr	r3, [r7, #24]
 230 0108 DA6A     		ldr	r2, [r3, #44]
 231 010a 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 232 010e C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 233 0112 1A60     		str	r2, [r3]
 234              	.L6:
 235              		.loc 1 655 0 discriminator 2
 236 0114 BB69     		ldr	r3, [r7, #24]
 237 0116 DA6A     		ldr	r2, [r3, #44]
 238 0118 1346     		mov	r3, r2
 239 011a 9B00     		lsls	r3, r3, #2
 240 011c 1344     		add	r3, r3, r2
 241 011e 9B00     		lsls	r3, r3, #2
 242 0120 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 243 0124 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 244 0128 1A44     		add	r2, r2, r3
 245 012a BB69     		ldr	r3, [r7, #24]
 246 012c 0433     		adds	r3, r3, #4
 247 012e 1046     		mov	r0, r2
 248 0130 1946     		mov	r1, r3
 249 0132 FFF7FEFF 		bl	vListInsertEnd
 656:../FreeRTOS/tasks.c **** 
 657:../FreeRTOS/tasks.c **** 			xReturn = pdPASS;
 250              		.loc 1 657 0 is_stmt 1 discriminator 2
 251 0136 0123     		movs	r3, #1
 252 0138 FB61     		str	r3, [r7, #28]
 658:../FreeRTOS/tasks.c **** 			portSETUP_TCB( pxNewTCB );
 659:../FreeRTOS/tasks.c **** 		}
 660:../FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
 253              		.loc 1 660 0 discriminator 2
 254 013a FFF7FEFF 		bl	vPortExitCritical
 255              	.LBE2:
 256 013e 02E0     		b	.L7
 257              	.L2:
 661:../FreeRTOS/tasks.c **** 	}
 662:../FreeRTOS/tasks.c **** 	else
 663:../FreeRTOS/tasks.c **** 	{
 664:../FreeRTOS/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 258              		.loc 1 664 0
 259 0140 4FF0FF33 		mov	r3, #-1
 260 0144 FB61     		str	r3, [r7, #28]
 261              	.L7:
 665:../FreeRTOS/tasks.c **** 		traceTASK_CREATE_FAILED();
 666:../FreeRTOS/tasks.c **** 	}
 667:../FreeRTOS/tasks.c **** 
 668:../FreeRTOS/tasks.c **** 	if( xReturn == pdPASS )
 262              		.loc 1 668 0
 263 0146 FB69     		ldr	r3, [r7, #28]
 264 0148 012B     		cmp	r3, #1
 265 014a 11D1     		bne	.L8
 669:../FreeRTOS/tasks.c **** 	{
 670:../FreeRTOS/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 266              		.loc 1 670 0
 267 014c 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 268 0150 C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 269 0154 1B68     		ldr	r3, [r3]
 270 0156 002B     		cmp	r3, #0
 271 0158 0AD0     		beq	.L8
 671:../FreeRTOS/tasks.c **** 		{
 672:../FreeRTOS/tasks.c **** 			/* If the created task is of a higher priority than the current task
 673:../FreeRTOS/tasks.c **** 			then it should run now. */
 674:../FreeRTOS/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 272              		.loc 1 674 0
 273 015a 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 274 015e C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 275 0162 1B68     		ldr	r3, [r3]
 276 0164 DA6A     		ldr	r2, [r3, #44]
 277 0166 BB6A     		ldr	r3, [r7, #40]
 278 0168 9A42     		cmp	r2, r3
 279 016a 01D2     		bcs	.L8
 675:../FreeRTOS/tasks.c **** 			{
 676:../FreeRTOS/tasks.c **** 				taskYIELD_IF_USING_PREEMPTION();
 280              		.loc 1 676 0
 281 016c FFF7FEFF 		bl	vPortYield
 282              	.L8:
 677:../FreeRTOS/tasks.c **** 			}
 678:../FreeRTOS/tasks.c **** 			else
 679:../FreeRTOS/tasks.c **** 			{
 680:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
 681:../FreeRTOS/tasks.c **** 			}
 682:../FreeRTOS/tasks.c **** 		}
 683:../FreeRTOS/tasks.c **** 		else
 684:../FreeRTOS/tasks.c **** 		{
 685:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 686:../FreeRTOS/tasks.c **** 		}
 687:../FreeRTOS/tasks.c **** 	}
 688:../FreeRTOS/tasks.c **** 
 689:../FreeRTOS/tasks.c **** 	return xReturn;
 283              		.loc 1 689 0
 284 0170 FB69     		ldr	r3, [r7, #28]
 690:../FreeRTOS/tasks.c **** }
 285              		.loc 1 690 0
 286 0172 1846     		mov	r0, r3
 287 0174 2037     		adds	r7, r7, #32
 288 0176 BD46     		mov	sp, r7
 289              		@ sp needed
 290 0178 80BD     		pop	{r7, pc}
 291              		.cfi_endproc
 292              	.LFE0:
 294 017a 00BF     		.align	2
 295              		.global	vTaskDelete
 296              		.thumb
 297              		.thumb_func
 299              	vTaskDelete:
 300              	.LFB1:
 691:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 692:../FreeRTOS/tasks.c **** 
 693:../FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 694:../FreeRTOS/tasks.c **** 
 695:../FreeRTOS/tasks.c **** 	void vTaskDelete( TaskHandle_t xTaskToDelete )
 696:../FreeRTOS/tasks.c **** 	{
 301              		.loc 1 696 0
 302              		.cfi_startproc
 303              		@ args = 0, pretend = 0, frame = 16
 304              		@ frame_needed = 1, uses_anonymous_args = 0
 305 017c 80B5     		push	{r7, lr}
 306              		.cfi_def_cfa_offset 8
 307              		.cfi_offset 7, -8
 308              		.cfi_offset 14, -4
 309 017e 84B0     		sub	sp, sp, #16
 310              		.cfi_def_cfa_offset 24
 311 0180 00AF     		add	r7, sp, #0
 312              		.cfi_def_cfa_register 7
 313 0182 7860     		str	r0, [r7, #4]
 697:../FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
 698:../FreeRTOS/tasks.c **** 
 699:../FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
 314              		.loc 1 699 0
 315 0184 FFF7FEFF 		bl	vPortEnterCritical
 700:../FreeRTOS/tasks.c **** 		{
 701:../FreeRTOS/tasks.c **** 			/* If null is passed in here then it is the calling task that is
 702:../FreeRTOS/tasks.c **** 			being deleted. */
 703:../FreeRTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 316              		.loc 1 703 0
 317 0188 7B68     		ldr	r3, [r7, #4]
 318 018a 002B     		cmp	r3, #0
 319 018c 05D1     		bne	.L11
 320              		.loc 1 703 0 is_stmt 0 discriminator 1
 321 018e 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 322 0192 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 323 0196 1B68     		ldr	r3, [r3]
 324 0198 00E0     		b	.L12
 325              	.L11:
 326              		.loc 1 703 0 discriminator 2
 327 019a 7B68     		ldr	r3, [r7, #4]
 328              	.L12:
 329              		.loc 1 703 0 discriminator 3
 330 019c FB60     		str	r3, [r7, #12]
 704:../FreeRTOS/tasks.c **** 
 705:../FreeRTOS/tasks.c **** 			/* Remove task from the ready list and place in the	termination list.
 706:../FreeRTOS/tasks.c **** 			This will stop the task from be scheduled.  The idle task will check
 707:../FreeRTOS/tasks.c **** 			the termination list and free up any memory allocated by the
 708:../FreeRTOS/tasks.c **** 			scheduler for the TCB and stack. */
 709:../FreeRTOS/tasks.c **** 			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 331              		.loc 1 709 0 is_stmt 1 discriminator 3
 332 019e FB68     		ldr	r3, [r7, #12]
 333 01a0 0433     		adds	r3, r3, #4
 334 01a2 1846     		mov	r0, r3
 335 01a4 FFF7FEFF 		bl	uxListRemove
 710:../FreeRTOS/tasks.c **** 			{
 711:../FreeRTOS/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 712:../FreeRTOS/tasks.c **** 			}
 713:../FreeRTOS/tasks.c **** 			else
 714:../FreeRTOS/tasks.c **** 			{
 715:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
 716:../FreeRTOS/tasks.c **** 			}
 717:../FreeRTOS/tasks.c **** 
 718:../FreeRTOS/tasks.c **** 			/* Is the task waiting on an event also? */
 719:../FreeRTOS/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 336              		.loc 1 719 0 discriminator 3
 337 01a8 FB68     		ldr	r3, [r7, #12]
 338 01aa 9B6A     		ldr	r3, [r3, #40]
 339 01ac 002B     		cmp	r3, #0
 340 01ae 04D0     		beq	.L13
 720:../FreeRTOS/tasks.c **** 			{
 721:../FreeRTOS/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 341              		.loc 1 721 0
 342 01b0 FB68     		ldr	r3, [r7, #12]
 343 01b2 1833     		adds	r3, r3, #24
 344 01b4 1846     		mov	r0, r3
 345 01b6 FFF7FEFF 		bl	uxListRemove
 346              	.L13:
 722:../FreeRTOS/tasks.c **** 			}
 723:../FreeRTOS/tasks.c **** 			else
 724:../FreeRTOS/tasks.c **** 			{
 725:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
 726:../FreeRTOS/tasks.c **** 			}
 727:../FreeRTOS/tasks.c **** 
 728:../FreeRTOS/tasks.c **** 			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 347              		.loc 1 728 0
 348 01ba FB68     		ldr	r3, [r7, #12]
 349 01bc 0433     		adds	r3, r3, #4
 350 01be 40F20000 		movw	r0, #:lower16:xTasksWaitingTermination
 351 01c2 C0F20000 		movt	r0, #:upper16:xTasksWaitingTermination
 352 01c6 1946     		mov	r1, r3
 353 01c8 FFF7FEFF 		bl	vListInsertEnd
 729:../FreeRTOS/tasks.c **** 
 730:../FreeRTOS/tasks.c **** 			/* Increment the ucTasksDeleted variable so the idle task knows
 731:../FreeRTOS/tasks.c **** 			there is a task that has been deleted and that it should therefore
 732:../FreeRTOS/tasks.c **** 			check the xTasksWaitingTermination list. */
 733:../FreeRTOS/tasks.c **** 			++uxTasksDeleted;
 354              		.loc 1 733 0
 355 01cc 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 356 01d0 C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 357 01d4 1B68     		ldr	r3, [r3]
 358 01d6 5A1C     		adds	r2, r3, #1
 359 01d8 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 360 01dc C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 361 01e0 1A60     		str	r2, [r3]
 734:../FreeRTOS/tasks.c **** 
 735:../FreeRTOS/tasks.c **** 			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
 736:../FreeRTOS/tasks.c **** 			can detect that the task lists need re-generating. */
 737:../FreeRTOS/tasks.c **** 			uxTaskNumber++;
 362              		.loc 1 737 0
 363 01e2 40F20003 		movw	r3, #:lower16:uxTaskNumber
 364 01e6 C0F20003 		movt	r3, #:upper16:uxTaskNumber
 365 01ea 1B68     		ldr	r3, [r3]
 366 01ec 5A1C     		adds	r2, r3, #1
 367 01ee 40F20003 		movw	r3, #:lower16:uxTaskNumber
 368 01f2 C0F20003 		movt	r3, #:upper16:uxTaskNumber
 369 01f6 1A60     		str	r2, [r3]
 738:../FreeRTOS/tasks.c **** 
 739:../FreeRTOS/tasks.c **** 			traceTASK_DELETE( pxTCB );
 740:../FreeRTOS/tasks.c **** 		}
 741:../FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
 370              		.loc 1 741 0
 371 01f8 FFF7FEFF 		bl	vPortExitCritical
 742:../FreeRTOS/tasks.c **** 
 743:../FreeRTOS/tasks.c **** 		/* Force a reschedule if it is the currently running task that has just
 744:../FreeRTOS/tasks.c **** 		been deleted. */
 745:../FreeRTOS/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 372              		.loc 1 745 0
 373 01fc 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 374 0200 C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 375 0204 1B68     		ldr	r3, [r3]
 376 0206 002B     		cmp	r3, #0
 377 0208 10D0     		beq	.L10
 746:../FreeRTOS/tasks.c **** 		{
 747:../FreeRTOS/tasks.c **** 			if( pxTCB == pxCurrentTCB )
 378              		.loc 1 747 0
 379 020a 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 380 020e C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 381 0212 1B68     		ldr	r3, [r3]
 382 0214 FA68     		ldr	r2, [r7, #12]
 383 0216 9A42     		cmp	r2, r3
 384 0218 02D1     		bne	.L15
 748:../FreeRTOS/tasks.c **** 			{
 749:../FreeRTOS/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
 750:../FreeRTOS/tasks.c **** 
 751:../FreeRTOS/tasks.c **** 				/* The pre-delete hook is primarily for the Windows simulator,
 752:../FreeRTOS/tasks.c **** 				in which Windows specific clean up operations are performed,
 753:../FreeRTOS/tasks.c **** 				after which it is not possible to yield away from this task -
 754:../FreeRTOS/tasks.c **** 				hence xYieldPending is used to latch that a context switch is
 755:../FreeRTOS/tasks.c **** 				required. */
 756:../FreeRTOS/tasks.c **** 				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
 757:../FreeRTOS/tasks.c **** 				portYIELD_WITHIN_API();
 385              		.loc 1 757 0
 386 021a FFF7FEFF 		bl	vPortYield
 387 021e 05E0     		b	.L10
 388              	.L15:
 758:../FreeRTOS/tasks.c **** 			}
 759:../FreeRTOS/tasks.c **** 			else
 760:../FreeRTOS/tasks.c **** 			{
 761:../FreeRTOS/tasks.c **** 				/* Reset the next expected unblock time in case it referred to
 762:../FreeRTOS/tasks.c **** 				the task that has just been deleted. */
 763:../FreeRTOS/tasks.c **** 				taskENTER_CRITICAL();
 389              		.loc 1 763 0
 390 0220 FFF7FEFF 		bl	vPortEnterCritical
 764:../FreeRTOS/tasks.c **** 				{
 765:../FreeRTOS/tasks.c **** 					prvResetNextTaskUnblockTime();
 391              		.loc 1 765 0
 392 0224 01F054F8 		bl	prvResetNextTaskUnblockTime
 766:../FreeRTOS/tasks.c **** 				}
 767:../FreeRTOS/tasks.c **** 				taskEXIT_CRITICAL();
 393              		.loc 1 767 0
 394 0228 FFF7FEFF 		bl	vPortExitCritical
 395              	.L10:
 768:../FreeRTOS/tasks.c **** 			}
 769:../FreeRTOS/tasks.c **** 		}
 770:../FreeRTOS/tasks.c **** 	}
 396              		.loc 1 770 0
 397 022c 1037     		adds	r7, r7, #16
 398 022e BD46     		mov	sp, r7
 399              		@ sp needed
 400 0230 80BD     		pop	{r7, pc}
 401              		.cfi_endproc
 402              	.LFE1:
 404 0232 00BF     		.align	2
 405              		.global	vTaskDelayUntil
 406              		.thumb
 407              		.thumb_func
 409              	vTaskDelayUntil:
 410              	.LFB2:
 771:../FreeRTOS/tasks.c **** 
 772:../FreeRTOS/tasks.c **** #endif /* INCLUDE_vTaskDelete */
 773:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 774:../FreeRTOS/tasks.c **** 
 775:../FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
 776:../FreeRTOS/tasks.c **** 
 777:../FreeRTOS/tasks.c **** 	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
 778:../FreeRTOS/tasks.c **** 	{
 411              		.loc 1 778 0
 412              		.cfi_startproc
 413              		@ args = 0, pretend = 0, frame = 24
 414              		@ frame_needed = 1, uses_anonymous_args = 0
 415 0234 80B5     		push	{r7, lr}
 416              		.cfi_def_cfa_offset 8
 417              		.cfi_offset 7, -8
 418              		.cfi_offset 14, -4
 419 0236 86B0     		sub	sp, sp, #24
 420              		.cfi_def_cfa_offset 32
 421 0238 00AF     		add	r7, sp, #0
 422              		.cfi_def_cfa_register 7
 423 023a 7860     		str	r0, [r7, #4]
 424 023c 3960     		str	r1, [r7]
 779:../FreeRTOS/tasks.c **** 	TickType_t xTimeToWake;
 780:../FreeRTOS/tasks.c **** 	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
 425              		.loc 1 780 0
 426 023e 0023     		movs	r3, #0
 427 0240 7B61     		str	r3, [r7, #20]
 781:../FreeRTOS/tasks.c **** 
 782:../FreeRTOS/tasks.c **** 		configASSERT( pxPreviousWakeTime );
 783:../FreeRTOS/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
 784:../FreeRTOS/tasks.c **** 		configASSERT( uxSchedulerSuspended == 0 );
 785:../FreeRTOS/tasks.c **** 
 786:../FreeRTOS/tasks.c **** 		vTaskSuspendAll();
 428              		.loc 1 786 0
 429 0242 FFF7FEFF 		bl	vTaskSuspendAll
 430              	.LBB3:
 787:../FreeRTOS/tasks.c **** 		{
 788:../FreeRTOS/tasks.c **** 			/* Minor optimisation.  The tick count cannot change in this
 789:../FreeRTOS/tasks.c **** 			block. */
 790:../FreeRTOS/tasks.c **** 			const TickType_t xConstTickCount = xTickCount;
 431              		.loc 1 790 0
 432 0246 40F20003 		movw	r3, #:lower16:xTickCount
 433 024a C0F20003 		movt	r3, #:upper16:xTickCount
 434 024e 1B68     		ldr	r3, [r3]
 435 0250 3B61     		str	r3, [r7, #16]
 791:../FreeRTOS/tasks.c **** 
 792:../FreeRTOS/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
 793:../FreeRTOS/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 436              		.loc 1 793 0
 437 0252 7B68     		ldr	r3, [r7, #4]
 438 0254 1A68     		ldr	r2, [r3]
 439 0256 3B68     		ldr	r3, [r7]
 440 0258 1344     		add	r3, r3, r2
 441 025a FB60     		str	r3, [r7, #12]
 794:../FreeRTOS/tasks.c **** 
 795:../FreeRTOS/tasks.c **** 			if( xConstTickCount < *pxPreviousWakeTime )
 442              		.loc 1 795 0
 443 025c 7B68     		ldr	r3, [r7, #4]
 444 025e 1A68     		ldr	r2, [r3]
 445 0260 3B69     		ldr	r3, [r7, #16]
 446 0262 9A42     		cmp	r2, r3
 447 0264 0BD9     		bls	.L17
 796:../FreeRTOS/tasks.c **** 			{
 797:../FreeRTOS/tasks.c **** 				/* The tick count has overflowed since this function was
 798:../FreeRTOS/tasks.c **** 				lasted called.  In this case the only time we should ever
 799:../FreeRTOS/tasks.c **** 				actually delay is if the wake time has also	overflowed,
 800:../FreeRTOS/tasks.c **** 				and the wake time is greater than the tick time.  When this
 801:../FreeRTOS/tasks.c **** 				is the case it is as if neither time had overflowed. */
 802:../FreeRTOS/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 448              		.loc 1 802 0
 449 0266 7B68     		ldr	r3, [r7, #4]
 450 0268 1A68     		ldr	r2, [r3]
 451 026a FB68     		ldr	r3, [r7, #12]
 452 026c 9A42     		cmp	r2, r3
 453 026e 11D9     		bls	.L18
 454              		.loc 1 802 0 is_stmt 0 discriminator 1
 455 0270 FA68     		ldr	r2, [r7, #12]
 456 0272 3B69     		ldr	r3, [r7, #16]
 457 0274 9A42     		cmp	r2, r3
 458 0276 0DD9     		bls	.L18
 803:../FreeRTOS/tasks.c **** 				{
 804:../FreeRTOS/tasks.c **** 					xShouldDelay = pdTRUE;
 459              		.loc 1 804 0 is_stmt 1
 460 0278 0123     		movs	r3, #1
 461 027a 7B61     		str	r3, [r7, #20]
 462 027c 0AE0     		b	.L18
 463              	.L17:
 805:../FreeRTOS/tasks.c **** 				}
 806:../FreeRTOS/tasks.c **** 				else
 807:../FreeRTOS/tasks.c **** 				{
 808:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
 809:../FreeRTOS/tasks.c **** 				}
 810:../FreeRTOS/tasks.c **** 			}
 811:../FreeRTOS/tasks.c **** 			else
 812:../FreeRTOS/tasks.c **** 			{
 813:../FreeRTOS/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
 814:../FreeRTOS/tasks.c **** 				delay if either the wake time has overflowed, and/or the
 815:../FreeRTOS/tasks.c **** 				tick time is less than the wake time. */
 816:../FreeRTOS/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 464              		.loc 1 816 0
 465 027e 7B68     		ldr	r3, [r7, #4]
 466 0280 1A68     		ldr	r2, [r3]
 467 0282 FB68     		ldr	r3, [r7, #12]
 468 0284 9A42     		cmp	r2, r3
 469 0286 03D8     		bhi	.L19
 470              		.loc 1 816 0 is_stmt 0 discriminator 1
 471 0288 FA68     		ldr	r2, [r7, #12]
 472 028a 3B69     		ldr	r3, [r7, #16]
 473 028c 9A42     		cmp	r2, r3
 474 028e 01D9     		bls	.L18
 475              	.L19:
 817:../FreeRTOS/tasks.c **** 				{
 818:../FreeRTOS/tasks.c **** 					xShouldDelay = pdTRUE;
 476              		.loc 1 818 0 is_stmt 1
 477 0290 0123     		movs	r3, #1
 478 0292 7B61     		str	r3, [r7, #20]
 479              	.L18:
 819:../FreeRTOS/tasks.c **** 				}
 820:../FreeRTOS/tasks.c **** 				else
 821:../FreeRTOS/tasks.c **** 				{
 822:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
 823:../FreeRTOS/tasks.c **** 				}
 824:../FreeRTOS/tasks.c **** 			}
 825:../FreeRTOS/tasks.c **** 
 826:../FreeRTOS/tasks.c **** 			/* Update the wake time ready for the next call. */
 827:../FreeRTOS/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 480              		.loc 1 827 0
 481 0294 7B68     		ldr	r3, [r7, #4]
 482 0296 FA68     		ldr	r2, [r7, #12]
 483 0298 1A60     		str	r2, [r3]
 828:../FreeRTOS/tasks.c **** 
 829:../FreeRTOS/tasks.c **** 			if( xShouldDelay != pdFALSE )
 484              		.loc 1 829 0
 485 029a 7B69     		ldr	r3, [r7, #20]
 486 029c 002B     		cmp	r3, #0
 487 029e 0BD0     		beq	.L20
 830:../FreeRTOS/tasks.c **** 			{
 831:../FreeRTOS/tasks.c **** 				traceTASK_DELAY_UNTIL();
 832:../FreeRTOS/tasks.c **** 
 833:../FreeRTOS/tasks.c **** 				/* Remove the task from the ready list before adding it to the
 834:../FreeRTOS/tasks.c **** 				blocked list as the same list item is used for both lists. */
 835:../FreeRTOS/tasks.c **** 				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 488              		.loc 1 835 0
 489 02a0 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 490 02a4 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 491 02a8 1B68     		ldr	r3, [r3]
 492 02aa 0433     		adds	r3, r3, #4
 493 02ac 1846     		mov	r0, r3
 494 02ae FFF7FEFF 		bl	uxListRemove
 836:../FreeRTOS/tasks.c **** 				{
 837:../FreeRTOS/tasks.c **** 					/* The current task must be in a ready list, so there is
 838:../FreeRTOS/tasks.c **** 					no need to check, and the port reset macro can be called
 839:../FreeRTOS/tasks.c **** 					directly. */
 840:../FreeRTOS/tasks.c **** 					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 841:../FreeRTOS/tasks.c **** 				}
 842:../FreeRTOS/tasks.c **** 				else
 843:../FreeRTOS/tasks.c **** 				{
 844:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
 845:../FreeRTOS/tasks.c **** 				}
 846:../FreeRTOS/tasks.c **** 
 847:../FreeRTOS/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 495              		.loc 1 847 0
 496 02b2 F868     		ldr	r0, [r7, #12]
 497 02b4 00F04EFF 		bl	prvAddCurrentTaskToDelayedList
 498              	.L20:
 499              	.LBE3:
 848:../FreeRTOS/tasks.c **** 			}
 849:../FreeRTOS/tasks.c **** 			else
 850:../FreeRTOS/tasks.c **** 			{
 851:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
 852:../FreeRTOS/tasks.c **** 			}
 853:../FreeRTOS/tasks.c **** 		}
 854:../FreeRTOS/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 500              		.loc 1 854 0
 501 02b8 FFF7FEFF 		bl	xTaskResumeAll
 502 02bc B860     		str	r0, [r7, #8]
 855:../FreeRTOS/tasks.c **** 
 856:../FreeRTOS/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 857:../FreeRTOS/tasks.c **** 		have put ourselves to sleep. */
 858:../FreeRTOS/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 503              		.loc 1 858 0
 504 02be BB68     		ldr	r3, [r7, #8]
 505 02c0 002B     		cmp	r3, #0
 506 02c2 01D1     		bne	.L16
 859:../FreeRTOS/tasks.c **** 		{
 860:../FreeRTOS/tasks.c **** 			portYIELD_WITHIN_API();
 507              		.loc 1 860 0
 508 02c4 FFF7FEFF 		bl	vPortYield
 509              	.L16:
 861:../FreeRTOS/tasks.c **** 		}
 862:../FreeRTOS/tasks.c **** 		else
 863:../FreeRTOS/tasks.c **** 		{
 864:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 865:../FreeRTOS/tasks.c **** 		}
 866:../FreeRTOS/tasks.c **** 	}
 510              		.loc 1 866 0
 511 02c8 1837     		adds	r7, r7, #24
 512 02ca BD46     		mov	sp, r7
 513              		@ sp needed
 514 02cc 80BD     		pop	{r7, pc}
 515              		.cfi_endproc
 516              	.LFE2:
 518 02ce 00BF     		.align	2
 519              		.global	vTaskDelay
 520              		.thumb
 521              		.thumb_func
 523              	vTaskDelay:
 524              	.LFB3:
 867:../FreeRTOS/tasks.c **** 
 868:../FreeRTOS/tasks.c **** #endif /* INCLUDE_vTaskDelayUntil */
 869:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 870:../FreeRTOS/tasks.c **** 
 871:../FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
 872:../FreeRTOS/tasks.c **** 
 873:../FreeRTOS/tasks.c **** 	void vTaskDelay( const TickType_t xTicksToDelay )
 874:../FreeRTOS/tasks.c **** 	{
 525              		.loc 1 874 0
 526              		.cfi_startproc
 527              		@ args = 0, pretend = 0, frame = 16
 528              		@ frame_needed = 1, uses_anonymous_args = 0
 529 02d0 80B5     		push	{r7, lr}
 530              		.cfi_def_cfa_offset 8
 531              		.cfi_offset 7, -8
 532              		.cfi_offset 14, -4
 533 02d2 84B0     		sub	sp, sp, #16
 534              		.cfi_def_cfa_offset 24
 535 02d4 00AF     		add	r7, sp, #0
 536              		.cfi_def_cfa_register 7
 537 02d6 7860     		str	r0, [r7, #4]
 875:../FreeRTOS/tasks.c **** 	TickType_t xTimeToWake;
 876:../FreeRTOS/tasks.c **** 	BaseType_t xAlreadyYielded = pdFALSE;
 538              		.loc 1 876 0
 539 02d8 0023     		movs	r3, #0
 540 02da FB60     		str	r3, [r7, #12]
 877:../FreeRTOS/tasks.c **** 
 878:../FreeRTOS/tasks.c **** 
 879:../FreeRTOS/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
 880:../FreeRTOS/tasks.c **** 		if( xTicksToDelay > ( TickType_t ) 0U )
 541              		.loc 1 880 0
 542 02dc 7B68     		ldr	r3, [r7, #4]
 543 02de 002B     		cmp	r3, #0
 544 02e0 18D0     		beq	.L23
 881:../FreeRTOS/tasks.c **** 		{
 882:../FreeRTOS/tasks.c **** 			configASSERT( uxSchedulerSuspended == 0 );
 883:../FreeRTOS/tasks.c **** 			vTaskSuspendAll();
 545              		.loc 1 883 0
 546 02e2 FFF7FEFF 		bl	vTaskSuspendAll
 884:../FreeRTOS/tasks.c **** 			{
 885:../FreeRTOS/tasks.c **** 				traceTASK_DELAY();
 886:../FreeRTOS/tasks.c **** 
 887:../FreeRTOS/tasks.c **** 				/* A task that is removed from the event list while the
 888:../FreeRTOS/tasks.c **** 				scheduler is suspended will not get placed in the ready
 889:../FreeRTOS/tasks.c **** 				list or removed from the blocked list until the scheduler
 890:../FreeRTOS/tasks.c **** 				is resumed.
 891:../FreeRTOS/tasks.c **** 
 892:../FreeRTOS/tasks.c **** 				This task cannot be in an event list as it is the currently
 893:../FreeRTOS/tasks.c **** 				executing task. */
 894:../FreeRTOS/tasks.c **** 
 895:../FreeRTOS/tasks.c **** 				/* Calculate the time to wake - this may overflow but this is
 896:../FreeRTOS/tasks.c **** 				not a problem. */
 897:../FreeRTOS/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 547              		.loc 1 897 0
 548 02e6 40F20003 		movw	r3, #:lower16:xTickCount
 549 02ea C0F20003 		movt	r3, #:upper16:xTickCount
 550 02ee 1A68     		ldr	r2, [r3]
 551 02f0 7B68     		ldr	r3, [r7, #4]
 552 02f2 1344     		add	r3, r3, r2
 553 02f4 BB60     		str	r3, [r7, #8]
 898:../FreeRTOS/tasks.c **** 
 899:../FreeRTOS/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 900:../FreeRTOS/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 901:../FreeRTOS/tasks.c **** 				both lists. */
 902:../FreeRTOS/tasks.c **** 				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 554              		.loc 1 902 0
 555 02f6 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 556 02fa C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 557 02fe 1B68     		ldr	r3, [r3]
 558 0300 0433     		adds	r3, r3, #4
 559 0302 1846     		mov	r0, r3
 560 0304 FFF7FEFF 		bl	uxListRemove
 903:../FreeRTOS/tasks.c **** 				{
 904:../FreeRTOS/tasks.c **** 					/* The current task must be in a ready list, so there is
 905:../FreeRTOS/tasks.c **** 					no need to check, and the port reset macro can be called
 906:../FreeRTOS/tasks.c **** 					directly. */
 907:../FreeRTOS/tasks.c **** 					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 908:../FreeRTOS/tasks.c **** 				}
 909:../FreeRTOS/tasks.c **** 				else
 910:../FreeRTOS/tasks.c **** 				{
 911:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
 912:../FreeRTOS/tasks.c **** 				}
 913:../FreeRTOS/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 561              		.loc 1 913 0
 562 0308 B868     		ldr	r0, [r7, #8]
 563 030a 00F023FF 		bl	prvAddCurrentTaskToDelayedList
 914:../FreeRTOS/tasks.c **** 			}
 915:../FreeRTOS/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 564              		.loc 1 915 0
 565 030e FFF7FEFF 		bl	xTaskResumeAll
 566 0312 F860     		str	r0, [r7, #12]
 567              	.L23:
 916:../FreeRTOS/tasks.c **** 		}
 917:../FreeRTOS/tasks.c **** 		else
 918:../FreeRTOS/tasks.c **** 		{
 919:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 920:../FreeRTOS/tasks.c **** 		}
 921:../FreeRTOS/tasks.c **** 
 922:../FreeRTOS/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 923:../FreeRTOS/tasks.c **** 		have put ourselves to sleep. */
 924:../FreeRTOS/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 568              		.loc 1 924 0
 569 0314 FB68     		ldr	r3, [r7, #12]
 570 0316 002B     		cmp	r3, #0
 571 0318 01D1     		bne	.L22
 925:../FreeRTOS/tasks.c **** 		{
 926:../FreeRTOS/tasks.c **** 			portYIELD_WITHIN_API();
 572              		.loc 1 926 0
 573 031a FFF7FEFF 		bl	vPortYield
 574              	.L22:
 927:../FreeRTOS/tasks.c **** 		}
 928:../FreeRTOS/tasks.c **** 		else
 929:../FreeRTOS/tasks.c **** 		{
 930:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 931:../FreeRTOS/tasks.c **** 		}
 932:../FreeRTOS/tasks.c **** 	}
 575              		.loc 1 932 0
 576 031e 1037     		adds	r7, r7, #16
 577 0320 BD46     		mov	sp, r7
 578              		@ sp needed
 579 0322 80BD     		pop	{r7, pc}
 580              		.cfi_endproc
 581              	.LFE3:
 583              		.align	2
 584              		.global	uxTaskPriorityGet
 585              		.thumb
 586              		.thumb_func
 588              	uxTaskPriorityGet:
 589              	.LFB4:
 933:../FreeRTOS/tasks.c **** 
 934:../FreeRTOS/tasks.c **** #endif /* INCLUDE_vTaskDelay */
 935:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 936:../FreeRTOS/tasks.c **** 
 937:../FreeRTOS/tasks.c **** #if ( INCLUDE_eTaskGetState == 1 )
 938:../FreeRTOS/tasks.c **** 
 939:../FreeRTOS/tasks.c **** 	eTaskState eTaskGetState( TaskHandle_t xTask )
 940:../FreeRTOS/tasks.c **** 	{
 941:../FreeRTOS/tasks.c **** 	eTaskState eReturn;
 942:../FreeRTOS/tasks.c **** 	List_t *pxStateList;
 943:../FreeRTOS/tasks.c **** 	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
 944:../FreeRTOS/tasks.c **** 
 945:../FreeRTOS/tasks.c **** 		configASSERT( pxTCB );
 946:../FreeRTOS/tasks.c **** 
 947:../FreeRTOS/tasks.c **** 		if( pxTCB == pxCurrentTCB )
 948:../FreeRTOS/tasks.c **** 		{
 949:../FreeRTOS/tasks.c **** 			/* The task calling this function is querying its own state. */
 950:../FreeRTOS/tasks.c **** 			eReturn = eRunning;
 951:../FreeRTOS/tasks.c **** 		}
 952:../FreeRTOS/tasks.c **** 		else
 953:../FreeRTOS/tasks.c **** 		{
 954:../FreeRTOS/tasks.c **** 			taskENTER_CRITICAL();
 955:../FreeRTOS/tasks.c **** 			{
 956:../FreeRTOS/tasks.c **** 				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xGenericListItem ) );
 957:../FreeRTOS/tasks.c **** 			}
 958:../FreeRTOS/tasks.c **** 			taskEXIT_CRITICAL();
 959:../FreeRTOS/tasks.c **** 
 960:../FreeRTOS/tasks.c **** 			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
 961:../FreeRTOS/tasks.c **** 			{
 962:../FreeRTOS/tasks.c **** 				/* The task being queried is referenced from one of the Blocked
 963:../FreeRTOS/tasks.c **** 				lists. */
 964:../FreeRTOS/tasks.c **** 				eReturn = eBlocked;
 965:../FreeRTOS/tasks.c **** 			}
 966:../FreeRTOS/tasks.c **** 
 967:../FreeRTOS/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
 968:../FreeRTOS/tasks.c **** 				else if( pxStateList == &xSuspendedTaskList )
 969:../FreeRTOS/tasks.c **** 				{
 970:../FreeRTOS/tasks.c **** 					/* The task being queried is referenced from the suspended
 971:../FreeRTOS/tasks.c **** 					list.  Is it genuinely suspended or is it block
 972:../FreeRTOS/tasks.c **** 					indefinitely? */
 973:../FreeRTOS/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
 974:../FreeRTOS/tasks.c **** 					{
 975:../FreeRTOS/tasks.c **** 						eReturn = eSuspended;
 976:../FreeRTOS/tasks.c **** 					}
 977:../FreeRTOS/tasks.c **** 					else
 978:../FreeRTOS/tasks.c **** 					{
 979:../FreeRTOS/tasks.c **** 						eReturn = eBlocked;
 980:../FreeRTOS/tasks.c **** 					}
 981:../FreeRTOS/tasks.c **** 				}
 982:../FreeRTOS/tasks.c **** 			#endif
 983:../FreeRTOS/tasks.c **** 
 984:../FreeRTOS/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
 985:../FreeRTOS/tasks.c **** 				else if( pxStateList == &xTasksWaitingTermination )
 986:../FreeRTOS/tasks.c **** 				{
 987:../FreeRTOS/tasks.c **** 					/* The task being queried is referenced from the deleted
 988:../FreeRTOS/tasks.c **** 					tasks list. */
 989:../FreeRTOS/tasks.c **** 					eReturn = eDeleted;
 990:../FreeRTOS/tasks.c **** 				}
 991:../FreeRTOS/tasks.c **** 			#endif
 992:../FreeRTOS/tasks.c **** 
 993:../FreeRTOS/tasks.c **** 			else
 994:../FreeRTOS/tasks.c **** 			{
 995:../FreeRTOS/tasks.c **** 				/* If the task is not in any other state, it must be in the
 996:../FreeRTOS/tasks.c **** 				Ready (including pending ready) state. */
 997:../FreeRTOS/tasks.c **** 				eReturn = eReady;
 998:../FreeRTOS/tasks.c **** 			}
 999:../FreeRTOS/tasks.c **** 		}
1000:../FreeRTOS/tasks.c **** 
1001:../FreeRTOS/tasks.c **** 		return eReturn;
1002:../FreeRTOS/tasks.c **** 	}
1003:../FreeRTOS/tasks.c **** 
1004:../FreeRTOS/tasks.c **** #endif /* INCLUDE_eTaskGetState */
1005:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1006:../FreeRTOS/tasks.c **** 
1007:../FreeRTOS/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1008:../FreeRTOS/tasks.c **** 
1009:../FreeRTOS/tasks.c **** 	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
1010:../FreeRTOS/tasks.c **** 	{
 590              		.loc 1 1010 0
 591              		.cfi_startproc
 592              		@ args = 0, pretend = 0, frame = 16
 593              		@ frame_needed = 1, uses_anonymous_args = 0
 594 0324 80B5     		push	{r7, lr}
 595              		.cfi_def_cfa_offset 8
 596              		.cfi_offset 7, -8
 597              		.cfi_offset 14, -4
 598 0326 84B0     		sub	sp, sp, #16
 599              		.cfi_def_cfa_offset 24
 600 0328 00AF     		add	r7, sp, #0
 601              		.cfi_def_cfa_register 7
 602 032a 7860     		str	r0, [r7, #4]
1011:../FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
1012:../FreeRTOS/tasks.c **** 	UBaseType_t uxReturn;
1013:../FreeRTOS/tasks.c **** 
1014:../FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
 603              		.loc 1 1014 0
 604 032c FFF7FEFF 		bl	vPortEnterCritical
1015:../FreeRTOS/tasks.c **** 		{
1016:../FreeRTOS/tasks.c **** 			/* If null is passed in here then we are changing the
1017:../FreeRTOS/tasks.c **** 			priority of the calling function. */
1018:../FreeRTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
 605              		.loc 1 1018 0
 606 0330 7B68     		ldr	r3, [r7, #4]
 607 0332 002B     		cmp	r3, #0
 608 0334 05D1     		bne	.L26
 609              		.loc 1 1018 0 is_stmt 0 discriminator 1
 610 0336 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 611 033a C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 612 033e 1B68     		ldr	r3, [r3]
 613 0340 00E0     		b	.L27
 614              	.L26:
 615              		.loc 1 1018 0 discriminator 2
 616 0342 7B68     		ldr	r3, [r7, #4]
 617              	.L27:
 618              		.loc 1 1018 0 discriminator 3
 619 0344 FB60     		str	r3, [r7, #12]
1019:../FreeRTOS/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 620              		.loc 1 1019 0 is_stmt 1 discriminator 3
 621 0346 FB68     		ldr	r3, [r7, #12]
 622 0348 DB6A     		ldr	r3, [r3, #44]
 623 034a BB60     		str	r3, [r7, #8]
1020:../FreeRTOS/tasks.c **** 		}
1021:../FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
 624              		.loc 1 1021 0 discriminator 3
 625 034c FFF7FEFF 		bl	vPortExitCritical
1022:../FreeRTOS/tasks.c **** 
1023:../FreeRTOS/tasks.c **** 		return uxReturn;
 626              		.loc 1 1023 0 discriminator 3
 627 0350 BB68     		ldr	r3, [r7, #8]
1024:../FreeRTOS/tasks.c **** 	}
 628              		.loc 1 1024 0 discriminator 3
 629 0352 1846     		mov	r0, r3
 630 0354 1037     		adds	r7, r7, #16
 631 0356 BD46     		mov	sp, r7
 632              		@ sp needed
 633 0358 80BD     		pop	{r7, pc}
 634              		.cfi_endproc
 635              	.LFE4:
 637 035a 00BF     		.align	2
 638              		.global	vTaskPrioritySet
 639              		.thumb
 640              		.thumb_func
 642              	vTaskPrioritySet:
 643              	.LFB5:
1025:../FreeRTOS/tasks.c **** 
1026:../FreeRTOS/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1027:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1028:../FreeRTOS/tasks.c **** 
1029:../FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
1030:../FreeRTOS/tasks.c **** 
1031:../FreeRTOS/tasks.c **** 	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
1032:../FreeRTOS/tasks.c **** 	{
 644              		.loc 1 1032 0
 645              		.cfi_startproc
 646              		@ args = 0, pretend = 0, frame = 24
 647              		@ frame_needed = 1, uses_anonymous_args = 0
 648 035c 80B5     		push	{r7, lr}
 649              		.cfi_def_cfa_offset 8
 650              		.cfi_offset 7, -8
 651              		.cfi_offset 14, -4
 652 035e 86B0     		sub	sp, sp, #24
 653              		.cfi_def_cfa_offset 32
 654 0360 00AF     		add	r7, sp, #0
 655              		.cfi_def_cfa_register 7
 656 0362 7860     		str	r0, [r7, #4]
 657 0364 3960     		str	r1, [r7]
1033:../FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
1034:../FreeRTOS/tasks.c **** 	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
1035:../FreeRTOS/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
 658              		.loc 1 1035 0
 659 0366 0023     		movs	r3, #0
 660 0368 7B61     		str	r3, [r7, #20]
1036:../FreeRTOS/tasks.c **** 
1037:../FreeRTOS/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
1038:../FreeRTOS/tasks.c **** 
1039:../FreeRTOS/tasks.c **** 		/* Ensure the new priority is valid. */
1040:../FreeRTOS/tasks.c **** 		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 661              		.loc 1 1040 0
 662 036a 3B68     		ldr	r3, [r7]
 663 036c 042B     		cmp	r3, #4
 664 036e 01D9     		bls	.L30
1041:../FreeRTOS/tasks.c **** 		{
1042:../FreeRTOS/tasks.c **** 			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 665              		.loc 1 1042 0
 666 0370 0423     		movs	r3, #4
 667 0372 3B60     		str	r3, [r7]
 668              	.L30:
1043:../FreeRTOS/tasks.c **** 		}
1044:../FreeRTOS/tasks.c **** 		else
1045:../FreeRTOS/tasks.c **** 		{
1046:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1047:../FreeRTOS/tasks.c **** 		}
1048:../FreeRTOS/tasks.c **** 
1049:../FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
 669              		.loc 1 1049 0
 670 0374 FFF7FEFF 		bl	vPortEnterCritical
1050:../FreeRTOS/tasks.c **** 		{
1051:../FreeRTOS/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
1052:../FreeRTOS/tasks.c **** 			task that is being changed. */
1053:../FreeRTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
 671              		.loc 1 1053 0
 672 0378 7B68     		ldr	r3, [r7, #4]
 673 037a 002B     		cmp	r3, #0
 674 037c 05D1     		bne	.L31
 675              		.loc 1 1053 0 is_stmt 0 discriminator 1
 676 037e 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 677 0382 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 678 0386 1B68     		ldr	r3, [r3]
 679 0388 00E0     		b	.L32
 680              	.L31:
 681              		.loc 1 1053 0 discriminator 2
 682 038a 7B68     		ldr	r3, [r7, #4]
 683              	.L32:
 684              		.loc 1 1053 0 discriminator 3
 685 038c 3B61     		str	r3, [r7, #16]
1054:../FreeRTOS/tasks.c **** 
1055:../FreeRTOS/tasks.c **** 			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
1056:../FreeRTOS/tasks.c **** 
1057:../FreeRTOS/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
1058:../FreeRTOS/tasks.c **** 			{
1059:../FreeRTOS/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxBasePriority;
 686              		.loc 1 1059 0 is_stmt 1 discriminator 3
 687 038e 3B69     		ldr	r3, [r7, #16]
 688 0390 5B6C     		ldr	r3, [r3, #68]
 689 0392 FB60     		str	r3, [r7, #12]
1060:../FreeRTOS/tasks.c **** 			}
1061:../FreeRTOS/tasks.c **** 			#else
1062:../FreeRTOS/tasks.c **** 			{
1063:../FreeRTOS/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxPriority;
1064:../FreeRTOS/tasks.c **** 			}
1065:../FreeRTOS/tasks.c **** 			#endif
1066:../FreeRTOS/tasks.c **** 
1067:../FreeRTOS/tasks.c **** 			if( uxCurrentBasePriority != uxNewPriority )
 690              		.loc 1 1067 0 discriminator 3
 691 0394 FA68     		ldr	r2, [r7, #12]
 692 0396 3B68     		ldr	r3, [r7]
 693 0398 9A42     		cmp	r2, r3
 694 039a 77D0     		beq	.L33
1068:../FreeRTOS/tasks.c **** 			{
1069:../FreeRTOS/tasks.c **** 				/* The priority change may have readied a task of higher
1070:../FreeRTOS/tasks.c **** 				priority than the calling task. */
1071:../FreeRTOS/tasks.c **** 				if( uxNewPriority > uxCurrentBasePriority )
 695              		.loc 1 1071 0
 696 039c 3A68     		ldr	r2, [r7]
 697 039e FB68     		ldr	r3, [r7, #12]
 698 03a0 9A42     		cmp	r2, r3
 699 03a2 13D9     		bls	.L34
1072:../FreeRTOS/tasks.c **** 				{
1073:../FreeRTOS/tasks.c **** 					if( pxTCB != pxCurrentTCB )
 700              		.loc 1 1073 0
 701 03a4 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 702 03a8 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 703 03ac 1B68     		ldr	r3, [r3]
 704 03ae 3A69     		ldr	r2, [r7, #16]
 705 03b0 9A42     		cmp	r2, r3
 706 03b2 15D0     		beq	.L35
1074:../FreeRTOS/tasks.c **** 					{
1075:../FreeRTOS/tasks.c **** 						/* The priority of a task other than the currently
1076:../FreeRTOS/tasks.c **** 						running task is being raised.  Is the priority being
1077:../FreeRTOS/tasks.c **** 						raised above that of the running task? */
1078:../FreeRTOS/tasks.c **** 						if( uxNewPriority >= pxCurrentTCB->uxPriority )
 707              		.loc 1 1078 0
 708 03b4 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 709 03b8 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 710 03bc 1B68     		ldr	r3, [r3]
 711 03be DA6A     		ldr	r2, [r3, #44]
 712 03c0 3B68     		ldr	r3, [r7]
 713 03c2 9A42     		cmp	r2, r3
 714 03c4 0CD8     		bhi	.L35
1079:../FreeRTOS/tasks.c **** 						{
1080:../FreeRTOS/tasks.c **** 							xYieldRequired = pdTRUE;
 715              		.loc 1 1080 0
 716 03c6 0123     		movs	r3, #1
 717 03c8 7B61     		str	r3, [r7, #20]
 718 03ca 09E0     		b	.L35
 719              	.L34:
1081:../FreeRTOS/tasks.c **** 						}
1082:../FreeRTOS/tasks.c **** 						else
1083:../FreeRTOS/tasks.c **** 						{
1084:../FreeRTOS/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
1085:../FreeRTOS/tasks.c **** 						}
1086:../FreeRTOS/tasks.c **** 					}
1087:../FreeRTOS/tasks.c **** 					else
1088:../FreeRTOS/tasks.c **** 					{
1089:../FreeRTOS/tasks.c **** 						/* The priority of the running task is being raised,
1090:../FreeRTOS/tasks.c **** 						but the running task must already be the highest
1091:../FreeRTOS/tasks.c **** 						priority task able to run so no yield is required. */
1092:../FreeRTOS/tasks.c **** 					}
1093:../FreeRTOS/tasks.c **** 				}
1094:../FreeRTOS/tasks.c **** 				else if( pxTCB == pxCurrentTCB )
 720              		.loc 1 1094 0
 721 03cc 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 722 03d0 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 723 03d4 1B68     		ldr	r3, [r3]
 724 03d6 3A69     		ldr	r2, [r7, #16]
 725 03d8 9A42     		cmp	r2, r3
 726 03da 01D1     		bne	.L35
1095:../FreeRTOS/tasks.c **** 				{
1096:../FreeRTOS/tasks.c **** 					/* Setting the priority of the running task down means
1097:../FreeRTOS/tasks.c **** 					there may now be another task of higher priority that
1098:../FreeRTOS/tasks.c **** 					is ready to execute. */
1099:../FreeRTOS/tasks.c **** 					xYieldRequired = pdTRUE;
 727              		.loc 1 1099 0
 728 03dc 0123     		movs	r3, #1
 729 03de 7B61     		str	r3, [r7, #20]
 730              	.L35:
1100:../FreeRTOS/tasks.c **** 				}
1101:../FreeRTOS/tasks.c **** 				else
1102:../FreeRTOS/tasks.c **** 				{
1103:../FreeRTOS/tasks.c **** 					/* Setting the priority of any other task down does not
1104:../FreeRTOS/tasks.c **** 					require a yield as the running task must be above the
1105:../FreeRTOS/tasks.c **** 					new priority of the task being modified. */
1106:../FreeRTOS/tasks.c **** 				}
1107:../FreeRTOS/tasks.c **** 
1108:../FreeRTOS/tasks.c **** 				/* Remember the ready list the task might be referenced from
1109:../FreeRTOS/tasks.c **** 				before its uxPriority member is changed so the
1110:../FreeRTOS/tasks.c **** 				taskRESET_READY_PRIORITY() macro can function correctly. */
1111:../FreeRTOS/tasks.c **** 				uxPriorityUsedOnEntry = pxTCB->uxPriority;
 731              		.loc 1 1111 0
 732 03e0 3B69     		ldr	r3, [r7, #16]
 733 03e2 DB6A     		ldr	r3, [r3, #44]
 734 03e4 BB60     		str	r3, [r7, #8]
1112:../FreeRTOS/tasks.c **** 
1113:../FreeRTOS/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
1114:../FreeRTOS/tasks.c **** 				{
1115:../FreeRTOS/tasks.c **** 					/* Only change the priority being used if the task is not
1116:../FreeRTOS/tasks.c **** 					currently using an inherited priority. */
1117:../FreeRTOS/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 735              		.loc 1 1117 0
 736 03e6 3B69     		ldr	r3, [r7, #16]
 737 03e8 5A6C     		ldr	r2, [r3, #68]
 738 03ea 3B69     		ldr	r3, [r7, #16]
 739 03ec DB6A     		ldr	r3, [r3, #44]
 740 03ee 9A42     		cmp	r2, r3
 741 03f0 02D1     		bne	.L36
1118:../FreeRTOS/tasks.c **** 					{
1119:../FreeRTOS/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
 742              		.loc 1 1119 0
 743 03f2 3B69     		ldr	r3, [r7, #16]
 744 03f4 3A68     		ldr	r2, [r7]
 745 03f6 DA62     		str	r2, [r3, #44]
 746              	.L36:
1120:../FreeRTOS/tasks.c **** 					}
1121:../FreeRTOS/tasks.c **** 					else
1122:../FreeRTOS/tasks.c **** 					{
1123:../FreeRTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1124:../FreeRTOS/tasks.c **** 					}
1125:../FreeRTOS/tasks.c **** 
1126:../FreeRTOS/tasks.c **** 					/* The base priority gets set whatever. */
1127:../FreeRTOS/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
 747              		.loc 1 1127 0
 748 03f8 3B69     		ldr	r3, [r7, #16]
 749 03fa 3A68     		ldr	r2, [r7]
 750 03fc 5A64     		str	r2, [r3, #68]
1128:../FreeRTOS/tasks.c **** 				}
1129:../FreeRTOS/tasks.c **** 				#else
1130:../FreeRTOS/tasks.c **** 				{
1131:../FreeRTOS/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
1132:../FreeRTOS/tasks.c **** 				}
1133:../FreeRTOS/tasks.c **** 				#endif
1134:../FreeRTOS/tasks.c **** 
1135:../FreeRTOS/tasks.c **** 				/* Only reset the event list item value if the value is not
1136:../FreeRTOS/tasks.c **** 				being used for anything else. */
1137:../FreeRTOS/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE 
 751              		.loc 1 1137 0
 752 03fe 3B69     		ldr	r3, [r7, #16]
 753 0400 9B69     		ldr	r3, [r3, #24]
 754 0402 002B     		cmp	r3, #0
 755 0404 04DB     		blt	.L37
1138:../FreeRTOS/tasks.c **** 				{
1139:../FreeRTOS/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - (
 756              		.loc 1 1139 0
 757 0406 3B68     		ldr	r3, [r7]
 758 0408 C3F10502 		rsb	r2, r3, #5
 759 040c 3B69     		ldr	r3, [r7, #16]
 760 040e 9A61     		str	r2, [r3, #24]
 761              	.L37:
1140:../FreeRTOS/tasks.c **** 				}
1141:../FreeRTOS/tasks.c **** 				else
1142:../FreeRTOS/tasks.c **** 				{
1143:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1144:../FreeRTOS/tasks.c **** 				}
1145:../FreeRTOS/tasks.c **** 
1146:../FreeRTOS/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
1147:../FreeRTOS/tasks.c **** 				nothing more than change it's priority variable. However, if
1148:../FreeRTOS/tasks.c **** 				the task is in a ready list it needs to be removed and placed
1149:../FreeRTOS/tasks.c **** 				in the list appropriate to its new priority. */
1150:../FreeRTOS/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGeneri
 762              		.loc 1 1150 0
 763 0410 3B69     		ldr	r3, [r7, #16]
 764 0412 5969     		ldr	r1, [r3, #20]
 765 0414 BA68     		ldr	r2, [r7, #8]
 766 0416 1346     		mov	r3, r2
 767 0418 9B00     		lsls	r3, r3, #2
 768 041a 1344     		add	r3, r3, r2
 769 041c 9B00     		lsls	r3, r3, #2
 770 041e 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 771 0422 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 772 0426 1344     		add	r3, r3, r2
 773 0428 9942     		cmp	r1, r3
 774 042a 01D1     		bne	.L38
 775              		.loc 1 1150 0 is_stmt 0 discriminator 1
 776 042c 0123     		movs	r3, #1
 777 042e 00E0     		b	.L39
 778              	.L38:
 779              		.loc 1 1150 0 discriminator 2
 780 0430 0023     		movs	r3, #0
 781              	.L39:
 782              		.loc 1 1150 0 discriminator 3
 783 0432 002B     		cmp	r3, #0
 784 0434 25D0     		beq	.L40
1151:../FreeRTOS/tasks.c **** 				{
1152:../FreeRTOS/tasks.c **** 					/* The task is currently in its ready list - remove before adding
1153:../FreeRTOS/tasks.c **** 					it to it's new ready list.  As we are in a critical section we
1154:../FreeRTOS/tasks.c **** 					can do this even if the scheduler is suspended. */
1155:../FreeRTOS/tasks.c **** 					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 785              		.loc 1 1155 0 is_stmt 1
 786 0436 3B69     		ldr	r3, [r7, #16]
 787 0438 0433     		adds	r3, r3, #4
 788 043a 1846     		mov	r0, r3
 789 043c FFF7FEFF 		bl	uxListRemove
1156:../FreeRTOS/tasks.c **** 					{
1157:../FreeRTOS/tasks.c **** 						/* It is known that the task is in its ready list so
1158:../FreeRTOS/tasks.c **** 						there is no need to check again and the port level
1159:../FreeRTOS/tasks.c **** 						reset macro can be called directly. */
1160:../FreeRTOS/tasks.c **** 						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
1161:../FreeRTOS/tasks.c **** 					}
1162:../FreeRTOS/tasks.c **** 					else
1163:../FreeRTOS/tasks.c **** 					{
1164:../FreeRTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1165:../FreeRTOS/tasks.c **** 					}
1166:../FreeRTOS/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 790              		.loc 1 1166 0
 791 0440 3B69     		ldr	r3, [r7, #16]
 792 0442 DA6A     		ldr	r2, [r3, #44]
 793 0444 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 794 0448 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 795 044c 1B68     		ldr	r3, [r3]
 796 044e 9A42     		cmp	r2, r3
 797 0450 06D9     		bls	.L41
 798              		.loc 1 1166 0 is_stmt 0 discriminator 1
 799 0452 3B69     		ldr	r3, [r7, #16]
 800 0454 DA6A     		ldr	r2, [r3, #44]
 801 0456 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 802 045a C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 803 045e 1A60     		str	r2, [r3]
 804              	.L41:
 805              		.loc 1 1166 0 discriminator 2
 806 0460 3B69     		ldr	r3, [r7, #16]
 807 0462 DA6A     		ldr	r2, [r3, #44]
 808 0464 1346     		mov	r3, r2
 809 0466 9B00     		lsls	r3, r3, #2
 810 0468 1344     		add	r3, r3, r2
 811 046a 9B00     		lsls	r3, r3, #2
 812 046c 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 813 0470 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 814 0474 1A44     		add	r2, r2, r3
 815 0476 3B69     		ldr	r3, [r7, #16]
 816 0478 0433     		adds	r3, r3, #4
 817 047a 1046     		mov	r0, r2
 818 047c 1946     		mov	r1, r3
 819 047e FFF7FEFF 		bl	vListInsertEnd
 820              	.L40:
1167:../FreeRTOS/tasks.c **** 				}
1168:../FreeRTOS/tasks.c **** 				else
1169:../FreeRTOS/tasks.c **** 				{
1170:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1171:../FreeRTOS/tasks.c **** 				}
1172:../FreeRTOS/tasks.c **** 
1173:../FreeRTOS/tasks.c **** 				if( xYieldRequired == pdTRUE )
 821              		.loc 1 1173 0 is_stmt 1
 822 0482 7B69     		ldr	r3, [r7, #20]
 823 0484 012B     		cmp	r3, #1
 824 0486 01D1     		bne	.L33
1174:../FreeRTOS/tasks.c **** 				{
1175:../FreeRTOS/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
 825              		.loc 1 1175 0
 826 0488 FFF7FEFF 		bl	vPortYield
 827              	.L33:
1176:../FreeRTOS/tasks.c **** 				}
1177:../FreeRTOS/tasks.c **** 				else
1178:../FreeRTOS/tasks.c **** 				{
1179:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1180:../FreeRTOS/tasks.c **** 				}
1181:../FreeRTOS/tasks.c **** 
1182:../FreeRTOS/tasks.c **** 				/* Remove compiler warning about unused variables when the port
1183:../FreeRTOS/tasks.c **** 				optimised task selection is not being used. */
1184:../FreeRTOS/tasks.c **** 				( void ) uxPriorityUsedOnEntry;
1185:../FreeRTOS/tasks.c **** 			}
1186:../FreeRTOS/tasks.c **** 		}
1187:../FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
 828              		.loc 1 1187 0
 829 048c FFF7FEFF 		bl	vPortExitCritical
1188:../FreeRTOS/tasks.c **** 	}
 830              		.loc 1 1188 0
 831 0490 1837     		adds	r7, r7, #24
 832 0492 BD46     		mov	sp, r7
 833              		@ sp needed
 834 0494 80BD     		pop	{r7, pc}
 835              		.cfi_endproc
 836              	.LFE5:
 838 0496 00BF     		.align	2
 839              		.global	vTaskSuspend
 840              		.thumb
 841              		.thumb_func
 843              	vTaskSuspend:
 844              	.LFB6:
1189:../FreeRTOS/tasks.c **** 
1190:../FreeRTOS/tasks.c **** #endif /* INCLUDE_vTaskPrioritySet */
1191:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1192:../FreeRTOS/tasks.c **** 
1193:../FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1194:../FreeRTOS/tasks.c **** 
1195:../FreeRTOS/tasks.c **** 	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
1196:../FreeRTOS/tasks.c **** 	{
 845              		.loc 1 1196 0
 846              		.cfi_startproc
 847              		@ args = 0, pretend = 0, frame = 16
 848              		@ frame_needed = 1, uses_anonymous_args = 0
 849 0498 80B5     		push	{r7, lr}
 850              		.cfi_def_cfa_offset 8
 851              		.cfi_offset 7, -8
 852              		.cfi_offset 14, -4
 853 049a 84B0     		sub	sp, sp, #16
 854              		.cfi_def_cfa_offset 24
 855 049c 00AF     		add	r7, sp, #0
 856              		.cfi_def_cfa_register 7
 857 049e 7860     		str	r0, [r7, #4]
1197:../FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
1198:../FreeRTOS/tasks.c **** 
1199:../FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
 858              		.loc 1 1199 0
 859 04a0 FFF7FEFF 		bl	vPortEnterCritical
1200:../FreeRTOS/tasks.c **** 		{
1201:../FreeRTOS/tasks.c **** 			/* If null is passed in here then it is the running task that is
1202:../FreeRTOS/tasks.c **** 			being suspended. */
1203:../FreeRTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 860              		.loc 1 1203 0
 861 04a4 7B68     		ldr	r3, [r7, #4]
 862 04a6 002B     		cmp	r3, #0
 863 04a8 05D1     		bne	.L43
 864              		.loc 1 1203 0 is_stmt 0 discriminator 1
 865 04aa 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 866 04ae C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 867 04b2 1B68     		ldr	r3, [r3]
 868 04b4 00E0     		b	.L44
 869              	.L43:
 870              		.loc 1 1203 0 discriminator 2
 871 04b6 7B68     		ldr	r3, [r7, #4]
 872              	.L44:
 873              		.loc 1 1203 0 discriminator 3
 874 04b8 FB60     		str	r3, [r7, #12]
1204:../FreeRTOS/tasks.c **** 
1205:../FreeRTOS/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
1206:../FreeRTOS/tasks.c **** 
1207:../FreeRTOS/tasks.c **** 			/* Remove task from the ready/delayed list and place in the
1208:../FreeRTOS/tasks.c **** 			suspended list. */
1209:../FreeRTOS/tasks.c **** 			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 875              		.loc 1 1209 0 is_stmt 1 discriminator 3
 876 04ba FB68     		ldr	r3, [r7, #12]
 877 04bc 0433     		adds	r3, r3, #4
 878 04be 1846     		mov	r0, r3
 879 04c0 FFF7FEFF 		bl	uxListRemove
1210:../FreeRTOS/tasks.c **** 			{
1211:../FreeRTOS/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1212:../FreeRTOS/tasks.c **** 			}
1213:../FreeRTOS/tasks.c **** 			else
1214:../FreeRTOS/tasks.c **** 			{
1215:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1216:../FreeRTOS/tasks.c **** 			}
1217:../FreeRTOS/tasks.c **** 
1218:../FreeRTOS/tasks.c **** 			/* Is the task waiting on an event also? */
1219:../FreeRTOS/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 880              		.loc 1 1219 0 discriminator 3
 881 04c4 FB68     		ldr	r3, [r7, #12]
 882 04c6 9B6A     		ldr	r3, [r3, #40]
 883 04c8 002B     		cmp	r3, #0
 884 04ca 04D0     		beq	.L45
1220:../FreeRTOS/tasks.c **** 			{
1221:../FreeRTOS/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 885              		.loc 1 1221 0
 886 04cc FB68     		ldr	r3, [r7, #12]
 887 04ce 1833     		adds	r3, r3, #24
 888 04d0 1846     		mov	r0, r3
 889 04d2 FFF7FEFF 		bl	uxListRemove
 890              	.L45:
1222:../FreeRTOS/tasks.c **** 			}
1223:../FreeRTOS/tasks.c **** 			else
1224:../FreeRTOS/tasks.c **** 			{
1225:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1226:../FreeRTOS/tasks.c **** 			}
1227:../FreeRTOS/tasks.c **** 
1228:../FreeRTOS/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 891              		.loc 1 1228 0
 892 04d6 FB68     		ldr	r3, [r7, #12]
 893 04d8 0433     		adds	r3, r3, #4
 894 04da 40F20000 		movw	r0, #:lower16:xSuspendedTaskList
 895 04de C0F20000 		movt	r0, #:upper16:xSuspendedTaskList
 896 04e2 1946     		mov	r1, r3
 897 04e4 FFF7FEFF 		bl	vListInsertEnd
1229:../FreeRTOS/tasks.c **** 		}
1230:../FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
 898              		.loc 1 1230 0
 899 04e8 FFF7FEFF 		bl	vPortExitCritical
1231:../FreeRTOS/tasks.c **** 
1232:../FreeRTOS/tasks.c **** 		if( pxTCB == pxCurrentTCB )
 900              		.loc 1 1232 0
 901 04ec 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 902 04f0 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 903 04f4 1B68     		ldr	r3, [r3]
 904 04f6 FA68     		ldr	r2, [r7, #12]
 905 04f8 9A42     		cmp	r2, r3
 906 04fa 1FD1     		bne	.L46
1233:../FreeRTOS/tasks.c **** 		{
1234:../FreeRTOS/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
 907              		.loc 1 1234 0
 908 04fc 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 909 0500 C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 910 0504 1B68     		ldr	r3, [r3]
 911 0506 002B     		cmp	r3, #0
 912 0508 02D0     		beq	.L47
1235:../FreeRTOS/tasks.c **** 			{
1236:../FreeRTOS/tasks.c **** 				/* The current task has just been suspended. */
1237:../FreeRTOS/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
1238:../FreeRTOS/tasks.c **** 				portYIELD_WITHIN_API();
 913              		.loc 1 1238 0
 914 050a FFF7FEFF 		bl	vPortYield
 915 050e 22E0     		b	.L42
 916              	.L47:
1239:../FreeRTOS/tasks.c **** 			}
1240:../FreeRTOS/tasks.c **** 			else
1241:../FreeRTOS/tasks.c **** 			{
1242:../FreeRTOS/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
1243:../FreeRTOS/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
1244:../FreeRTOS/tasks.c **** 				must be adjusted to point to a different task. */
1245:../FreeRTOS/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 917              		.loc 1 1245 0
 918 0510 40F20003 		movw	r3, #:lower16:xSuspendedTaskList
 919 0514 C0F20003 		movt	r3, #:upper16:xSuspendedTaskList
 920 0518 1A68     		ldr	r2, [r3]
 921 051a 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 922 051e C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 923 0522 1B68     		ldr	r3, [r3]
 924 0524 9A42     		cmp	r2, r3
 925 0526 06D1     		bne	.L49
1246:../FreeRTOS/tasks.c **** 				{
1247:../FreeRTOS/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
1248:../FreeRTOS/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
1249:../FreeRTOS/tasks.c **** 					be set to point to it no matter what its relative priority
1250:../FreeRTOS/tasks.c **** 					is. */
1251:../FreeRTOS/tasks.c **** 					pxCurrentTCB = NULL;
 926              		.loc 1 1251 0
 927 0528 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 928 052c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 929 0530 0022     		movs	r2, #0
 930 0532 1A60     		str	r2, [r3]
 931 0534 0FE0     		b	.L42
 932              	.L49:
1252:../FreeRTOS/tasks.c **** 				}
1253:../FreeRTOS/tasks.c **** 				else
1254:../FreeRTOS/tasks.c **** 				{
1255:../FreeRTOS/tasks.c **** 					vTaskSwitchContext();
 933              		.loc 1 1255 0
 934 0536 FFF7FEFF 		bl	vTaskSwitchContext
 935 053a 0CE0     		b	.L42
 936              	.L46:
1256:../FreeRTOS/tasks.c **** 				}
1257:../FreeRTOS/tasks.c **** 			}
1258:../FreeRTOS/tasks.c **** 		}
1259:../FreeRTOS/tasks.c **** 		else
1260:../FreeRTOS/tasks.c **** 		{
1261:../FreeRTOS/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
 937              		.loc 1 1261 0
 938 053c 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 939 0540 C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 940 0544 1B68     		ldr	r3, [r3]
 941 0546 002B     		cmp	r3, #0
 942 0548 05D0     		beq	.L42
1262:../FreeRTOS/tasks.c **** 			{
1263:../FreeRTOS/tasks.c **** 				/* A task other than the currently running task was suspended,
1264:../FreeRTOS/tasks.c **** 				reset the next expected unblock time in case it referred to the
1265:../FreeRTOS/tasks.c **** 				task that is now in the Suspended state. */
1266:../FreeRTOS/tasks.c **** 				taskENTER_CRITICAL();
 943              		.loc 1 1266 0
 944 054a FFF7FEFF 		bl	vPortEnterCritical
1267:../FreeRTOS/tasks.c **** 				{
1268:../FreeRTOS/tasks.c **** 					prvResetNextTaskUnblockTime();
 945              		.loc 1 1268 0
 946 054e 00F0BFFE 		bl	prvResetNextTaskUnblockTime
1269:../FreeRTOS/tasks.c **** 				}
1270:../FreeRTOS/tasks.c **** 				taskEXIT_CRITICAL();
 947              		.loc 1 1270 0
 948 0552 FFF7FEFF 		bl	vPortExitCritical
 949              	.L42:
1271:../FreeRTOS/tasks.c **** 			}
1272:../FreeRTOS/tasks.c **** 			else
1273:../FreeRTOS/tasks.c **** 			{
1274:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1275:../FreeRTOS/tasks.c **** 			}
1276:../FreeRTOS/tasks.c **** 		}
1277:../FreeRTOS/tasks.c **** 	}
 950              		.loc 1 1277 0
 951 0556 1037     		adds	r7, r7, #16
 952 0558 BD46     		mov	sp, r7
 953              		@ sp needed
 954 055a 80BD     		pop	{r7, pc}
 955              		.cfi_endproc
 956              	.LFE6:
 958              		.align	2
 959              		.thumb
 960              		.thumb_func
 962              	prvTaskIsTaskSuspended:
 963              	.LFB7:
1278:../FreeRTOS/tasks.c **** 
1279:../FreeRTOS/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1280:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1281:../FreeRTOS/tasks.c **** 
1282:../FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1283:../FreeRTOS/tasks.c **** 
1284:../FreeRTOS/tasks.c **** 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
1285:../FreeRTOS/tasks.c **** 	{
 964              		.loc 1 1285 0
 965              		.cfi_startproc
 966              		@ args = 0, pretend = 0, frame = 16
 967              		@ frame_needed = 1, uses_anonymous_args = 0
 968              		@ link register save eliminated.
 969 055c 80B4     		push	{r7}
 970              		.cfi_def_cfa_offset 4
 971              		.cfi_offset 7, -4
 972 055e 85B0     		sub	sp, sp, #20
 973              		.cfi_def_cfa_offset 24
 974 0560 00AF     		add	r7, sp, #0
 975              		.cfi_def_cfa_register 7
 976 0562 7860     		str	r0, [r7, #4]
1286:../FreeRTOS/tasks.c **** 	BaseType_t xReturn = pdFALSE;
 977              		.loc 1 1286 0
 978 0564 0023     		movs	r3, #0
 979 0566 FB60     		str	r3, [r7, #12]
1287:../FreeRTOS/tasks.c **** 	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
 980              		.loc 1 1287 0
 981 0568 7B68     		ldr	r3, [r7, #4]
 982 056a BB60     		str	r3, [r7, #8]
1288:../FreeRTOS/tasks.c **** 
1289:../FreeRTOS/tasks.c **** 		/* Accesses xPendingReadyList so must be called from a critical
1290:../FreeRTOS/tasks.c **** 		section. */
1291:../FreeRTOS/tasks.c **** 
1292:../FreeRTOS/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
1293:../FreeRTOS/tasks.c **** 		configASSERT( xTask );
1294:../FreeRTOS/tasks.c **** 
1295:../FreeRTOS/tasks.c **** 		/* Is the task being resumed actually in the suspended list? */
1296:../FreeRTOS/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 983              		.loc 1 1296 0
 984 056c BB68     		ldr	r3, [r7, #8]
 985 056e 5A69     		ldr	r2, [r3, #20]
 986 0570 40F20003 		movw	r3, #:lower16:xSuspendedTaskList
 987 0574 C0F20003 		movt	r3, #:upper16:xSuspendedTaskList
 988 0578 9A42     		cmp	r2, r3
 989 057a 01D1     		bne	.L52
 990              		.loc 1 1296 0 is_stmt 0 discriminator 1
 991 057c 0123     		movs	r3, #1
 992 057e 00E0     		b	.L53
 993              	.L52:
 994              		.loc 1 1296 0 discriminator 2
 995 0580 0023     		movs	r3, #0
 996              	.L53:
 997              		.loc 1 1296 0 discriminator 3
 998 0582 002B     		cmp	r3, #0
 999 0584 12D0     		beq	.L54
1297:../FreeRTOS/tasks.c **** 		{
1298:../FreeRTOS/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
1299:../FreeRTOS/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 1000              		.loc 1 1299 0 is_stmt 1
 1001 0586 BB68     		ldr	r3, [r7, #8]
 1002 0588 9A6A     		ldr	r2, [r3, #40]
 1003 058a 40F20003 		movw	r3, #:lower16:xPendingReadyList
 1004 058e C0F20003 		movt	r3, #:upper16:xPendingReadyList
 1005 0592 9A42     		cmp	r2, r3
 1006 0594 0AD0     		beq	.L54
1300:../FreeRTOS/tasks.c **** 			{
1301:../FreeRTOS/tasks.c **** 				/* Is it in the suspended list because it is in the	Suspended
1302:../FreeRTOS/tasks.c **** 				state, or because is is blocked with no timeout? */
1303:../FreeRTOS/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
 1007              		.loc 1 1303 0
 1008 0596 BB68     		ldr	r3, [r7, #8]
 1009 0598 9B6A     		ldr	r3, [r3, #40]
 1010 059a 002B     		cmp	r3, #0
 1011 059c 01D1     		bne	.L55
 1012              		.loc 1 1303 0 is_stmt 0 discriminator 1
 1013 059e 0123     		movs	r3, #1
 1014 05a0 00E0     		b	.L56
 1015              	.L55:
 1016              		.loc 1 1303 0 discriminator 2
 1017 05a2 0023     		movs	r3, #0
 1018              	.L56:
 1019              		.loc 1 1303 0 discriminator 3
 1020 05a4 002B     		cmp	r3, #0
 1021 05a6 01D0     		beq	.L54
1304:../FreeRTOS/tasks.c **** 				{
1305:../FreeRTOS/tasks.c **** 					xReturn = pdTRUE;
 1022              		.loc 1 1305 0 is_stmt 1
 1023 05a8 0123     		movs	r3, #1
 1024 05aa FB60     		str	r3, [r7, #12]
 1025              	.L54:
1306:../FreeRTOS/tasks.c **** 				}
1307:../FreeRTOS/tasks.c **** 				else
1308:../FreeRTOS/tasks.c **** 				{
1309:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1310:../FreeRTOS/tasks.c **** 				}
1311:../FreeRTOS/tasks.c **** 			}
1312:../FreeRTOS/tasks.c **** 			else
1313:../FreeRTOS/tasks.c **** 			{
1314:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1315:../FreeRTOS/tasks.c **** 			}
1316:../FreeRTOS/tasks.c **** 		}
1317:../FreeRTOS/tasks.c **** 		else
1318:../FreeRTOS/tasks.c **** 		{
1319:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1320:../FreeRTOS/tasks.c **** 		}
1321:../FreeRTOS/tasks.c **** 
1322:../FreeRTOS/tasks.c **** 		return xReturn;
 1026              		.loc 1 1322 0
 1027 05ac FB68     		ldr	r3, [r7, #12]
1323:../FreeRTOS/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 1028              		.loc 1 1323 0
 1029 05ae 1846     		mov	r0, r3
 1030 05b0 1437     		adds	r7, r7, #20
 1031 05b2 BD46     		mov	sp, r7
 1032              		@ sp needed
 1033 05b4 5DF8047B 		ldr	r7, [sp], #4
 1034 05b8 7047     		bx	lr
 1035              		.cfi_endproc
 1036              	.LFE7:
 1038 05ba 00BF     		.align	2
 1039              		.global	vTaskResume
 1040              		.thumb
 1041              		.thumb_func
 1043              	vTaskResume:
 1044              	.LFB8:
1324:../FreeRTOS/tasks.c **** 
1325:../FreeRTOS/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1326:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1327:../FreeRTOS/tasks.c **** 
1328:../FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1329:../FreeRTOS/tasks.c **** 
1330:../FreeRTOS/tasks.c **** 	void vTaskResume( TaskHandle_t xTaskToResume )
1331:../FreeRTOS/tasks.c **** 	{
 1045              		.loc 1 1331 0
 1046              		.cfi_startproc
 1047              		@ args = 0, pretend = 0, frame = 16
 1048              		@ frame_needed = 1, uses_anonymous_args = 0
 1049 05bc 80B5     		push	{r7, lr}
 1050              		.cfi_def_cfa_offset 8
 1051              		.cfi_offset 7, -8
 1052              		.cfi_offset 14, -4
 1053 05be 84B0     		sub	sp, sp, #16
 1054              		.cfi_def_cfa_offset 24
 1055 05c0 00AF     		add	r7, sp, #0
 1056              		.cfi_def_cfa_register 7
 1057 05c2 7860     		str	r0, [r7, #4]
1332:../FreeRTOS/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
 1058              		.loc 1 1332 0
 1059 05c4 7B68     		ldr	r3, [r7, #4]
 1060 05c6 FB60     		str	r3, [r7, #12]
1333:../FreeRTOS/tasks.c **** 
1334:../FreeRTOS/tasks.c **** 		/* It does not make sense to resume the calling task. */
1335:../FreeRTOS/tasks.c **** 		configASSERT( xTaskToResume );
1336:../FreeRTOS/tasks.c **** 
1337:../FreeRTOS/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
1338:../FreeRTOS/tasks.c **** 		currently executing task. */
1339:../FreeRTOS/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 1061              		.loc 1 1339 0
 1062 05c8 FB68     		ldr	r3, [r7, #12]
 1063 05ca 002B     		cmp	r3, #0
 1064 05cc 43D0     		beq	.L58
 1065              		.loc 1 1339 0 is_stmt 0 discriminator 1
 1066 05ce 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1067 05d2 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1068 05d6 1B68     		ldr	r3, [r3]
 1069 05d8 FA68     		ldr	r2, [r7, #12]
 1070 05da 9A42     		cmp	r2, r3
 1071 05dc 3BD0     		beq	.L58
1340:../FreeRTOS/tasks.c **** 		{
1341:../FreeRTOS/tasks.c **** 			taskENTER_CRITICAL();
 1072              		.loc 1 1341 0 is_stmt 1
 1073 05de FFF7FEFF 		bl	vPortEnterCritical
1342:../FreeRTOS/tasks.c **** 			{
1343:../FreeRTOS/tasks.c **** 				if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1074              		.loc 1 1343 0
 1075 05e2 F868     		ldr	r0, [r7, #12]
 1076 05e4 FFF7BAFF 		bl	prvTaskIsTaskSuspended
 1077 05e8 0346     		mov	r3, r0
 1078 05ea 012B     		cmp	r3, #1
 1079 05ec 31D1     		bne	.L60
1344:../FreeRTOS/tasks.c **** 				{
1345:../FreeRTOS/tasks.c **** 					traceTASK_RESUME( pxTCB );
1346:../FreeRTOS/tasks.c **** 
1347:../FreeRTOS/tasks.c **** 					/* As we are in a critical section we can access the ready
1348:../FreeRTOS/tasks.c **** 					lists even if the scheduler is suspended. */
1349:../FreeRTOS/tasks.c **** 					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
 1080              		.loc 1 1349 0
 1081 05ee FB68     		ldr	r3, [r7, #12]
 1082 05f0 0433     		adds	r3, r3, #4
 1083 05f2 1846     		mov	r0, r3
 1084 05f4 FFF7FEFF 		bl	uxListRemove
1350:../FreeRTOS/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1085              		.loc 1 1350 0
 1086 05f8 FB68     		ldr	r3, [r7, #12]
 1087 05fa DA6A     		ldr	r2, [r3, #44]
 1088 05fc 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1089 0600 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1090 0604 1B68     		ldr	r3, [r3]
 1091 0606 9A42     		cmp	r2, r3
 1092 0608 06D9     		bls	.L61
 1093              		.loc 1 1350 0 is_stmt 0 discriminator 1
 1094 060a FB68     		ldr	r3, [r7, #12]
 1095 060c DA6A     		ldr	r2, [r3, #44]
 1096 060e 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1097 0612 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1098 0616 1A60     		str	r2, [r3]
 1099              	.L61:
 1100              		.loc 1 1350 0 discriminator 2
 1101 0618 FB68     		ldr	r3, [r7, #12]
 1102 061a DA6A     		ldr	r2, [r3, #44]
 1103 061c 1346     		mov	r3, r2
 1104 061e 9B00     		lsls	r3, r3, #2
 1105 0620 1344     		add	r3, r3, r2
 1106 0622 9B00     		lsls	r3, r3, #2
 1107 0624 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 1108 0628 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 1109 062c 1A44     		add	r2, r2, r3
 1110 062e FB68     		ldr	r3, [r7, #12]
 1111 0630 0433     		adds	r3, r3, #4
 1112 0632 1046     		mov	r0, r2
 1113 0634 1946     		mov	r1, r3
 1114 0636 FFF7FEFF 		bl	vListInsertEnd
1351:../FreeRTOS/tasks.c **** 
1352:../FreeRTOS/tasks.c **** 					/* We may have just resumed a higher priority task. */
1353:../FreeRTOS/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1115              		.loc 1 1353 0 is_stmt 1 discriminator 2
 1116 063a FB68     		ldr	r3, [r7, #12]
 1117 063c DA6A     		ldr	r2, [r3, #44]
 1118 063e 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1119 0642 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1120 0646 1B68     		ldr	r3, [r3]
 1121 0648 DB6A     		ldr	r3, [r3, #44]
 1122 064a 9A42     		cmp	r2, r3
 1123 064c 01D3     		bcc	.L60
1354:../FreeRTOS/tasks.c **** 					{
1355:../FreeRTOS/tasks.c **** 						/* This yield may not cause the task just resumed to run,
1356:../FreeRTOS/tasks.c **** 						but will leave the lists in the correct state for the
1357:../FreeRTOS/tasks.c **** 						next yield. */
1358:../FreeRTOS/tasks.c **** 						taskYIELD_IF_USING_PREEMPTION();
 1124              		.loc 1 1358 0
 1125 064e FFF7FEFF 		bl	vPortYield
 1126              	.L60:
1359:../FreeRTOS/tasks.c **** 					}
1360:../FreeRTOS/tasks.c **** 					else
1361:../FreeRTOS/tasks.c **** 					{
1362:../FreeRTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1363:../FreeRTOS/tasks.c **** 					}
1364:../FreeRTOS/tasks.c **** 				}
1365:../FreeRTOS/tasks.c **** 				else
1366:../FreeRTOS/tasks.c **** 				{
1367:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1368:../FreeRTOS/tasks.c **** 				}
1369:../FreeRTOS/tasks.c **** 			}
1370:../FreeRTOS/tasks.c **** 			taskEXIT_CRITICAL();
 1127              		.loc 1 1370 0 discriminator 2
 1128 0652 FFF7FEFF 		bl	vPortExitCritical
 1129              	.L58:
1371:../FreeRTOS/tasks.c **** 		}
1372:../FreeRTOS/tasks.c **** 		else
1373:../FreeRTOS/tasks.c **** 		{
1374:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1375:../FreeRTOS/tasks.c **** 		}
1376:../FreeRTOS/tasks.c **** 	}
 1130              		.loc 1 1376 0
 1131 0656 1037     		adds	r7, r7, #16
 1132 0658 BD46     		mov	sp, r7
 1133              		@ sp needed
 1134 065a 80BD     		pop	{r7, pc}
 1135              		.cfi_endproc
 1136              	.LFE8:
 1138              		.align	2
 1139              		.global	xTaskResumeFromISR
 1140              		.thumb
 1141              		.thumb_func
 1143              	xTaskResumeFromISR:
 1144              	.LFB9:
1377:../FreeRTOS/tasks.c **** 
1378:../FreeRTOS/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1379:../FreeRTOS/tasks.c **** 
1380:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1381:../FreeRTOS/tasks.c **** 
1382:../FreeRTOS/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1383:../FreeRTOS/tasks.c **** 
1384:../FreeRTOS/tasks.c **** 	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
1385:../FreeRTOS/tasks.c **** 	{
 1145              		.loc 1 1385 0
 1146              		.cfi_startproc
 1147              		@ args = 0, pretend = 0, frame = 24
 1148              		@ frame_needed = 1, uses_anonymous_args = 0
 1149 065c 80B5     		push	{r7, lr}
 1150              		.cfi_def_cfa_offset 8
 1151              		.cfi_offset 7, -8
 1152              		.cfi_offset 14, -4
 1153 065e 86B0     		sub	sp, sp, #24
 1154              		.cfi_def_cfa_offset 32
 1155 0660 00AF     		add	r7, sp, #0
 1156              		.cfi_def_cfa_register 7
 1157 0662 7860     		str	r0, [r7, #4]
1386:../FreeRTOS/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
 1158              		.loc 1 1386 0
 1159 0664 0023     		movs	r3, #0
 1160 0666 7B61     		str	r3, [r7, #20]
1387:../FreeRTOS/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
 1161              		.loc 1 1387 0
 1162 0668 7B68     		ldr	r3, [r7, #4]
 1163 066a 3B61     		str	r3, [r7, #16]
1388:../FreeRTOS/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
1389:../FreeRTOS/tasks.c **** 
1390:../FreeRTOS/tasks.c **** 		configASSERT( xTaskToResume );
1391:../FreeRTOS/tasks.c **** 
1392:../FreeRTOS/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1393:../FreeRTOS/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1394:../FreeRTOS/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1395:../FreeRTOS/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1396:../FreeRTOS/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1397:../FreeRTOS/tasks.c **** 		is defined in FreeRTOSConfig.h then
1398:../FreeRTOS/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1399:../FreeRTOS/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1400:../FreeRTOS/tasks.c **** 		been assigned a priority above the configured maximum system call
1401:../FreeRTOS/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1402:../FreeRTOS/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1403:../FreeRTOS/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1404:../FreeRTOS/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1405:../FreeRTOS/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1406:../FreeRTOS/tasks.c **** 		provided on the following link:
1407:../FreeRTOS/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1408:../FreeRTOS/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1409:../FreeRTOS/tasks.c **** 
1410:../FreeRTOS/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1164              		.loc 1 1410 0
 1165 066c FFF7FEFF 		bl	ulPortSetInterruptMask
 1166 0670 F860     		str	r0, [r7, #12]
1411:../FreeRTOS/tasks.c **** 		{
1412:../FreeRTOS/tasks.c **** 			if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1167              		.loc 1 1412 0
 1168 0672 3869     		ldr	r0, [r7, #16]
 1169 0674 FFF772FF 		bl	prvTaskIsTaskSuspended
 1170 0678 0346     		mov	r3, r0
 1171 067a 012B     		cmp	r3, #1
 1172 067c 42D1     		bne	.L63
1413:../FreeRTOS/tasks.c **** 			{
1414:../FreeRTOS/tasks.c **** 				traceTASK_RESUME_FROM_ISR( pxTCB );
1415:../FreeRTOS/tasks.c **** 
1416:../FreeRTOS/tasks.c **** 				/* Check the ready lists can be accessed. */
1417:../FreeRTOS/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 1173              		.loc 1 1417 0
 1174 067e 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1175 0682 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1176 0686 1B68     		ldr	r3, [r3]
 1177 0688 002B     		cmp	r3, #0
 1178 068a 32D1     		bne	.L64
1418:../FreeRTOS/tasks.c **** 				{
1419:../FreeRTOS/tasks.c **** 					/* Ready lists can be accessed so move the task from the
1420:../FreeRTOS/tasks.c **** 					suspended list to the ready list directly. */
1421:../FreeRTOS/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1179              		.loc 1 1421 0
 1180 068c 3B69     		ldr	r3, [r7, #16]
 1181 068e DA6A     		ldr	r2, [r3, #44]
 1182 0690 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1183 0694 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1184 0698 1B68     		ldr	r3, [r3]
 1185 069a DB6A     		ldr	r3, [r3, #44]
 1186 069c 9A42     		cmp	r2, r3
 1187 069e 01D3     		bcc	.L65
1422:../FreeRTOS/tasks.c **** 					{
1423:../FreeRTOS/tasks.c **** 						xYieldRequired = pdTRUE;
 1188              		.loc 1 1423 0
 1189 06a0 0123     		movs	r3, #1
 1190 06a2 7B61     		str	r3, [r7, #20]
 1191              	.L65:
1424:../FreeRTOS/tasks.c **** 					}
1425:../FreeRTOS/tasks.c **** 					else
1426:../FreeRTOS/tasks.c **** 					{
1427:../FreeRTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1428:../FreeRTOS/tasks.c **** 					}
1429:../FreeRTOS/tasks.c **** 
1430:../FreeRTOS/tasks.c **** 					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
 1192              		.loc 1 1430 0
 1193 06a4 3B69     		ldr	r3, [r7, #16]
 1194 06a6 0433     		adds	r3, r3, #4
 1195 06a8 1846     		mov	r0, r3
 1196 06aa FFF7FEFF 		bl	uxListRemove
1431:../FreeRTOS/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1197              		.loc 1 1431 0
 1198 06ae 3B69     		ldr	r3, [r7, #16]
 1199 06b0 DA6A     		ldr	r2, [r3, #44]
 1200 06b2 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1201 06b6 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1202 06ba 1B68     		ldr	r3, [r3]
 1203 06bc 9A42     		cmp	r2, r3
 1204 06be 06D9     		bls	.L66
 1205              		.loc 1 1431 0 is_stmt 0 discriminator 1
 1206 06c0 3B69     		ldr	r3, [r7, #16]
 1207 06c2 DA6A     		ldr	r2, [r3, #44]
 1208 06c4 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1209 06c8 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1210 06cc 1A60     		str	r2, [r3]
 1211              	.L66:
 1212              		.loc 1 1431 0 discriminator 2
 1213 06ce 3B69     		ldr	r3, [r7, #16]
 1214 06d0 DA6A     		ldr	r2, [r3, #44]
 1215 06d2 1346     		mov	r3, r2
 1216 06d4 9B00     		lsls	r3, r3, #2
 1217 06d6 1344     		add	r3, r3, r2
 1218 06d8 9B00     		lsls	r3, r3, #2
 1219 06da 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 1220 06de C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 1221 06e2 1A44     		add	r2, r2, r3
 1222 06e4 3B69     		ldr	r3, [r7, #16]
 1223 06e6 0433     		adds	r3, r3, #4
 1224 06e8 1046     		mov	r0, r2
 1225 06ea 1946     		mov	r1, r3
 1226 06ec FFF7FEFF 		bl	vListInsertEnd
 1227 06f0 08E0     		b	.L63
 1228              	.L64:
1432:../FreeRTOS/tasks.c **** 				}
1433:../FreeRTOS/tasks.c **** 				else
1434:../FreeRTOS/tasks.c **** 				{
1435:../FreeRTOS/tasks.c **** 					/* The delayed or ready lists cannot be accessed so the task
1436:../FreeRTOS/tasks.c **** 					is held in the pending ready list until the scheduler is
1437:../FreeRTOS/tasks.c **** 					unsuspended. */
1438:../FreeRTOS/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 1229              		.loc 1 1438 0 is_stmt 1
 1230 06f2 3B69     		ldr	r3, [r7, #16]
 1231 06f4 1833     		adds	r3, r3, #24
 1232 06f6 40F20000 		movw	r0, #:lower16:xPendingReadyList
 1233 06fa C0F20000 		movt	r0, #:upper16:xPendingReadyList
 1234 06fe 1946     		mov	r1, r3
 1235 0700 FFF7FEFF 		bl	vListInsertEnd
 1236              	.L63:
1439:../FreeRTOS/tasks.c **** 				}
1440:../FreeRTOS/tasks.c **** 			}
1441:../FreeRTOS/tasks.c **** 			else
1442:../FreeRTOS/tasks.c **** 			{
1443:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1444:../FreeRTOS/tasks.c **** 			}
1445:../FreeRTOS/tasks.c **** 		}
1446:../FreeRTOS/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1237              		.loc 1 1446 0
 1238 0704 F868     		ldr	r0, [r7, #12]
 1239 0706 FFF7FEFF 		bl	vPortClearInterruptMask
1447:../FreeRTOS/tasks.c **** 
1448:../FreeRTOS/tasks.c **** 		return xYieldRequired;
 1240              		.loc 1 1448 0
 1241 070a 7B69     		ldr	r3, [r7, #20]
1449:../FreeRTOS/tasks.c **** 	}
 1242              		.loc 1 1449 0
 1243 070c 1846     		mov	r0, r3
 1244 070e 1837     		adds	r7, r7, #24
 1245 0710 BD46     		mov	sp, r7
 1246              		@ sp needed
 1247 0712 80BD     		pop	{r7, pc}
 1248              		.cfi_endproc
 1249              	.LFE9:
 1251              		.section	.rodata
 1252              		.align	2
 1253              	.LC0:
 1254 0000 49444C45 		.ascii	"IDLE\000"
 1254      00
 1255              		.text
 1256              		.align	2
 1257              		.global	vTaskStartScheduler
 1258              		.thumb
 1259              		.thumb_func
 1261              	vTaskStartScheduler:
 1262              	.LFB10:
1450:../FreeRTOS/tasks.c **** 
1451:../FreeRTOS/tasks.c **** #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1452:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1453:../FreeRTOS/tasks.c **** 
1454:../FreeRTOS/tasks.c **** void vTaskStartScheduler( void )
1455:../FreeRTOS/tasks.c **** {
 1263              		.loc 1 1455 0
 1264              		.cfi_startproc
 1265              		@ args = 0, pretend = 0, frame = 8
 1266              		@ frame_needed = 1, uses_anonymous_args = 0
 1267 0714 80B5     		push	{r7, lr}
 1268              		.cfi_def_cfa_offset 8
 1269              		.cfi_offset 7, -8
 1270              		.cfi_offset 14, -4
 1271 0716 86B0     		sub	sp, sp, #24
 1272              		.cfi_def_cfa_offset 32
 1273 0718 04AF     		add	r7, sp, #16
 1274              		.cfi_def_cfa 7, 16
1456:../FreeRTOS/tasks.c **** BaseType_t xReturn;
1457:../FreeRTOS/tasks.c **** 
1458:../FreeRTOS/tasks.c **** 	/* Add the idle task at the lowest priority. */
1459:../FreeRTOS/tasks.c **** 	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1460:../FreeRTOS/tasks.c **** 	{
1461:../FreeRTOS/tasks.c **** 		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
1462:../FreeRTOS/tasks.c **** 		be returned by the xTaskGetIdleTaskHandle() function. */
1463:../FreeRTOS/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORI
1464:../FreeRTOS/tasks.c **** 	}
1465:../FreeRTOS/tasks.c **** 	#else
1466:../FreeRTOS/tasks.c **** 	{
1467:../FreeRTOS/tasks.c **** 		/* Create the idle task without storing its handle. */
1468:../FreeRTOS/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORI
 1275              		.loc 1 1468 0
 1276 071a 0023     		movs	r3, #0
 1277 071c 0093     		str	r3, [sp]
 1278 071e 0023     		movs	r3, #0
 1279 0720 0193     		str	r3, [sp, #4]
 1280 0722 0023     		movs	r3, #0
 1281 0724 0293     		str	r3, [sp, #8]
 1282 0726 0023     		movs	r3, #0
 1283 0728 0393     		str	r3, [sp, #12]
 1284 072a 40F20000 		movw	r0, #:lower16:prvIdleTask
 1285 072e C0F20000 		movt	r0, #:upper16:prvIdleTask
 1286 0732 40F20001 		movw	r1, #:lower16:.LC0
 1287 0736 C0F20001 		movt	r1, #:upper16:.LC0
 1288 073a 8022     		movs	r2, #128
 1289 073c 0023     		movs	r3, #0
 1290 073e FFF7FEFF 		bl	xTaskGenericCreate
 1291 0742 7860     		str	r0, [r7, #4]
1469:../FreeRTOS/tasks.c **** 	}
1470:../FreeRTOS/tasks.c **** 	#endif /* INCLUDE_xTaskGetIdleTaskHandle */
1471:../FreeRTOS/tasks.c **** 
1472:../FreeRTOS/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
1473:../FreeRTOS/tasks.c **** 	{
1474:../FreeRTOS/tasks.c **** 		if( xReturn == pdPASS )
1475:../FreeRTOS/tasks.c **** 		{
1476:../FreeRTOS/tasks.c **** 			xReturn = xTimerCreateTimerTask();
1477:../FreeRTOS/tasks.c **** 		}
1478:../FreeRTOS/tasks.c **** 		else
1479:../FreeRTOS/tasks.c **** 		{
1480:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1481:../FreeRTOS/tasks.c **** 		}
1482:../FreeRTOS/tasks.c **** 	}
1483:../FreeRTOS/tasks.c **** 	#endif /* configUSE_TIMERS */
1484:../FreeRTOS/tasks.c **** 
1485:../FreeRTOS/tasks.c **** 	if( xReturn == pdPASS )
 1292              		.loc 1 1485 0
 1293 0744 7B68     		ldr	r3, [r7, #4]
 1294 0746 012B     		cmp	r3, #1
 1295 0748 0FD1     		bne	.L69
1486:../FreeRTOS/tasks.c **** 	{
1487:../FreeRTOS/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1488:../FreeRTOS/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
1489:../FreeRTOS/tasks.c **** 		the created tasks contain a status word with interrupts switched on
1490:../FreeRTOS/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
1491:../FreeRTOS/tasks.c **** 		starts to run. */
1492:../FreeRTOS/tasks.c **** 		portDISABLE_INTERRUPTS();
 1296              		.loc 1 1492 0
 1297 074a FFF7FEFF 		bl	ulPortSetInterruptMask
1493:../FreeRTOS/tasks.c **** 
1494:../FreeRTOS/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
1495:../FreeRTOS/tasks.c **** 		{
1496:../FreeRTOS/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
1497:../FreeRTOS/tasks.c **** 			structure specific to the task that will run first. */
1498:../FreeRTOS/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
1499:../FreeRTOS/tasks.c **** 		}
1500:../FreeRTOS/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
1501:../FreeRTOS/tasks.c **** 
1502:../FreeRTOS/tasks.c **** 		xSchedulerRunning = pdTRUE;
 1298              		.loc 1 1502 0
 1299 074e 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 1300 0752 C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 1301 0756 0122     		movs	r2, #1
 1302 0758 1A60     		str	r2, [r3]
1503:../FreeRTOS/tasks.c **** 		xTickCount = ( TickType_t ) 0U;
 1303              		.loc 1 1503 0
 1304 075a 40F20003 		movw	r3, #:lower16:xTickCount
 1305 075e C0F20003 		movt	r3, #:upper16:xTickCount
 1306 0762 0022     		movs	r2, #0
 1307 0764 1A60     		str	r2, [r3]
1504:../FreeRTOS/tasks.c **** 
1505:../FreeRTOS/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1506:../FreeRTOS/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
1507:../FreeRTOS/tasks.c **** 		the run time counter time base. */
1508:../FreeRTOS/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1509:../FreeRTOS/tasks.c **** 
1510:../FreeRTOS/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
1511:../FreeRTOS/tasks.c **** 		portable interface. */
1512:../FreeRTOS/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
 1308              		.loc 1 1512 0
 1309 0766 FFF7FEFF 		bl	xPortStartScheduler
 1310              	.L69:
1513:../FreeRTOS/tasks.c **** 		{
1514:../FreeRTOS/tasks.c **** 			/* Should not reach here as if the scheduler is running the
1515:../FreeRTOS/tasks.c **** 			function will not return. */
1516:../FreeRTOS/tasks.c **** 		}
1517:../FreeRTOS/tasks.c **** 		else
1518:../FreeRTOS/tasks.c **** 		{
1519:../FreeRTOS/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
1520:../FreeRTOS/tasks.c **** 		}
1521:../FreeRTOS/tasks.c **** 	}
1522:../FreeRTOS/tasks.c **** 	else
1523:../FreeRTOS/tasks.c **** 	{
1524:../FreeRTOS/tasks.c **** 		/* This line will only be reached if the kernel could not be started,
1525:../FreeRTOS/tasks.c **** 		because there was not enough FreeRTOS heap to create the idle task
1526:../FreeRTOS/tasks.c **** 		or the timer task. */
1527:../FreeRTOS/tasks.c **** 		configASSERT( xReturn );
1528:../FreeRTOS/tasks.c **** 	}
1529:../FreeRTOS/tasks.c **** }
 1311              		.loc 1 1529 0
 1312 076a 0837     		adds	r7, r7, #8
 1313 076c BD46     		mov	sp, r7
 1314              		@ sp needed
 1315 076e 80BD     		pop	{r7, pc}
 1316              		.cfi_endproc
 1317              	.LFE10:
 1319              		.align	2
 1320              		.global	vTaskEndScheduler
 1321              		.thumb
 1322              		.thumb_func
 1324              	vTaskEndScheduler:
 1325              	.LFB11:
1530:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1531:../FreeRTOS/tasks.c **** 
1532:../FreeRTOS/tasks.c **** void vTaskEndScheduler( void )
1533:../FreeRTOS/tasks.c **** {
 1326              		.loc 1 1533 0
 1327              		.cfi_startproc
 1328              		@ args = 0, pretend = 0, frame = 0
 1329              		@ frame_needed = 1, uses_anonymous_args = 0
 1330 0770 80B5     		push	{r7, lr}
 1331              		.cfi_def_cfa_offset 8
 1332              		.cfi_offset 7, -8
 1333              		.cfi_offset 14, -4
 1334 0772 00AF     		add	r7, sp, #0
 1335              		.cfi_def_cfa_register 7
1534:../FreeRTOS/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
1535:../FreeRTOS/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
1536:../FreeRTOS/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
1537:../FreeRTOS/tasks.c **** 	portDISABLE_INTERRUPTS();
 1336              		.loc 1 1537 0
 1337 0774 FFF7FEFF 		bl	ulPortSetInterruptMask
1538:../FreeRTOS/tasks.c **** 	xSchedulerRunning = pdFALSE;
 1338              		.loc 1 1538 0
 1339 0778 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 1340 077c C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 1341 0780 0022     		movs	r2, #0
 1342 0782 1A60     		str	r2, [r3]
1539:../FreeRTOS/tasks.c **** 	vPortEndScheduler();
 1343              		.loc 1 1539 0
 1344 0784 FFF7FEFF 		bl	vPortEndScheduler
1540:../FreeRTOS/tasks.c **** }
 1345              		.loc 1 1540 0
 1346 0788 80BD     		pop	{r7, pc}
 1347              		.cfi_endproc
 1348              	.LFE11:
 1350 078a 00BF     		.align	2
 1351              		.global	vTaskSuspendAll
 1352              		.thumb
 1353              		.thumb_func
 1355              	vTaskSuspendAll:
 1356              	.LFB12:
1541:../FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
1542:../FreeRTOS/tasks.c **** 
1543:../FreeRTOS/tasks.c **** void vTaskSuspendAll( void )
1544:../FreeRTOS/tasks.c **** {
 1357              		.loc 1 1544 0
 1358              		.cfi_startproc
 1359              		@ args = 0, pretend = 0, frame = 0
 1360              		@ frame_needed = 1, uses_anonymous_args = 0
 1361              		@ link register save eliminated.
 1362 078c 80B4     		push	{r7}
 1363              		.cfi_def_cfa_offset 4
 1364              		.cfi_offset 7, -4
 1365 078e 00AF     		add	r7, sp, #0
 1366              		.cfi_def_cfa_register 7
1545:../FreeRTOS/tasks.c **** 	/* A critical section is not required as the variable is of type
1546:../FreeRTOS/tasks.c **** 	BaseType_t.  Please read Richard Barry's reply in the following link to a
1547:../FreeRTOS/tasks.c **** 	post in the FreeRTOS support forum before reporting this as a bug! -
1548:../FreeRTOS/tasks.c **** 	http://goo.gl/wu4acr */
1549:../FreeRTOS/tasks.c **** 	++uxSchedulerSuspended;
 1367              		.loc 1 1549 0
 1368 0790 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1369 0794 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1370 0798 1B68     		ldr	r3, [r3]
 1371 079a 5A1C     		adds	r2, r3, #1
 1372 079c 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1373 07a0 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1374 07a4 1A60     		str	r2, [r3]
1550:../FreeRTOS/tasks.c **** }
 1375              		.loc 1 1550 0
 1376 07a6 BD46     		mov	sp, r7
 1377              		@ sp needed
 1378 07a8 5DF8047B 		ldr	r7, [sp], #4
 1379 07ac 7047     		bx	lr
 1380              		.cfi_endproc
 1381              	.LFE12:
 1383 07ae 00BF     		.align	2
 1384              		.global	xTaskResumeAll
 1385              		.thumb
 1386              		.thumb_func
 1388              	xTaskResumeAll:
 1389              	.LFB13:
1551:../FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
1552:../FreeRTOS/tasks.c **** 
1553:../FreeRTOS/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
1554:../FreeRTOS/tasks.c **** 
1555:../FreeRTOS/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void )
1556:../FreeRTOS/tasks.c **** 	{
1557:../FreeRTOS/tasks.c **** 	TickType_t xReturn;
1558:../FreeRTOS/tasks.c **** 
1559:../FreeRTOS/tasks.c **** 		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
1560:../FreeRTOS/tasks.c **** 		{
1561:../FreeRTOS/tasks.c **** 			xReturn = 0;
1562:../FreeRTOS/tasks.c **** 		}
1563:../FreeRTOS/tasks.c **** 		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
1564:../FreeRTOS/tasks.c **** 		{
1565:../FreeRTOS/tasks.c **** 			/* There are other idle priority tasks in the ready state.  If
1566:../FreeRTOS/tasks.c **** 			time slicing is used then the very next tick interrupt must be
1567:../FreeRTOS/tasks.c **** 			processed. */
1568:../FreeRTOS/tasks.c **** 			xReturn = 0;
1569:../FreeRTOS/tasks.c **** 		}
1570:../FreeRTOS/tasks.c **** 		else
1571:../FreeRTOS/tasks.c **** 		{
1572:../FreeRTOS/tasks.c **** 			xReturn = xNextTaskUnblockTime - xTickCount;
1573:../FreeRTOS/tasks.c **** 		}
1574:../FreeRTOS/tasks.c **** 
1575:../FreeRTOS/tasks.c **** 		return xReturn;
1576:../FreeRTOS/tasks.c **** 	}
1577:../FreeRTOS/tasks.c **** 
1578:../FreeRTOS/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
1579:../FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
1580:../FreeRTOS/tasks.c **** 
1581:../FreeRTOS/tasks.c **** BaseType_t xTaskResumeAll( void )
1582:../FreeRTOS/tasks.c **** {
 1390              		.loc 1 1582 0
 1391              		.cfi_startproc
 1392              		@ args = 0, pretend = 0, frame = 8
 1393              		@ frame_needed = 1, uses_anonymous_args = 0
 1394 07b0 80B5     		push	{r7, lr}
 1395              		.cfi_def_cfa_offset 8
 1396              		.cfi_offset 7, -8
 1397              		.cfi_offset 14, -4
 1398 07b2 82B0     		sub	sp, sp, #8
 1399              		.cfi_def_cfa_offset 16
 1400 07b4 00AF     		add	r7, sp, #0
 1401              		.cfi_def_cfa_register 7
1583:../FreeRTOS/tasks.c **** TCB_t *pxTCB;
1584:../FreeRTOS/tasks.c **** BaseType_t xAlreadyYielded = pdFALSE;
 1402              		.loc 1 1584 0
 1403 07b6 0023     		movs	r3, #0
 1404 07b8 7B60     		str	r3, [r7, #4]
1585:../FreeRTOS/tasks.c **** 
1586:../FreeRTOS/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
1587:../FreeRTOS/tasks.c **** 	previous call to vTaskSuspendAll(). */
1588:../FreeRTOS/tasks.c **** 	configASSERT( uxSchedulerSuspended );
1589:../FreeRTOS/tasks.c **** 
1590:../FreeRTOS/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
1591:../FreeRTOS/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
1592:../FreeRTOS/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
1593:../FreeRTOS/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
1594:../FreeRTOS/tasks.c **** 	tasks from this list into their appropriate ready list. */
1595:../FreeRTOS/tasks.c **** 	taskENTER_CRITICAL();
 1405              		.loc 1 1595 0
 1406 07ba FFF7FEFF 		bl	vPortEnterCritical
1596:../FreeRTOS/tasks.c **** 	{
1597:../FreeRTOS/tasks.c **** 		--uxSchedulerSuspended;
 1407              		.loc 1 1597 0
 1408 07be 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1409 07c2 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1410 07c6 1B68     		ldr	r3, [r3]
 1411 07c8 5A1E     		subs	r2, r3, #1
 1412 07ca 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1413 07ce C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1414 07d2 1A60     		str	r2, [r3]
1598:../FreeRTOS/tasks.c **** 
1599:../FreeRTOS/tasks.c **** 		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 1415              		.loc 1 1599 0
 1416 07d4 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1417 07d8 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1418 07dc 1B68     		ldr	r3, [r3]
 1419 07de 002B     		cmp	r3, #0
 1420 07e0 40F08180 		bne	.L74
1600:../FreeRTOS/tasks.c **** 		{
1601:../FreeRTOS/tasks.c **** 			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 1421              		.loc 1 1601 0
 1422 07e4 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 1423 07e8 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 1424 07ec 1B68     		ldr	r3, [r3]
 1425 07ee 002B     		cmp	r3, #0
 1426 07f0 79D0     		beq	.L74
1602:../FreeRTOS/tasks.c **** 			{
1603:../FreeRTOS/tasks.c **** 				/* Move any readied tasks from the pending list into the
1604:../FreeRTOS/tasks.c **** 				appropriate ready list. */
1605:../FreeRTOS/tasks.c **** 				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 1427              		.loc 1 1605 0
 1428 07f2 41E0     		b	.L75
 1429              	.L77:
1606:../FreeRTOS/tasks.c **** 				{
1607:../FreeRTOS/tasks.c **** 					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 1430              		.loc 1 1607 0
 1431 07f4 40F20003 		movw	r3, #:lower16:xPendingReadyList
 1432 07f8 C0F20003 		movt	r3, #:upper16:xPendingReadyList
 1433 07fc DB68     		ldr	r3, [r3, #12]
 1434 07fe DB68     		ldr	r3, [r3, #12]
 1435 0800 3B60     		str	r3, [r7]
1608:../FreeRTOS/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1436              		.loc 1 1608 0
 1437 0802 3B68     		ldr	r3, [r7]
 1438 0804 1833     		adds	r3, r3, #24
 1439 0806 1846     		mov	r0, r3
 1440 0808 FFF7FEFF 		bl	uxListRemove
1609:../FreeRTOS/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 1441              		.loc 1 1609 0
 1442 080c 3B68     		ldr	r3, [r7]
 1443 080e 0433     		adds	r3, r3, #4
 1444 0810 1846     		mov	r0, r3
 1445 0812 FFF7FEFF 		bl	uxListRemove
1610:../FreeRTOS/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1446              		.loc 1 1610 0
 1447 0816 3B68     		ldr	r3, [r7]
 1448 0818 DA6A     		ldr	r2, [r3, #44]
 1449 081a 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1450 081e C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1451 0822 1B68     		ldr	r3, [r3]
 1452 0824 9A42     		cmp	r2, r3
 1453 0826 06D9     		bls	.L76
 1454              		.loc 1 1610 0 is_stmt 0 discriminator 1
 1455 0828 3B68     		ldr	r3, [r7]
 1456 082a DA6A     		ldr	r2, [r3, #44]
 1457 082c 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1458 0830 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1459 0834 1A60     		str	r2, [r3]
 1460              	.L76:
 1461              		.loc 1 1610 0 discriminator 2
 1462 0836 3B68     		ldr	r3, [r7]
 1463 0838 DA6A     		ldr	r2, [r3, #44]
 1464 083a 1346     		mov	r3, r2
 1465 083c 9B00     		lsls	r3, r3, #2
 1466 083e 1344     		add	r3, r3, r2
 1467 0840 9B00     		lsls	r3, r3, #2
 1468 0842 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 1469 0846 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 1470 084a 1A44     		add	r2, r2, r3
 1471 084c 3B68     		ldr	r3, [r7]
 1472 084e 0433     		adds	r3, r3, #4
 1473 0850 1046     		mov	r0, r2
 1474 0852 1946     		mov	r1, r3
 1475 0854 FFF7FEFF 		bl	vListInsertEnd
1611:../FreeRTOS/tasks.c **** 
1612:../FreeRTOS/tasks.c **** 					/* If we have moved a task that has a priority higher than
1613:../FreeRTOS/tasks.c **** 					the current task then we should yield. */
1614:../FreeRTOS/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1476              		.loc 1 1614 0 is_stmt 1 discriminator 2
 1477 0858 3B68     		ldr	r3, [r7]
 1478 085a DA6A     		ldr	r2, [r3, #44]
 1479 085c 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1480 0860 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1481 0864 1B68     		ldr	r3, [r3]
 1482 0866 DB6A     		ldr	r3, [r3, #44]
 1483 0868 9A42     		cmp	r2, r3
 1484 086a 05D3     		bcc	.L75
1615:../FreeRTOS/tasks.c **** 					{
1616:../FreeRTOS/tasks.c **** 						xYieldPending = pdTRUE;
 1485              		.loc 1 1616 0
 1486 086c 40F20003 		movw	r3, #:lower16:xYieldPending
 1487 0870 C0F20003 		movt	r3, #:upper16:xYieldPending
 1488 0874 0122     		movs	r2, #1
 1489 0876 1A60     		str	r2, [r3]
 1490              	.L75:
1605:../FreeRTOS/tasks.c **** 				{
 1491              		.loc 1 1605 0 discriminator 1
 1492 0878 40F20003 		movw	r3, #:lower16:xPendingReadyList
 1493 087c C0F20003 		movt	r3, #:upper16:xPendingReadyList
 1494 0880 1B68     		ldr	r3, [r3]
 1495 0882 002B     		cmp	r3, #0
 1496 0884 B6D1     		bne	.L77
1617:../FreeRTOS/tasks.c **** 					}
1618:../FreeRTOS/tasks.c **** 					else
1619:../FreeRTOS/tasks.c **** 					{
1620:../FreeRTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1621:../FreeRTOS/tasks.c **** 					}
1622:../FreeRTOS/tasks.c **** 				}
1623:../FreeRTOS/tasks.c **** 
1624:../FreeRTOS/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
1625:../FreeRTOS/tasks.c **** 				they should be processed now.  This ensures the tick count does
1626:../FreeRTOS/tasks.c **** 				not	slip, and that any delayed tasks are resumed at the correct
1627:../FreeRTOS/tasks.c **** 				time. */
1628:../FreeRTOS/tasks.c **** 				if( uxPendedTicks > ( UBaseType_t ) 0U )
 1497              		.loc 1 1628 0
 1498 0886 40F20003 		movw	r3, #:lower16:uxPendedTicks
 1499 088a C0F20003 		movt	r3, #:upper16:uxPendedTicks
 1500 088e 1B68     		ldr	r3, [r3]
 1501 0890 002B     		cmp	r3, #0
 1502 0892 1DD0     		beq	.L78
1629:../FreeRTOS/tasks.c **** 				{
1630:../FreeRTOS/tasks.c **** 					while( uxPendedTicks > ( UBaseType_t ) 0U )
 1503              		.loc 1 1630 0
 1504 0894 15E0     		b	.L79
 1505              	.L81:
1631:../FreeRTOS/tasks.c **** 					{
1632:../FreeRTOS/tasks.c **** 						if( xTaskIncrementTick() != pdFALSE )
 1506              		.loc 1 1632 0
 1507 0896 FFF7FEFF 		bl	xTaskIncrementTick
 1508 089a 0346     		mov	r3, r0
 1509 089c 002B     		cmp	r3, #0
 1510 089e 05D0     		beq	.L80
1633:../FreeRTOS/tasks.c **** 						{
1634:../FreeRTOS/tasks.c **** 							xYieldPending = pdTRUE;
 1511              		.loc 1 1634 0
 1512 08a0 40F20003 		movw	r3, #:lower16:xYieldPending
 1513 08a4 C0F20003 		movt	r3, #:upper16:xYieldPending
 1514 08a8 0122     		movs	r2, #1
 1515 08aa 1A60     		str	r2, [r3]
 1516              	.L80:
1635:../FreeRTOS/tasks.c **** 						}
1636:../FreeRTOS/tasks.c **** 						else
1637:../FreeRTOS/tasks.c **** 						{
1638:../FreeRTOS/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
1639:../FreeRTOS/tasks.c **** 						}
1640:../FreeRTOS/tasks.c **** 						--uxPendedTicks;
 1517              		.loc 1 1640 0
 1518 08ac 40F20003 		movw	r3, #:lower16:uxPendedTicks
 1519 08b0 C0F20003 		movt	r3, #:upper16:uxPendedTicks
 1520 08b4 1B68     		ldr	r3, [r3]
 1521 08b6 5A1E     		subs	r2, r3, #1
 1522 08b8 40F20003 		movw	r3, #:lower16:uxPendedTicks
 1523 08bc C0F20003 		movt	r3, #:upper16:uxPendedTicks
 1524 08c0 1A60     		str	r2, [r3]
 1525              	.L79:
1630:../FreeRTOS/tasks.c **** 					{
 1526              		.loc 1 1630 0 discriminator 1
 1527 08c2 40F20003 		movw	r3, #:lower16:uxPendedTicks
 1528 08c6 C0F20003 		movt	r3, #:upper16:uxPendedTicks
 1529 08ca 1B68     		ldr	r3, [r3]
 1530 08cc 002B     		cmp	r3, #0
 1531 08ce E2D1     		bne	.L81
 1532              	.L78:
1641:../FreeRTOS/tasks.c **** 					}
1642:../FreeRTOS/tasks.c **** 				}
1643:../FreeRTOS/tasks.c **** 				else
1644:../FreeRTOS/tasks.c **** 				{
1645:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1646:../FreeRTOS/tasks.c **** 				}
1647:../FreeRTOS/tasks.c **** 
1648:../FreeRTOS/tasks.c **** 				if( xYieldPending == pdTRUE )
 1533              		.loc 1 1648 0
 1534 08d0 40F20003 		movw	r3, #:lower16:xYieldPending
 1535 08d4 C0F20003 		movt	r3, #:upper16:xYieldPending
 1536 08d8 1B68     		ldr	r3, [r3]
 1537 08da 012B     		cmp	r3, #1
 1538 08dc 03D1     		bne	.L74
1649:../FreeRTOS/tasks.c **** 				{
1650:../FreeRTOS/tasks.c **** 					#if( configUSE_PREEMPTION != 0 )
1651:../FreeRTOS/tasks.c **** 					{
1652:../FreeRTOS/tasks.c **** 						xAlreadyYielded = pdTRUE;
 1539              		.loc 1 1652 0
 1540 08de 0123     		movs	r3, #1
 1541 08e0 7B60     		str	r3, [r7, #4]
1653:../FreeRTOS/tasks.c **** 					}
1654:../FreeRTOS/tasks.c **** 					#endif
1655:../FreeRTOS/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
 1542              		.loc 1 1655 0
 1543 08e2 FFF7FEFF 		bl	vPortYield
 1544              	.L74:
1656:../FreeRTOS/tasks.c **** 				}
1657:../FreeRTOS/tasks.c **** 				else
1658:../FreeRTOS/tasks.c **** 				{
1659:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1660:../FreeRTOS/tasks.c **** 				}
1661:../FreeRTOS/tasks.c **** 			}
1662:../FreeRTOS/tasks.c **** 		}
1663:../FreeRTOS/tasks.c **** 		else
1664:../FreeRTOS/tasks.c **** 		{
1665:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1666:../FreeRTOS/tasks.c **** 		}
1667:../FreeRTOS/tasks.c **** 	}
1668:../FreeRTOS/tasks.c **** 	taskEXIT_CRITICAL();
 1545              		.loc 1 1668 0
 1546 08e6 FFF7FEFF 		bl	vPortExitCritical
1669:../FreeRTOS/tasks.c **** 
1670:../FreeRTOS/tasks.c **** 	return xAlreadyYielded;
 1547              		.loc 1 1670 0
 1548 08ea 7B68     		ldr	r3, [r7, #4]
1671:../FreeRTOS/tasks.c **** }
 1549              		.loc 1 1671 0
 1550 08ec 1846     		mov	r0, r3
 1551 08ee 0837     		adds	r7, r7, #8
 1552 08f0 BD46     		mov	sp, r7
 1553              		@ sp needed
 1554 08f2 80BD     		pop	{r7, pc}
 1555              		.cfi_endproc
 1556              	.LFE13:
 1558              		.align	2
 1559              		.global	xTaskGetTickCount
 1560              		.thumb
 1561              		.thumb_func
 1563              	xTaskGetTickCount:
 1564              	.LFB14:
1672:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1673:../FreeRTOS/tasks.c **** 
1674:../FreeRTOS/tasks.c **** TickType_t xTaskGetTickCount( void )
1675:../FreeRTOS/tasks.c **** {
 1565              		.loc 1 1675 0
 1566              		.cfi_startproc
 1567              		@ args = 0, pretend = 0, frame = 8
 1568              		@ frame_needed = 1, uses_anonymous_args = 0
 1569 08f4 80B5     		push	{r7, lr}
 1570              		.cfi_def_cfa_offset 8
 1571              		.cfi_offset 7, -8
 1572              		.cfi_offset 14, -4
 1573 08f6 82B0     		sub	sp, sp, #8
 1574              		.cfi_def_cfa_offset 16
 1575 08f8 00AF     		add	r7, sp, #0
 1576              		.cfi_def_cfa_register 7
1676:../FreeRTOS/tasks.c **** TickType_t xTicks;
1677:../FreeRTOS/tasks.c **** 
1678:../FreeRTOS/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
1679:../FreeRTOS/tasks.c **** 	taskENTER_CRITICAL();
 1577              		.loc 1 1679 0
 1578 08fa FFF7FEFF 		bl	vPortEnterCritical
1680:../FreeRTOS/tasks.c **** 	{
1681:../FreeRTOS/tasks.c **** 		xTicks = xTickCount;
 1579              		.loc 1 1681 0
 1580 08fe 40F20003 		movw	r3, #:lower16:xTickCount
 1581 0902 C0F20003 		movt	r3, #:upper16:xTickCount
 1582 0906 1B68     		ldr	r3, [r3]
 1583 0908 7B60     		str	r3, [r7, #4]
1682:../FreeRTOS/tasks.c **** 	}
1683:../FreeRTOS/tasks.c **** 	taskEXIT_CRITICAL();
 1584              		.loc 1 1683 0
 1585 090a FFF7FEFF 		bl	vPortExitCritical
1684:../FreeRTOS/tasks.c **** 
1685:../FreeRTOS/tasks.c **** 	return xTicks;
 1586              		.loc 1 1685 0
 1587 090e 7B68     		ldr	r3, [r7, #4]
1686:../FreeRTOS/tasks.c **** }
 1588              		.loc 1 1686 0
 1589 0910 1846     		mov	r0, r3
 1590 0912 0837     		adds	r7, r7, #8
 1591 0914 BD46     		mov	sp, r7
 1592              		@ sp needed
 1593 0916 80BD     		pop	{r7, pc}
 1594              		.cfi_endproc
 1595              	.LFE14:
 1597              		.align	2
 1598              		.global	xTaskGetTickCountFromISR
 1599              		.thumb
 1600              		.thumb_func
 1602              	xTaskGetTickCountFromISR:
 1603              	.LFB15:
1687:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1688:../FreeRTOS/tasks.c **** 
1689:../FreeRTOS/tasks.c **** TickType_t xTaskGetTickCountFromISR( void )
1690:../FreeRTOS/tasks.c **** {
 1604              		.loc 1 1690 0
 1605              		.cfi_startproc
 1606              		@ args = 0, pretend = 0, frame = 8
 1607              		@ frame_needed = 1, uses_anonymous_args = 0
 1608 0918 80B5     		push	{r7, lr}
 1609              		.cfi_def_cfa_offset 8
 1610              		.cfi_offset 7, -8
 1611              		.cfi_offset 14, -4
 1612 091a 82B0     		sub	sp, sp, #8
 1613              		.cfi_def_cfa_offset 16
 1614 091c 00AF     		add	r7, sp, #0
 1615              		.cfi_def_cfa_register 7
1691:../FreeRTOS/tasks.c **** TickType_t xReturn;
1692:../FreeRTOS/tasks.c **** UBaseType_t uxSavedInterruptStatus;
1693:../FreeRTOS/tasks.c **** 
1694:../FreeRTOS/tasks.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1695:../FreeRTOS/tasks.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1696:../FreeRTOS/tasks.c **** 	above the maximum system call priority are kept permanently enabled, even
1697:../FreeRTOS/tasks.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1698:../FreeRTOS/tasks.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1699:../FreeRTOS/tasks.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1700:../FreeRTOS/tasks.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1701:../FreeRTOS/tasks.c **** 	assigned a priority above the configured maximum system call priority.
1702:../FreeRTOS/tasks.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1703:../FreeRTOS/tasks.c **** 	that have been assigned a priority at or (logically) below the maximum
1704:../FreeRTOS/tasks.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1705:../FreeRTOS/tasks.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1706:../FreeRTOS/tasks.c **** 	More information (albeit Cortex-M specific) is provided on the following
1707:../FreeRTOS/tasks.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1708:../FreeRTOS/tasks.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1709:../FreeRTOS/tasks.c **** 
1710:../FreeRTOS/tasks.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1616              		.loc 1 1710 0
 1617 091e FFF7FEFF 		bl	ulPortSetInterruptMask
 1618 0922 7860     		str	r0, [r7, #4]
1711:../FreeRTOS/tasks.c **** 	{
1712:../FreeRTOS/tasks.c **** 		xReturn = xTickCount;
 1619              		.loc 1 1712 0
 1620 0924 40F20003 		movw	r3, #:lower16:xTickCount
 1621 0928 C0F20003 		movt	r3, #:upper16:xTickCount
 1622 092c 1B68     		ldr	r3, [r3]
 1623 092e 3B60     		str	r3, [r7]
1713:../FreeRTOS/tasks.c **** 	}
1714:../FreeRTOS/tasks.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1624              		.loc 1 1714 0
 1625 0930 7868     		ldr	r0, [r7, #4]
 1626 0932 FFF7FEFF 		bl	vPortClearInterruptMask
1715:../FreeRTOS/tasks.c **** 
1716:../FreeRTOS/tasks.c **** 	return xReturn;
 1627              		.loc 1 1716 0
 1628 0936 3B68     		ldr	r3, [r7]
1717:../FreeRTOS/tasks.c **** }
 1629              		.loc 1 1717 0
 1630 0938 1846     		mov	r0, r3
 1631 093a 0837     		adds	r7, r7, #8
 1632 093c BD46     		mov	sp, r7
 1633              		@ sp needed
 1634 093e 80BD     		pop	{r7, pc}
 1635              		.cfi_endproc
 1636              	.LFE15:
 1638              		.align	2
 1639              		.global	uxTaskGetNumberOfTasks
 1640              		.thumb
 1641              		.thumb_func
 1643              	uxTaskGetNumberOfTasks:
 1644              	.LFB16:
1718:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1719:../FreeRTOS/tasks.c **** 
1720:../FreeRTOS/tasks.c **** UBaseType_t uxTaskGetNumberOfTasks( void )
1721:../FreeRTOS/tasks.c **** {
 1645              		.loc 1 1721 0
 1646              		.cfi_startproc
 1647              		@ args = 0, pretend = 0, frame = 0
 1648              		@ frame_needed = 1, uses_anonymous_args = 0
 1649              		@ link register save eliminated.
 1650 0940 80B4     		push	{r7}
 1651              		.cfi_def_cfa_offset 4
 1652              		.cfi_offset 7, -4
 1653 0942 00AF     		add	r7, sp, #0
 1654              		.cfi_def_cfa_register 7
1722:../FreeRTOS/tasks.c **** 	/* A critical section is not required because the variables are of type
1723:../FreeRTOS/tasks.c **** 	BaseType_t. */
1724:../FreeRTOS/tasks.c **** 	return uxCurrentNumberOfTasks;
 1655              		.loc 1 1724 0
 1656 0944 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 1657 0948 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 1658 094c 1B68     		ldr	r3, [r3]
1725:../FreeRTOS/tasks.c **** }
 1659              		.loc 1 1725 0
 1660 094e 1846     		mov	r0, r3
 1661 0950 BD46     		mov	sp, r7
 1662              		@ sp needed
 1663 0952 5DF8047B 		ldr	r7, [sp], #4
 1664 0956 7047     		bx	lr
 1665              		.cfi_endproc
 1666              	.LFE16:
 1668              		.align	2
 1669              		.global	xTaskIncrementTick
 1670              		.thumb
 1671              		.thumb_func
 1673              	xTaskIncrementTick:
 1674              	.LFB17:
1726:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1727:../FreeRTOS/tasks.c **** 
1728:../FreeRTOS/tasks.c **** #if ( INCLUDE_pcTaskGetTaskName == 1 )
1729:../FreeRTOS/tasks.c **** 
1730:../FreeRTOS/tasks.c **** 	char *pcTaskGetTaskName( TaskHandle_t xTaskToQuery )
1731:../FreeRTOS/tasks.c **** 	{
1732:../FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
1733:../FreeRTOS/tasks.c **** 
1734:../FreeRTOS/tasks.c **** 		/* If null is passed in here then the name of the calling task is being queried. */
1735:../FreeRTOS/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
1736:../FreeRTOS/tasks.c **** 		configASSERT( pxTCB );
1737:../FreeRTOS/tasks.c **** 		return &( pxTCB->pcTaskName[ 0 ] );
1738:../FreeRTOS/tasks.c **** 	}
1739:../FreeRTOS/tasks.c **** 
1740:../FreeRTOS/tasks.c **** #endif /* INCLUDE_pcTaskGetTaskName */
1741:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1742:../FreeRTOS/tasks.c **** 
1743:../FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1744:../FreeRTOS/tasks.c **** 
1745:../FreeRTOS/tasks.c **** 	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArra
1746:../FreeRTOS/tasks.c **** 	{
1747:../FreeRTOS/tasks.c **** 	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
1748:../FreeRTOS/tasks.c **** 
1749:../FreeRTOS/tasks.c **** 		vTaskSuspendAll();
1750:../FreeRTOS/tasks.c **** 		{
1751:../FreeRTOS/tasks.c **** 			/* Is there a space in the array for each task in the system? */
1752:../FreeRTOS/tasks.c **** 			if( uxArraySize >= uxCurrentNumberOfTasks )
1753:../FreeRTOS/tasks.c **** 			{
1754:../FreeRTOS/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
1755:../FreeRTOS/tasks.c **** 				task in the Ready state. */
1756:../FreeRTOS/tasks.c **** 				do
1757:../FreeRTOS/tasks.c **** 				{
1758:../FreeRTOS/tasks.c **** 					uxQueue--;
1759:../FreeRTOS/tasks.c **** 					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[
1760:../FreeRTOS/tasks.c **** 
1761:../FreeRTOS/tasks.c **** 				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the cast
1762:../FreeRTOS/tasks.c **** 
1763:../FreeRTOS/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
1764:../FreeRTOS/tasks.c **** 				task in the Blocked state. */
1765:../FreeRTOS/tasks.c **** 				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayed
1766:../FreeRTOS/tasks.c **** 				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflo
1767:../FreeRTOS/tasks.c **** 
1768:../FreeRTOS/tasks.c **** 				#if( INCLUDE_vTaskDelete == 1 )
1769:../FreeRTOS/tasks.c **** 				{
1770:../FreeRTOS/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
1771:../FreeRTOS/tasks.c **** 					each task that has been deleted but not yet cleaned up. */
1772:../FreeRTOS/tasks.c **** 					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermina
1773:../FreeRTOS/tasks.c **** 				}
1774:../FreeRTOS/tasks.c **** 				#endif
1775:../FreeRTOS/tasks.c **** 
1776:../FreeRTOS/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
1777:../FreeRTOS/tasks.c **** 				{
1778:../FreeRTOS/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
1779:../FreeRTOS/tasks.c **** 					each task in the Suspended state. */
1780:../FreeRTOS/tasks.c **** 					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, 
1781:../FreeRTOS/tasks.c **** 				}
1782:../FreeRTOS/tasks.c **** 				#endif
1783:../FreeRTOS/tasks.c **** 
1784:../FreeRTOS/tasks.c **** 				#if ( configGENERATE_RUN_TIME_STATS == 1)
1785:../FreeRTOS/tasks.c **** 				{
1786:../FreeRTOS/tasks.c **** 					if( pulTotalRunTime != NULL )
1787:../FreeRTOS/tasks.c **** 					{
1788:../FreeRTOS/tasks.c **** 						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1789:../FreeRTOS/tasks.c **** 							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
1790:../FreeRTOS/tasks.c **** 						#else
1791:../FreeRTOS/tasks.c **** 							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1792:../FreeRTOS/tasks.c **** 						#endif
1793:../FreeRTOS/tasks.c **** 					}
1794:../FreeRTOS/tasks.c **** 				}
1795:../FreeRTOS/tasks.c **** 				#else
1796:../FreeRTOS/tasks.c **** 				{
1797:../FreeRTOS/tasks.c **** 					if( pulTotalRunTime != NULL )
1798:../FreeRTOS/tasks.c **** 					{
1799:../FreeRTOS/tasks.c **** 						*pulTotalRunTime = 0;
1800:../FreeRTOS/tasks.c **** 					}
1801:../FreeRTOS/tasks.c **** 				}
1802:../FreeRTOS/tasks.c **** 				#endif
1803:../FreeRTOS/tasks.c **** 			}
1804:../FreeRTOS/tasks.c **** 			else
1805:../FreeRTOS/tasks.c **** 			{
1806:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1807:../FreeRTOS/tasks.c **** 			}
1808:../FreeRTOS/tasks.c **** 		}
1809:../FreeRTOS/tasks.c **** 		( void ) xTaskResumeAll();
1810:../FreeRTOS/tasks.c **** 
1811:../FreeRTOS/tasks.c **** 		return uxTask;
1812:../FreeRTOS/tasks.c **** 	}
1813:../FreeRTOS/tasks.c **** 
1814:../FreeRTOS/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
1815:../FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
1816:../FreeRTOS/tasks.c **** 
1817:../FreeRTOS/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1818:../FreeRTOS/tasks.c **** 
1819:../FreeRTOS/tasks.c **** 	TaskHandle_t xTaskGetIdleTaskHandle( void )
1820:../FreeRTOS/tasks.c **** 	{
1821:../FreeRTOS/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
1822:../FreeRTOS/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
1823:../FreeRTOS/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
1824:../FreeRTOS/tasks.c **** 		return xIdleTaskHandle;
1825:../FreeRTOS/tasks.c **** 	}
1826:../FreeRTOS/tasks.c **** 
1827:../FreeRTOS/tasks.c **** #endif /* INCLUDE_xTaskGetIdleTaskHandle */
1828:../FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
1829:../FreeRTOS/tasks.c **** 
1830:../FreeRTOS/tasks.c **** /* This conditional compilation should use inequality to 0, not equality to 1.
1831:../FreeRTOS/tasks.c **** This is to ensure vTaskStepTick() is available when user defined low power mode
1832:../FreeRTOS/tasks.c **** implementations require configUSE_TICKLESS_IDLE to be set to a value other than
1833:../FreeRTOS/tasks.c **** 1. */
1834:../FreeRTOS/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
1835:../FreeRTOS/tasks.c **** 
1836:../FreeRTOS/tasks.c **** 	void vTaskStepTick( const TickType_t xTicksToJump )
1837:../FreeRTOS/tasks.c **** 	{
1838:../FreeRTOS/tasks.c **** 		/* Correct the tick count value after a period during which the tick
1839:../FreeRTOS/tasks.c **** 		was suppressed.  Note this does *not* call the tick hook function for
1840:../FreeRTOS/tasks.c **** 		each stepped tick. */
1841:../FreeRTOS/tasks.c **** 		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
1842:../FreeRTOS/tasks.c **** 		xTickCount += xTicksToJump;
1843:../FreeRTOS/tasks.c **** 		traceINCREASE_TICK_COUNT( xTicksToJump );
1844:../FreeRTOS/tasks.c **** 	}
1845:../FreeRTOS/tasks.c **** 
1846:../FreeRTOS/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
1847:../FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
1848:../FreeRTOS/tasks.c **** 
1849:../FreeRTOS/tasks.c **** BaseType_t xTaskIncrementTick( void )
1850:../FreeRTOS/tasks.c **** {
 1675              		.loc 1 1850 0
 1676              		.cfi_startproc
 1677              		@ args = 0, pretend = 0, frame = 24
 1678              		@ frame_needed = 1, uses_anonymous_args = 0
 1679 0958 80B5     		push	{r7, lr}
 1680              		.cfi_def_cfa_offset 8
 1681              		.cfi_offset 7, -8
 1682              		.cfi_offset 14, -4
 1683 095a 86B0     		sub	sp, sp, #24
 1684              		.cfi_def_cfa_offset 32
 1685 095c 00AF     		add	r7, sp, #0
 1686              		.cfi_def_cfa_register 7
1851:../FreeRTOS/tasks.c **** TCB_t * pxTCB;
1852:../FreeRTOS/tasks.c **** TickType_t xItemValue;
1853:../FreeRTOS/tasks.c **** BaseType_t xSwitchRequired = pdFALSE;
 1687              		.loc 1 1853 0
 1688 095e 0023     		movs	r3, #0
 1689 0960 7B61     		str	r3, [r7, #20]
1854:../FreeRTOS/tasks.c **** 
1855:../FreeRTOS/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
1856:../FreeRTOS/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
1857:../FreeRTOS/tasks.c **** 	tasks to be unblocked. */
1858:../FreeRTOS/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
1859:../FreeRTOS/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 1690              		.loc 1 1859 0
 1691 0962 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1692 0966 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1693 096a 1B68     		ldr	r3, [r3]
 1694 096c 002B     		cmp	r3, #0
 1695 096e 40F0BB80 		bne	.L90
1860:../FreeRTOS/tasks.c **** 	{
1861:../FreeRTOS/tasks.c **** 		/* Increment the RTOS tick, switching the delayed and overflowed
1862:../FreeRTOS/tasks.c **** 		delayed lists if it wraps to 0. */
1863:../FreeRTOS/tasks.c **** 		++xTickCount;
 1696              		.loc 1 1863 0
 1697 0972 40F20003 		movw	r3, #:lower16:xTickCount
 1698 0976 C0F20003 		movt	r3, #:upper16:xTickCount
 1699 097a 1B68     		ldr	r3, [r3]
 1700 097c 5A1C     		adds	r2, r3, #1
 1701 097e 40F20003 		movw	r3, #:lower16:xTickCount
 1702 0982 C0F20003 		movt	r3, #:upper16:xTickCount
 1703 0986 1A60     		str	r2, [r3]
 1704              	.LBB4:
1864:../FreeRTOS/tasks.c **** 
1865:../FreeRTOS/tasks.c **** 		{
1866:../FreeRTOS/tasks.c **** 			/* Minor optimisation.  The tick count cannot change in this
1867:../FreeRTOS/tasks.c **** 			block. */
1868:../FreeRTOS/tasks.c **** 			const TickType_t xConstTickCount = xTickCount;
 1705              		.loc 1 1868 0
 1706 0988 40F20003 		movw	r3, #:lower16:xTickCount
 1707 098c C0F20003 		movt	r3, #:upper16:xTickCount
 1708 0990 1B68     		ldr	r3, [r3]
 1709 0992 3B61     		str	r3, [r7, #16]
1869:../FreeRTOS/tasks.c **** 
1870:../FreeRTOS/tasks.c **** 			if( xConstTickCount == ( TickType_t ) 0U )
 1710              		.loc 1 1870 0
 1711 0994 3B69     		ldr	r3, [r7, #16]
 1712 0996 002B     		cmp	r3, #0
 1713 0998 22D1     		bne	.L91
 1714              	.LBB5:
1871:../FreeRTOS/tasks.c **** 			{
1872:../FreeRTOS/tasks.c **** 				taskSWITCH_DELAYED_LISTS();
 1715              		.loc 1 1872 0
 1716 099a 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 1717 099e C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 1718 09a2 1B68     		ldr	r3, [r3]
 1719 09a4 FB60     		str	r3, [r7, #12]
 1720 09a6 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 1721 09aa C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 1722 09ae 1A68     		ldr	r2, [r3]
 1723 09b0 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 1724 09b4 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 1725 09b8 1A60     		str	r2, [r3]
 1726 09ba 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 1727 09be C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 1728 09c2 FA68     		ldr	r2, [r7, #12]
 1729 09c4 1A60     		str	r2, [r3]
 1730 09c6 40F20003 		movw	r3, #:lower16:xNumOfOverflows
 1731 09ca C0F20003 		movt	r3, #:upper16:xNumOfOverflows
 1732 09ce 1B68     		ldr	r3, [r3]
 1733 09d0 5A1C     		adds	r2, r3, #1
 1734 09d2 40F20003 		movw	r3, #:lower16:xNumOfOverflows
 1735 09d6 C0F20003 		movt	r3, #:upper16:xNumOfOverflows
 1736 09da 1A60     		str	r2, [r3]
 1737 09dc 00F078FC 		bl	prvResetNextTaskUnblockTime
 1738              	.L91:
 1739              	.LBE5:
1873:../FreeRTOS/tasks.c **** 			}
1874:../FreeRTOS/tasks.c **** 			else
1875:../FreeRTOS/tasks.c **** 			{
1876:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1877:../FreeRTOS/tasks.c **** 			}
1878:../FreeRTOS/tasks.c **** 
1879:../FreeRTOS/tasks.c **** 			/* See if this tick has made a timeout expire.  Tasks are stored in
1880:../FreeRTOS/tasks.c **** 			the	queue in the order of their wake time - meaning once one task
1881:../FreeRTOS/tasks.c **** 			has been found whose block time has not expired there is no need to
1882:../FreeRTOS/tasks.c **** 			look any further	down the list. */
1883:../FreeRTOS/tasks.c **** 			if( xConstTickCount >= xNextTaskUnblockTime )
 1740              		.loc 1 1883 0
 1741 09e0 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 1742 09e4 C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 1743 09e8 1B68     		ldr	r3, [r3]
 1744 09ea 3A69     		ldr	r2, [r7, #16]
 1745 09ec 9A42     		cmp	r2, r3
 1746 09ee 66D3     		bcc	.L92
 1747              	.L100:
1884:../FreeRTOS/tasks.c **** 			{
1885:../FreeRTOS/tasks.c **** 				for( ;; )
1886:../FreeRTOS/tasks.c **** 				{
1887:../FreeRTOS/tasks.c **** 					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 1748              		.loc 1 1887 0
 1749 09f0 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 1750 09f4 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 1751 09f8 1B68     		ldr	r3, [r3]
 1752 09fa 1B68     		ldr	r3, [r3]
 1753 09fc 002B     		cmp	r3, #0
 1754 09fe 01D1     		bne	.L93
 1755              		.loc 1 1887 0 is_stmt 0 discriminator 1
 1756 0a00 0123     		movs	r3, #1
 1757 0a02 00E0     		b	.L94
 1758              	.L93:
 1759              		.loc 1 1887 0 discriminator 2
 1760 0a04 0023     		movs	r3, #0
 1761              	.L94:
 1762              		.loc 1 1887 0 discriminator 3
 1763 0a06 002B     		cmp	r3, #0
 1764 0a08 07D0     		beq	.L95
1888:../FreeRTOS/tasks.c **** 					{
1889:../FreeRTOS/tasks.c **** 						/* The delayed list is empty.  Set xNextTaskUnblockTime
1890:../FreeRTOS/tasks.c **** 						to the maximum possible value so it is extremely
1891:../FreeRTOS/tasks.c **** 						unlikely that the
1892:../FreeRTOS/tasks.c **** 						if( xTickCount >= xNextTaskUnblockTime ) test will pass
1893:../FreeRTOS/tasks.c **** 						next time through. */
1894:../FreeRTOS/tasks.c **** 						xNextTaskUnblockTime = portMAX_DELAY;
 1765              		.loc 1 1894 0 is_stmt 1
 1766 0a0a 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 1767 0a0e C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 1768 0a12 4FF0FF32 		mov	r2, #-1
 1769 0a16 1A60     		str	r2, [r3]
1895:../FreeRTOS/tasks.c **** 						break;
 1770              		.loc 1 1895 0
 1771 0a18 51E0     		b	.L92
 1772              	.L95:
1896:../FreeRTOS/tasks.c **** 					}
1897:../FreeRTOS/tasks.c **** 					else
1898:../FreeRTOS/tasks.c **** 					{
1899:../FreeRTOS/tasks.c **** 						/* The delayed list is not empty, get the value of the
1900:../FreeRTOS/tasks.c **** 						item at the head of the delayed list.  This is the time
1901:../FreeRTOS/tasks.c **** 						at which the task at the head of the delayed list must
1902:../FreeRTOS/tasks.c **** 						be removed from the Blocked state. */
1903:../FreeRTOS/tasks.c **** 						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 1773              		.loc 1 1903 0
 1774 0a1a 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 1775 0a1e C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 1776 0a22 1B68     		ldr	r3, [r3]
 1777 0a24 DB68     		ldr	r3, [r3, #12]
 1778 0a26 DB68     		ldr	r3, [r3, #12]
 1779 0a28 BB60     		str	r3, [r7, #8]
1904:../FreeRTOS/tasks.c **** 						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 1780              		.loc 1 1904 0
 1781 0a2a BB68     		ldr	r3, [r7, #8]
 1782 0a2c 5B68     		ldr	r3, [r3, #4]
 1783 0a2e 7B60     		str	r3, [r7, #4]
1905:../FreeRTOS/tasks.c **** 
1906:../FreeRTOS/tasks.c **** 						if( xConstTickCount < xItemValue )
 1784              		.loc 1 1906 0
 1785 0a30 3A69     		ldr	r2, [r7, #16]
 1786 0a32 7B68     		ldr	r3, [r7, #4]
 1787 0a34 9A42     		cmp	r2, r3
 1788 0a36 06D2     		bcs	.L96
1907:../FreeRTOS/tasks.c **** 						{
1908:../FreeRTOS/tasks.c **** 							/* It is not time to unblock this item yet, but the
1909:../FreeRTOS/tasks.c **** 							item value is the time at which the task at the head
1910:../FreeRTOS/tasks.c **** 							of the blocked list must be removed from the Blocked
1911:../FreeRTOS/tasks.c **** 							state -	so record the item value in
1912:../FreeRTOS/tasks.c **** 							xNextTaskUnblockTime. */
1913:../FreeRTOS/tasks.c **** 							xNextTaskUnblockTime = xItemValue;
 1789              		.loc 1 1913 0
 1790 0a38 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 1791 0a3c C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 1792 0a40 7A68     		ldr	r2, [r7, #4]
 1793 0a42 1A60     		str	r2, [r3]
1914:../FreeRTOS/tasks.c **** 							break;
 1794              		.loc 1 1914 0
 1795 0a44 3BE0     		b	.L92
 1796              	.L96:
1915:../FreeRTOS/tasks.c **** 						}
1916:../FreeRTOS/tasks.c **** 						else
1917:../FreeRTOS/tasks.c **** 						{
1918:../FreeRTOS/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
1919:../FreeRTOS/tasks.c **** 						}
1920:../FreeRTOS/tasks.c **** 
1921:../FreeRTOS/tasks.c **** 						/* It is time to remove the item from the Blocked state. */
1922:../FreeRTOS/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 1797              		.loc 1 1922 0
 1798 0a46 BB68     		ldr	r3, [r7, #8]
 1799 0a48 0433     		adds	r3, r3, #4
 1800 0a4a 1846     		mov	r0, r3
 1801 0a4c FFF7FEFF 		bl	uxListRemove
1923:../FreeRTOS/tasks.c **** 
1924:../FreeRTOS/tasks.c **** 						/* Is the task waiting on an event also?  If so remove
1925:../FreeRTOS/tasks.c **** 						it from the event list. */
1926:../FreeRTOS/tasks.c **** 						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 1802              		.loc 1 1926 0
 1803 0a50 BB68     		ldr	r3, [r7, #8]
 1804 0a52 9B6A     		ldr	r3, [r3, #40]
 1805 0a54 002B     		cmp	r3, #0
 1806 0a56 04D0     		beq	.L97
1927:../FreeRTOS/tasks.c **** 						{
1928:../FreeRTOS/tasks.c **** 							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1807              		.loc 1 1928 0
 1808 0a58 BB68     		ldr	r3, [r7, #8]
 1809 0a5a 1833     		adds	r3, r3, #24
 1810 0a5c 1846     		mov	r0, r3
 1811 0a5e FFF7FEFF 		bl	uxListRemove
 1812              	.L97:
1929:../FreeRTOS/tasks.c **** 						}
1930:../FreeRTOS/tasks.c **** 						else
1931:../FreeRTOS/tasks.c **** 						{
1932:../FreeRTOS/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
1933:../FreeRTOS/tasks.c **** 						}
1934:../FreeRTOS/tasks.c **** 
1935:../FreeRTOS/tasks.c **** 						/* Place the unblocked task into the appropriate ready
1936:../FreeRTOS/tasks.c **** 						list. */
1937:../FreeRTOS/tasks.c **** 						prvAddTaskToReadyList( pxTCB );
 1813              		.loc 1 1937 0
 1814 0a62 BB68     		ldr	r3, [r7, #8]
 1815 0a64 DA6A     		ldr	r2, [r3, #44]
 1816 0a66 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1817 0a6a C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1818 0a6e 1B68     		ldr	r3, [r3]
 1819 0a70 9A42     		cmp	r2, r3
 1820 0a72 06D9     		bls	.L98
 1821              		.loc 1 1937 0 is_stmt 0 discriminator 1
 1822 0a74 BB68     		ldr	r3, [r7, #8]
 1823 0a76 DA6A     		ldr	r2, [r3, #44]
 1824 0a78 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1825 0a7c C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1826 0a80 1A60     		str	r2, [r3]
 1827              	.L98:
 1828              		.loc 1 1937 0 discriminator 2
 1829 0a82 BB68     		ldr	r3, [r7, #8]
 1830 0a84 DA6A     		ldr	r2, [r3, #44]
 1831 0a86 1346     		mov	r3, r2
 1832 0a88 9B00     		lsls	r3, r3, #2
 1833 0a8a 1344     		add	r3, r3, r2
 1834 0a8c 9B00     		lsls	r3, r3, #2
 1835 0a8e 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 1836 0a92 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 1837 0a96 1A44     		add	r2, r2, r3
 1838 0a98 BB68     		ldr	r3, [r7, #8]
 1839 0a9a 0433     		adds	r3, r3, #4
 1840 0a9c 1046     		mov	r0, r2
 1841 0a9e 1946     		mov	r1, r3
 1842 0aa0 FFF7FEFF 		bl	vListInsertEnd
1938:../FreeRTOS/tasks.c **** 
1939:../FreeRTOS/tasks.c **** 						/* A task being unblocked cannot cause an immediate
1940:../FreeRTOS/tasks.c **** 						context switch if preemption is turned off. */
1941:../FreeRTOS/tasks.c **** 						#if (  configUSE_PREEMPTION == 1 )
1942:../FreeRTOS/tasks.c **** 						{
1943:../FreeRTOS/tasks.c **** 							/* Preemption is on, but a context switch should
1944:../FreeRTOS/tasks.c **** 							only be performed if the unblocked task has a
1945:../FreeRTOS/tasks.c **** 							priority that is equal to or higher than the
1946:../FreeRTOS/tasks.c **** 							currently executing task. */
1947:../FreeRTOS/tasks.c **** 							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1843              		.loc 1 1947 0 is_stmt 1 discriminator 2
 1844 0aa4 BB68     		ldr	r3, [r7, #8]
 1845 0aa6 DA6A     		ldr	r2, [r3, #44]
 1846 0aa8 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1847 0aac C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1848 0ab0 1B68     		ldr	r3, [r3]
 1849 0ab2 DB6A     		ldr	r3, [r3, #44]
 1850 0ab4 9A42     		cmp	r2, r3
 1851 0ab6 01D3     		bcc	.L99
1948:../FreeRTOS/tasks.c **** 							{
1949:../FreeRTOS/tasks.c **** 								xSwitchRequired = pdTRUE;
 1852              		.loc 1 1949 0
 1853 0ab8 0123     		movs	r3, #1
 1854 0aba 7B61     		str	r3, [r7, #20]
 1855              	.L99:
1950:../FreeRTOS/tasks.c **** 							}
1951:../FreeRTOS/tasks.c **** 							else
1952:../FreeRTOS/tasks.c **** 							{
1953:../FreeRTOS/tasks.c **** 								mtCOVERAGE_TEST_MARKER();
1954:../FreeRTOS/tasks.c **** 							}
1955:../FreeRTOS/tasks.c **** 						}
1956:../FreeRTOS/tasks.c **** 						#endif /* configUSE_PREEMPTION */
1957:../FreeRTOS/tasks.c **** 					}
1958:../FreeRTOS/tasks.c **** 				}
 1856              		.loc 1 1958 0
 1857 0abc 98E7     		b	.L100
 1858              	.L92:
 1859              	.LBE4:
1959:../FreeRTOS/tasks.c **** 			}
1960:../FreeRTOS/tasks.c **** 		}
1961:../FreeRTOS/tasks.c **** 
1962:../FreeRTOS/tasks.c **** 		/* Tasks of equal priority to the currently running task will share
1963:../FreeRTOS/tasks.c **** 		processing time (time slice) if preemption is on, and the application
1964:../FreeRTOS/tasks.c **** 		writer has not explicitly turned time slicing off. */
1965:../FreeRTOS/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
1966:../FreeRTOS/tasks.c **** 		{
1967:../FreeRTOS/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_
 1860              		.loc 1 1967 0
 1861 0abe 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1862 0ac2 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1863 0ac6 1B68     		ldr	r3, [r3]
 1864 0ac8 D96A     		ldr	r1, [r3, #44]
 1865 0aca 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 1866 0ace C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 1867 0ad2 0B46     		mov	r3, r1
 1868 0ad4 9B00     		lsls	r3, r3, #2
 1869 0ad6 0B44     		add	r3, r3, r1
 1870 0ad8 9B00     		lsls	r3, r3, #2
 1871 0ada 1344     		add	r3, r3, r2
 1872 0adc 1B68     		ldr	r3, [r3]
 1873 0ade 012B     		cmp	r3, #1
 1874 0ae0 0DD9     		bls	.L101
1968:../FreeRTOS/tasks.c **** 			{
1969:../FreeRTOS/tasks.c **** 				xSwitchRequired = pdTRUE;
 1875              		.loc 1 1969 0
 1876 0ae2 0123     		movs	r3, #1
 1877 0ae4 7B61     		str	r3, [r7, #20]
 1878 0ae6 0AE0     		b	.L101
 1879              	.L90:
1970:../FreeRTOS/tasks.c **** 			}
1971:../FreeRTOS/tasks.c **** 			else
1972:../FreeRTOS/tasks.c **** 			{
1973:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1974:../FreeRTOS/tasks.c **** 			}
1975:../FreeRTOS/tasks.c **** 		}
1976:../FreeRTOS/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
1977:../FreeRTOS/tasks.c **** 
1978:../FreeRTOS/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
1979:../FreeRTOS/tasks.c **** 		{
1980:../FreeRTOS/tasks.c **** 			/* Guard against the tick hook being called when the pended tick
1981:../FreeRTOS/tasks.c **** 			count is being unwound (when the scheduler is being unlocked). */
1982:../FreeRTOS/tasks.c **** 			if( uxPendedTicks == ( UBaseType_t ) 0U )
1983:../FreeRTOS/tasks.c **** 			{
1984:../FreeRTOS/tasks.c **** 				vApplicationTickHook();
1985:../FreeRTOS/tasks.c **** 			}
1986:../FreeRTOS/tasks.c **** 			else
1987:../FreeRTOS/tasks.c **** 			{
1988:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1989:../FreeRTOS/tasks.c **** 			}
1990:../FreeRTOS/tasks.c **** 		}
1991:../FreeRTOS/tasks.c **** 		#endif /* configUSE_TICK_HOOK */
1992:../FreeRTOS/tasks.c **** 	}
1993:../FreeRTOS/tasks.c **** 	else
1994:../FreeRTOS/tasks.c **** 	{
1995:../FreeRTOS/tasks.c **** 		++uxPendedTicks;
 1880              		.loc 1 1995 0
 1881 0ae8 40F20003 		movw	r3, #:lower16:uxPendedTicks
 1882 0aec C0F20003 		movt	r3, #:upper16:uxPendedTicks
 1883 0af0 1B68     		ldr	r3, [r3]
 1884 0af2 5A1C     		adds	r2, r3, #1
 1885 0af4 40F20003 		movw	r3, #:lower16:uxPendedTicks
 1886 0af8 C0F20003 		movt	r3, #:upper16:uxPendedTicks
 1887 0afc 1A60     		str	r2, [r3]
 1888              	.L101:
1996:../FreeRTOS/tasks.c **** 
1997:../FreeRTOS/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
1998:../FreeRTOS/tasks.c **** 		scheduler is locked. */
1999:../FreeRTOS/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
2000:../FreeRTOS/tasks.c **** 		{
2001:../FreeRTOS/tasks.c **** 			vApplicationTickHook();
2002:../FreeRTOS/tasks.c **** 		}
2003:../FreeRTOS/tasks.c **** 		#endif
2004:../FreeRTOS/tasks.c **** 	}
2005:../FreeRTOS/tasks.c **** 
2006:../FreeRTOS/tasks.c **** 	#if ( configUSE_PREEMPTION == 1 )
2007:../FreeRTOS/tasks.c **** 	{
2008:../FreeRTOS/tasks.c **** 		if( xYieldPending != pdFALSE )
 1889              		.loc 1 2008 0
 1890 0afe 40F20003 		movw	r3, #:lower16:xYieldPending
 1891 0b02 C0F20003 		movt	r3, #:upper16:xYieldPending
 1892 0b06 1B68     		ldr	r3, [r3]
 1893 0b08 002B     		cmp	r3, #0
 1894 0b0a 01D0     		beq	.L102
2009:../FreeRTOS/tasks.c **** 		{
2010:../FreeRTOS/tasks.c **** 			xSwitchRequired = pdTRUE;
 1895              		.loc 1 2010 0
 1896 0b0c 0123     		movs	r3, #1
 1897 0b0e 7B61     		str	r3, [r7, #20]
 1898              	.L102:
2011:../FreeRTOS/tasks.c **** 		}
2012:../FreeRTOS/tasks.c **** 		else
2013:../FreeRTOS/tasks.c **** 		{
2014:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2015:../FreeRTOS/tasks.c **** 		}
2016:../FreeRTOS/tasks.c **** 	}
2017:../FreeRTOS/tasks.c **** 	#endif /* configUSE_PREEMPTION */
2018:../FreeRTOS/tasks.c **** 
2019:../FreeRTOS/tasks.c **** 	return xSwitchRequired;
 1899              		.loc 1 2019 0
 1900 0b10 7B69     		ldr	r3, [r7, #20]
2020:../FreeRTOS/tasks.c **** }
 1901              		.loc 1 2020 0
 1902 0b12 1846     		mov	r0, r3
 1903 0b14 1837     		adds	r7, r7, #24
 1904 0b16 BD46     		mov	sp, r7
 1905              		@ sp needed
 1906 0b18 80BD     		pop	{r7, pc}
 1907              		.cfi_endproc
 1908              	.LFE17:
 1910 0b1a 00BF     		.align	2
 1911              		.global	vTaskSwitchContext
 1912              		.thumb
 1913              		.thumb_func
 1915              	vTaskSwitchContext:
 1916              	.LFB18:
2021:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2022:../FreeRTOS/tasks.c **** 
2023:../FreeRTOS/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2024:../FreeRTOS/tasks.c **** 
2025:../FreeRTOS/tasks.c **** 	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
2026:../FreeRTOS/tasks.c **** 	{
2027:../FreeRTOS/tasks.c **** 	TCB_t *xTCB;
2028:../FreeRTOS/tasks.c **** 
2029:../FreeRTOS/tasks.c **** 		/* If xTask is NULL then it is the task hook of the calling task that is
2030:../FreeRTOS/tasks.c **** 		getting set. */
2031:../FreeRTOS/tasks.c **** 		if( xTask == NULL )
2032:../FreeRTOS/tasks.c **** 		{
2033:../FreeRTOS/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2034:../FreeRTOS/tasks.c **** 		}
2035:../FreeRTOS/tasks.c **** 		else
2036:../FreeRTOS/tasks.c **** 		{
2037:../FreeRTOS/tasks.c **** 			xTCB = ( TCB_t * ) xTask;
2038:../FreeRTOS/tasks.c **** 		}
2039:../FreeRTOS/tasks.c **** 
2040:../FreeRTOS/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2041:../FreeRTOS/tasks.c **** 		the value can be accessed from an interrupt. */
2042:../FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
2043:../FreeRTOS/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
2044:../FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
2045:../FreeRTOS/tasks.c **** 	}
2046:../FreeRTOS/tasks.c **** 
2047:../FreeRTOS/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2048:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2049:../FreeRTOS/tasks.c **** 
2050:../FreeRTOS/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2051:../FreeRTOS/tasks.c **** 
2052:../FreeRTOS/tasks.c **** 	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
2053:../FreeRTOS/tasks.c **** 	{
2054:../FreeRTOS/tasks.c **** 	TCB_t *xTCB;
2055:../FreeRTOS/tasks.c **** 	TaskHookFunction_t xReturn;
2056:../FreeRTOS/tasks.c **** 
2057:../FreeRTOS/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
2058:../FreeRTOS/tasks.c **** 		if( xTask == NULL )
2059:../FreeRTOS/tasks.c **** 		{
2060:../FreeRTOS/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2061:../FreeRTOS/tasks.c **** 		}
2062:../FreeRTOS/tasks.c **** 		else
2063:../FreeRTOS/tasks.c **** 		{
2064:../FreeRTOS/tasks.c **** 			xTCB = ( TCB_t * ) xTask;
2065:../FreeRTOS/tasks.c **** 		}
2066:../FreeRTOS/tasks.c **** 
2067:../FreeRTOS/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2068:../FreeRTOS/tasks.c **** 		the value can be accessed from an interrupt. */
2069:../FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
2070:../FreeRTOS/tasks.c **** 		{
2071:../FreeRTOS/tasks.c **** 			xReturn = xTCB->pxTaskTag;
2072:../FreeRTOS/tasks.c **** 		}
2073:../FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
2074:../FreeRTOS/tasks.c **** 
2075:../FreeRTOS/tasks.c **** 		return xReturn;
2076:../FreeRTOS/tasks.c **** 	}
2077:../FreeRTOS/tasks.c **** 
2078:../FreeRTOS/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2079:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2080:../FreeRTOS/tasks.c **** 
2081:../FreeRTOS/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2082:../FreeRTOS/tasks.c **** 
2083:../FreeRTOS/tasks.c **** 	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
2084:../FreeRTOS/tasks.c **** 	{
2085:../FreeRTOS/tasks.c **** 	TCB_t *xTCB;
2086:../FreeRTOS/tasks.c **** 	BaseType_t xReturn;
2087:../FreeRTOS/tasks.c **** 
2088:../FreeRTOS/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
2089:../FreeRTOS/tasks.c **** 		if( xTask == NULL )
2090:../FreeRTOS/tasks.c **** 		{
2091:../FreeRTOS/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2092:../FreeRTOS/tasks.c **** 		}
2093:../FreeRTOS/tasks.c **** 		else
2094:../FreeRTOS/tasks.c **** 		{
2095:../FreeRTOS/tasks.c **** 			xTCB = ( TCB_t * ) xTask;
2096:../FreeRTOS/tasks.c **** 		}
2097:../FreeRTOS/tasks.c **** 
2098:../FreeRTOS/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
2099:../FreeRTOS/tasks.c **** 		{
2100:../FreeRTOS/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
2101:../FreeRTOS/tasks.c **** 		}
2102:../FreeRTOS/tasks.c **** 		else
2103:../FreeRTOS/tasks.c **** 		{
2104:../FreeRTOS/tasks.c **** 			xReturn = pdFAIL;
2105:../FreeRTOS/tasks.c **** 		}
2106:../FreeRTOS/tasks.c **** 
2107:../FreeRTOS/tasks.c **** 		return xReturn;
2108:../FreeRTOS/tasks.c **** 	}
2109:../FreeRTOS/tasks.c **** 
2110:../FreeRTOS/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2111:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2112:../FreeRTOS/tasks.c **** 
2113:../FreeRTOS/tasks.c **** void vTaskSwitchContext( void )
2114:../FreeRTOS/tasks.c **** {
 1917              		.loc 1 2114 0
 1918              		.cfi_startproc
 1919              		@ args = 0, pretend = 0, frame = 8
 1920              		@ frame_needed = 1, uses_anonymous_args = 0
 1921 0b1c 80B5     		push	{r7, lr}
 1922              		.cfi_def_cfa_offset 8
 1923              		.cfi_offset 7, -8
 1924              		.cfi_offset 14, -4
 1925 0b1e 82B0     		sub	sp, sp, #8
 1926              		.cfi_def_cfa_offset 16
 1927 0b20 00AF     		add	r7, sp, #0
 1928              		.cfi_def_cfa_register 7
2115:../FreeRTOS/tasks.c **** 	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 1929              		.loc 1 2115 0
 1930 0b22 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1931 0b26 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1932 0b2a 1B68     		ldr	r3, [r3]
 1933 0b2c 002B     		cmp	r3, #0
 1934 0b2e 06D0     		beq	.L105
2116:../FreeRTOS/tasks.c **** 	{
2117:../FreeRTOS/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
2118:../FreeRTOS/tasks.c **** 		switch. */
2119:../FreeRTOS/tasks.c **** 		xYieldPending = pdTRUE;
 1935              		.loc 1 2119 0
 1936 0b30 40F20003 		movw	r3, #:lower16:xYieldPending
 1937 0b34 C0F20003 		movt	r3, #:upper16:xYieldPending
 1938 0b38 0122     		movs	r2, #1
 1939 0b3a 1A60     		str	r2, [r3]
 1940 0b3c 87E0     		b	.L104
 1941              	.L105:
2120:../FreeRTOS/tasks.c **** 	}
2121:../FreeRTOS/tasks.c **** 	else
2122:../FreeRTOS/tasks.c **** 	{
2123:../FreeRTOS/tasks.c **** 		xYieldPending = pdFALSE;
 1942              		.loc 1 2123 0
 1943 0b3e 40F20003 		movw	r3, #:lower16:xYieldPending
 1944 0b42 C0F20003 		movt	r3, #:upper16:xYieldPending
 1945 0b46 0022     		movs	r2, #0
 1946 0b48 1A60     		str	r2, [r3]
2124:../FreeRTOS/tasks.c **** 		traceTASK_SWITCHED_OUT();
2125:../FreeRTOS/tasks.c **** 
2126:../FreeRTOS/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
2127:../FreeRTOS/tasks.c **** 		{
2128:../FreeRTOS/tasks.c **** 				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2129:../FreeRTOS/tasks.c **** 					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
2130:../FreeRTOS/tasks.c **** 				#else
2131:../FreeRTOS/tasks.c **** 					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2132:../FreeRTOS/tasks.c **** 				#endif
2133:../FreeRTOS/tasks.c **** 
2134:../FreeRTOS/tasks.c **** 				/* Add the amount of time the task has been running to the
2135:../FreeRTOS/tasks.c **** 				accumulated	time so far.  The time the task started running was
2136:../FreeRTOS/tasks.c **** 				stored in ulTaskSwitchedInTime.  Note that there is no overflow
2137:../FreeRTOS/tasks.c **** 				protection here	so count values are only valid until the timer
2138:../FreeRTOS/tasks.c **** 				overflows.  The guard against negative values is to protect
2139:../FreeRTOS/tasks.c **** 				against suspect run time stat counter implementations - which
2140:../FreeRTOS/tasks.c **** 				are provided by the application, not the kernel. */
2141:../FreeRTOS/tasks.c **** 				if( ulTotalRunTime > ulTaskSwitchedInTime )
2142:../FreeRTOS/tasks.c **** 				{
2143:../FreeRTOS/tasks.c **** 					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
2144:../FreeRTOS/tasks.c **** 				}
2145:../FreeRTOS/tasks.c **** 				else
2146:../FreeRTOS/tasks.c **** 				{
2147:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
2148:../FreeRTOS/tasks.c **** 				}
2149:../FreeRTOS/tasks.c **** 				ulTaskSwitchedInTime = ulTotalRunTime;
2150:../FreeRTOS/tasks.c **** 		}
2151:../FreeRTOS/tasks.c **** 		#endif /* configGENERATE_RUN_TIME_STATS */
2152:../FreeRTOS/tasks.c **** 
2153:../FreeRTOS/tasks.c **** 		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
 1947              		.loc 1 2153 0
 1948 0b4a 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1949 0b4e C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1950 0b52 1B68     		ldr	r3, [r3]
 1951 0b54 1A68     		ldr	r2, [r3]
 1952 0b56 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1953 0b5a C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1954 0b5e 1B68     		ldr	r3, [r3]
 1955 0b60 1B6B     		ldr	r3, [r3, #48]
 1956 0b62 9A42     		cmp	r2, r3
 1957 0b64 0ED8     		bhi	.L107
 1958              		.loc 1 2153 0 is_stmt 0 discriminator 1
 1959 0b66 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1960 0b6a C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1961 0b6e 1A68     		ldr	r2, [r3]
 1962 0b70 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1963 0b74 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1964 0b78 1B68     		ldr	r3, [r3]
 1965 0b7a 3433     		adds	r3, r3, #52
 1966 0b7c 1046     		mov	r0, r2
 1967 0b7e 1946     		mov	r1, r3
 1968 0b80 FFF7FEFF 		bl	vApplicationStackOverflowHook
 1969              	.L107:
 1970              	.LBB6:
2154:../FreeRTOS/tasks.c **** 		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
 1971              		.loc 1 2154 0 is_stmt 1
 1972 0b84 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1973 0b88 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1974 0b8c 1B68     		ldr	r3, [r3]
 1975 0b8e 1B6B     		ldr	r3, [r3, #48]
 1976 0b90 1846     		mov	r0, r3
 1977 0b92 40F20001 		movw	r1, #:lower16:ucExpectedStackBytes.5263
 1978 0b96 C0F20001 		movt	r1, #:upper16:ucExpectedStackBytes.5263
 1979 0b9a 1422     		movs	r2, #20
 1980 0b9c FFF7FEFF 		bl	memcmp
 1981 0ba0 0346     		mov	r3, r0
 1982 0ba2 002B     		cmp	r3, #0
 1983 0ba4 0FD0     		beq	.L108
 1984              		.loc 1 2154 0 is_stmt 0 discriminator 1
 1985 0ba6 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1986 0baa C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1987 0bae 1A68     		ldr	r2, [r3]
 1988 0bb0 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1989 0bb4 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1990 0bb8 1B68     		ldr	r3, [r3]
 1991 0bba 3433     		adds	r3, r3, #52
 1992 0bbc 1046     		mov	r0, r2
 1993 0bbe 1946     		mov	r1, r3
 1994 0bc0 FFF7FEFF 		bl	vApplicationStackOverflowHook
 1995              	.LBE6:
2155:../FreeRTOS/tasks.c **** 
2156:../FreeRTOS/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
 1996              		.loc 1 2156 0 is_stmt 1 discriminator 1
 1997 0bc4 0BE0     		b	.L109
 1998              	.L108:
 1999              		.loc 1 2156 0 is_stmt 0
 2000 0bc6 0AE0     		b	.L109
 2001              	.L110:
 2002              		.loc 1 2156 0 discriminator 2
 2003 0bc8 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2004 0bcc C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2005 0bd0 1B68     		ldr	r3, [r3]
 2006 0bd2 5A1E     		subs	r2, r3, #1
 2007 0bd4 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2008 0bd8 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2009 0bdc 1A60     		str	r2, [r3]
 2010              	.L109:
 2011              		.loc 1 2156 0 discriminator 1
 2012 0bde 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2013 0be2 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2014 0be6 1968     		ldr	r1, [r3]
 2015 0be8 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 2016 0bec C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 2017 0bf0 0B46     		mov	r3, r1
 2018 0bf2 9B00     		lsls	r3, r3, #2
 2019 0bf4 0B44     		add	r3, r3, r1
 2020 0bf6 9B00     		lsls	r3, r3, #2
 2021 0bf8 1344     		add	r3, r3, r2
 2022 0bfa 1B68     		ldr	r3, [r3]
 2023 0bfc 002B     		cmp	r3, #0
 2024 0bfe E3D0     		beq	.L110
 2025              	.LBB7:
 2026              		.loc 1 2156 0 discriminator 3
 2027 0c00 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2028 0c04 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2029 0c08 1A68     		ldr	r2, [r3]
 2030 0c0a 1346     		mov	r3, r2
 2031 0c0c 9B00     		lsls	r3, r3, #2
 2032 0c0e 1344     		add	r3, r3, r2
 2033 0c10 9B00     		lsls	r3, r3, #2
 2034 0c12 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 2035 0c16 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 2036 0c1a 1344     		add	r3, r3, r2
 2037 0c1c 7B60     		str	r3, [r7, #4]
 2038 0c1e 7B68     		ldr	r3, [r7, #4]
 2039 0c20 5B68     		ldr	r3, [r3, #4]
 2040 0c22 5A68     		ldr	r2, [r3, #4]
 2041 0c24 7B68     		ldr	r3, [r7, #4]
 2042 0c26 5A60     		str	r2, [r3, #4]
 2043 0c28 7B68     		ldr	r3, [r7, #4]
 2044 0c2a 5A68     		ldr	r2, [r3, #4]
 2045 0c2c 7B68     		ldr	r3, [r7, #4]
 2046 0c2e 0833     		adds	r3, r3, #8
 2047 0c30 9A42     		cmp	r2, r3
 2048 0c32 04D1     		bne	.L111
 2049              		.loc 1 2156 0 discriminator 1
 2050 0c34 7B68     		ldr	r3, [r7, #4]
 2051 0c36 5B68     		ldr	r3, [r3, #4]
 2052 0c38 5A68     		ldr	r2, [r3, #4]
 2053 0c3a 7B68     		ldr	r3, [r7, #4]
 2054 0c3c 5A60     		str	r2, [r3, #4]
 2055              	.L111:
 2056              		.loc 1 2156 0 discriminator 2
 2057 0c3e 7B68     		ldr	r3, [r7, #4]
 2058 0c40 5B68     		ldr	r3, [r3, #4]
 2059 0c42 DA68     		ldr	r2, [r3, #12]
 2060 0c44 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2061 0c48 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2062 0c4c 1A60     		str	r2, [r3]
 2063              	.L104:
 2064              	.LBE7:
2157:../FreeRTOS/tasks.c **** 
2158:../FreeRTOS/tasks.c **** 		traceTASK_SWITCHED_IN();
2159:../FreeRTOS/tasks.c **** 
2160:../FreeRTOS/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
2161:../FreeRTOS/tasks.c **** 		{
2162:../FreeRTOS/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
2163:../FreeRTOS/tasks.c **** 			structure specific to this task. */
2164:../FreeRTOS/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
2165:../FreeRTOS/tasks.c **** 		}
2166:../FreeRTOS/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
2167:../FreeRTOS/tasks.c **** 	}
2168:../FreeRTOS/tasks.c **** }
 2065              		.loc 1 2168 0 is_stmt 1
 2066 0c4e 0837     		adds	r7, r7, #8
 2067 0c50 BD46     		mov	sp, r7
 2068              		@ sp needed
 2069 0c52 80BD     		pop	{r7, pc}
 2070              		.cfi_endproc
 2071              	.LFE18:
 2073              		.align	2
 2074              		.global	vTaskPlaceOnEventList
 2075              		.thumb
 2076              		.thumb_func
 2078              	vTaskPlaceOnEventList:
 2079              	.LFB19:
2169:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2170:../FreeRTOS/tasks.c **** 
2171:../FreeRTOS/tasks.c **** void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
2172:../FreeRTOS/tasks.c **** {
 2080              		.loc 1 2172 0
 2081              		.cfi_startproc
 2082              		@ args = 0, pretend = 0, frame = 16
 2083              		@ frame_needed = 1, uses_anonymous_args = 0
 2084 0c54 80B5     		push	{r7, lr}
 2085              		.cfi_def_cfa_offset 8
 2086              		.cfi_offset 7, -8
 2087              		.cfi_offset 14, -4
 2088 0c56 84B0     		sub	sp, sp, #16
 2089              		.cfi_def_cfa_offset 24
 2090 0c58 00AF     		add	r7, sp, #0
 2091              		.cfi_def_cfa_register 7
 2092 0c5a 7860     		str	r0, [r7, #4]
 2093 0c5c 3960     		str	r1, [r7]
2173:../FreeRTOS/tasks.c **** TickType_t xTimeToWake;
2174:../FreeRTOS/tasks.c **** 
2175:../FreeRTOS/tasks.c **** 	configASSERT( pxEventList );
2176:../FreeRTOS/tasks.c **** 
2177:../FreeRTOS/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
2178:../FreeRTOS/tasks.c **** 	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
2179:../FreeRTOS/tasks.c **** 
2180:../FreeRTOS/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
2181:../FreeRTOS/tasks.c **** 	This is placed in the list in priority order so the highest priority task
2182:../FreeRTOS/tasks.c **** 	is the first to be woken by the event.  The queue that contains the event
2183:../FreeRTOS/tasks.c **** 	list is locked, preventing simultaneous access from interrupts. */
2184:../FreeRTOS/tasks.c **** 	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 2094              		.loc 1 2184 0
 2095 0c5e 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2096 0c62 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2097 0c66 1B68     		ldr	r3, [r3]
 2098 0c68 1833     		adds	r3, r3, #24
 2099 0c6a 7868     		ldr	r0, [r7, #4]
 2100 0c6c 1946     		mov	r1, r3
 2101 0c6e FFF7FEFF 		bl	vListInsert
2185:../FreeRTOS/tasks.c **** 
2186:../FreeRTOS/tasks.c **** 	/* The task must be removed from from the ready list before it is added to
2187:../FreeRTOS/tasks.c **** 	the blocked list as the same list item is used for both lists.  Exclusive
2188:../FreeRTOS/tasks.c **** 	access to the ready lists guaranteed because the scheduler is locked. */
2189:../FreeRTOS/tasks.c **** 	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 2102              		.loc 1 2189 0
 2103 0c72 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2104 0c76 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2105 0c7a 1B68     		ldr	r3, [r3]
 2106 0c7c 0433     		adds	r3, r3, #4
 2107 0c7e 1846     		mov	r0, r3
 2108 0c80 FFF7FEFF 		bl	uxListRemove
2190:../FreeRTOS/tasks.c **** 	{
2191:../FreeRTOS/tasks.c **** 		/* The current task must be in a ready list, so there is no need to
2192:../FreeRTOS/tasks.c **** 		check, and the port reset macro can be called directly. */
2193:../FreeRTOS/tasks.c **** 		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
2194:../FreeRTOS/tasks.c **** 	}
2195:../FreeRTOS/tasks.c **** 	else
2196:../FreeRTOS/tasks.c **** 	{
2197:../FreeRTOS/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
2198:../FreeRTOS/tasks.c **** 	}
2199:../FreeRTOS/tasks.c **** 
2200:../FreeRTOS/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
2201:../FreeRTOS/tasks.c **** 	{
2202:../FreeRTOS/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
 2109              		.loc 1 2202 0
 2110 0c84 3B68     		ldr	r3, [r7]
 2111 0c86 B3F1FF3F 		cmp	r3, #-1
 2112 0c8a 0DD1     		bne	.L113
2203:../FreeRTOS/tasks.c **** 		{
2204:../FreeRTOS/tasks.c **** 			/* Add the task to the suspended task list instead of a delayed task
2205:../FreeRTOS/tasks.c **** 			list to ensure the task is not woken by a timing event.  It will
2206:../FreeRTOS/tasks.c **** 			block indefinitely. */
2207:../FreeRTOS/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 2113              		.loc 1 2207 0
 2114 0c8c 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2115 0c90 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2116 0c94 1B68     		ldr	r3, [r3]
 2117 0c96 0433     		adds	r3, r3, #4
 2118 0c98 40F20000 		movw	r0, #:lower16:xSuspendedTaskList
 2119 0c9c C0F20000 		movt	r0, #:upper16:xSuspendedTaskList
 2120 0ca0 1946     		mov	r1, r3
 2121 0ca2 FFF7FEFF 		bl	vListInsertEnd
 2122 0ca6 0AE0     		b	.L112
 2123              	.L113:
2208:../FreeRTOS/tasks.c **** 		}
2209:../FreeRTOS/tasks.c **** 		else
2210:../FreeRTOS/tasks.c **** 		{
2211:../FreeRTOS/tasks.c **** 			/* Calculate the time at which the task should be woken if the event
2212:../FreeRTOS/tasks.c **** 			does not occur.  This may overflow but this doesn't matter, the
2213:../FreeRTOS/tasks.c **** 			scheduler will handle it. */
2214:../FreeRTOS/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
 2124              		.loc 1 2214 0
 2125 0ca8 40F20003 		movw	r3, #:lower16:xTickCount
 2126 0cac C0F20003 		movt	r3, #:upper16:xTickCount
 2127 0cb0 1A68     		ldr	r2, [r3]
 2128 0cb2 3B68     		ldr	r3, [r7]
 2129 0cb4 1344     		add	r3, r3, r2
 2130 0cb6 FB60     		str	r3, [r7, #12]
2215:../FreeRTOS/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
 2131              		.loc 1 2215 0
 2132 0cb8 F868     		ldr	r0, [r7, #12]
 2133 0cba 00F04BFA 		bl	prvAddCurrentTaskToDelayedList
 2134              	.L112:
2216:../FreeRTOS/tasks.c **** 		}
2217:../FreeRTOS/tasks.c **** 	}
2218:../FreeRTOS/tasks.c **** 	#else /* INCLUDE_vTaskSuspend */
2219:../FreeRTOS/tasks.c **** 	{
2220:../FreeRTOS/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
2221:../FreeRTOS/tasks.c **** 			not occur.  This may overflow but this doesn't matter, the scheduler
2222:../FreeRTOS/tasks.c **** 			will handle it. */
2223:../FreeRTOS/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
2224:../FreeRTOS/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
2225:../FreeRTOS/tasks.c **** 	}
2226:../FreeRTOS/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
2227:../FreeRTOS/tasks.c **** }
 2135              		.loc 1 2227 0
 2136 0cbe 1037     		adds	r7, r7, #16
 2137 0cc0 BD46     		mov	sp, r7
 2138              		@ sp needed
 2139 0cc2 80BD     		pop	{r7, pc}
 2140              		.cfi_endproc
 2141              	.LFE19:
 2143              		.align	2
 2144              		.global	vTaskPlaceOnUnorderedEventList
 2145              		.thumb
 2146              		.thumb_func
 2148              	vTaskPlaceOnUnorderedEventList:
 2149              	.LFB20:
2228:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2229:../FreeRTOS/tasks.c **** 
2230:../FreeRTOS/tasks.c **** void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickT
2231:../FreeRTOS/tasks.c **** {
 2150              		.loc 1 2231 0
 2151              		.cfi_startproc
 2152              		@ args = 0, pretend = 0, frame = 24
 2153              		@ frame_needed = 1, uses_anonymous_args = 0
 2154 0cc4 80B5     		push	{r7, lr}
 2155              		.cfi_def_cfa_offset 8
 2156              		.cfi_offset 7, -8
 2157              		.cfi_offset 14, -4
 2158 0cc6 86B0     		sub	sp, sp, #24
 2159              		.cfi_def_cfa_offset 32
 2160 0cc8 00AF     		add	r7, sp, #0
 2161              		.cfi_def_cfa_register 7
 2162 0cca F860     		str	r0, [r7, #12]
 2163 0ccc B960     		str	r1, [r7, #8]
 2164 0cce 7A60     		str	r2, [r7, #4]
2232:../FreeRTOS/tasks.c **** TickType_t xTimeToWake;
2233:../FreeRTOS/tasks.c **** 
2234:../FreeRTOS/tasks.c **** 	configASSERT( pxEventList );
2235:../FreeRTOS/tasks.c **** 
2236:../FreeRTOS/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2237:../FreeRTOS/tasks.c **** 	the event groups implementation. */
2238:../FreeRTOS/tasks.c **** 	configASSERT( uxSchedulerSuspended != 0 );
2239:../FreeRTOS/tasks.c **** 
2240:../FreeRTOS/tasks.c **** 	/* Store the item value in the event list item.  It is safe to access the
2241:../FreeRTOS/tasks.c **** 	event list item here as interrupts won't access the event list item of a
2242:../FreeRTOS/tasks.c **** 	task that is not in the Blocked state. */
2243:../FreeRTOS/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE
 2165              		.loc 1 2243 0
 2166 0cd0 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2167 0cd4 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2168 0cd8 1B68     		ldr	r3, [r3]
 2169 0cda BA68     		ldr	r2, [r7, #8]
 2170 0cdc 42F00042 		orr	r2, r2, #-2147483648
 2171 0ce0 9A61     		str	r2, [r3, #24]
2244:../FreeRTOS/tasks.c **** 
2245:../FreeRTOS/tasks.c **** 	/* Place the event list item of the TCB at the end of the appropriate event
2246:../FreeRTOS/tasks.c **** 	list.  It is safe to access the event list here because it is part of an
2247:../FreeRTOS/tasks.c **** 	event group implementation - and interrupts don't access event groups
2248:../FreeRTOS/tasks.c **** 	directly (instead they access them indirectly by pending function calls to
2249:../FreeRTOS/tasks.c **** 	the task level). */
2250:../FreeRTOS/tasks.c **** 	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 2172              		.loc 1 2250 0
 2173 0ce2 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2174 0ce6 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2175 0cea 1B68     		ldr	r3, [r3]
 2176 0cec 1833     		adds	r3, r3, #24
 2177 0cee F868     		ldr	r0, [r7, #12]
 2178 0cf0 1946     		mov	r1, r3
 2179 0cf2 FFF7FEFF 		bl	vListInsertEnd
2251:../FreeRTOS/tasks.c **** 
2252:../FreeRTOS/tasks.c **** 	/* The task must be removed from the ready list before it is added to the
2253:../FreeRTOS/tasks.c **** 	blocked list.  Exclusive access can be assured to the ready list as the
2254:../FreeRTOS/tasks.c **** 	scheduler is locked. */
2255:../FreeRTOS/tasks.c **** 	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 2180              		.loc 1 2255 0
 2181 0cf6 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2182 0cfa C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2183 0cfe 1B68     		ldr	r3, [r3]
 2184 0d00 0433     		adds	r3, r3, #4
 2185 0d02 1846     		mov	r0, r3
 2186 0d04 FFF7FEFF 		bl	uxListRemove
2256:../FreeRTOS/tasks.c **** 	{
2257:../FreeRTOS/tasks.c **** 		/* The current task must be in a ready list, so there is no need to
2258:../FreeRTOS/tasks.c **** 		check, and the port reset macro can be called directly. */
2259:../FreeRTOS/tasks.c **** 		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
2260:../FreeRTOS/tasks.c **** 	}
2261:../FreeRTOS/tasks.c **** 	else
2262:../FreeRTOS/tasks.c **** 	{
2263:../FreeRTOS/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
2264:../FreeRTOS/tasks.c **** 	}
2265:../FreeRTOS/tasks.c **** 
2266:../FreeRTOS/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
2267:../FreeRTOS/tasks.c **** 	{
2268:../FreeRTOS/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
 2187              		.loc 1 2268 0
 2188 0d08 7B68     		ldr	r3, [r7, #4]
 2189 0d0a B3F1FF3F 		cmp	r3, #-1
 2190 0d0e 0DD1     		bne	.L116
2269:../FreeRTOS/tasks.c **** 		{
2270:../FreeRTOS/tasks.c **** 			/* Add the task to the suspended task list instead of a delayed task
2271:../FreeRTOS/tasks.c **** 			list to ensure it is not woken by a timing event.  It will block
2272:../FreeRTOS/tasks.c **** 			indefinitely. */
2273:../FreeRTOS/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 2191              		.loc 1 2273 0
 2192 0d10 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2193 0d14 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2194 0d18 1B68     		ldr	r3, [r3]
 2195 0d1a 0433     		adds	r3, r3, #4
 2196 0d1c 40F20000 		movw	r0, #:lower16:xSuspendedTaskList
 2197 0d20 C0F20000 		movt	r0, #:upper16:xSuspendedTaskList
 2198 0d24 1946     		mov	r1, r3
 2199 0d26 FFF7FEFF 		bl	vListInsertEnd
 2200 0d2a 0AE0     		b	.L115
 2201              	.L116:
2274:../FreeRTOS/tasks.c **** 		}
2275:../FreeRTOS/tasks.c **** 		else
2276:../FreeRTOS/tasks.c **** 		{
2277:../FreeRTOS/tasks.c **** 			/* Calculate the time at which the task should be woken if the event
2278:../FreeRTOS/tasks.c **** 			does not occur.  This may overflow but this doesn't matter, the
2279:../FreeRTOS/tasks.c **** 			kernel will manage it correctly. */
2280:../FreeRTOS/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
 2202              		.loc 1 2280 0
 2203 0d2c 40F20003 		movw	r3, #:lower16:xTickCount
 2204 0d30 C0F20003 		movt	r3, #:upper16:xTickCount
 2205 0d34 1A68     		ldr	r2, [r3]
 2206 0d36 7B68     		ldr	r3, [r7, #4]
 2207 0d38 1344     		add	r3, r3, r2
 2208 0d3a 7B61     		str	r3, [r7, #20]
2281:../FreeRTOS/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
 2209              		.loc 1 2281 0
 2210 0d3c 7869     		ldr	r0, [r7, #20]
 2211 0d3e 00F009FA 		bl	prvAddCurrentTaskToDelayedList
 2212              	.L115:
2282:../FreeRTOS/tasks.c **** 		}
2283:../FreeRTOS/tasks.c **** 	}
2284:../FreeRTOS/tasks.c **** 	#else /* INCLUDE_vTaskSuspend */
2285:../FreeRTOS/tasks.c **** 	{
2286:../FreeRTOS/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
2287:../FreeRTOS/tasks.c **** 			not occur.  This may overflow but this doesn't matter, the kernel
2288:../FreeRTOS/tasks.c **** 			will manage it correctly. */
2289:../FreeRTOS/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
2290:../FreeRTOS/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
2291:../FreeRTOS/tasks.c **** 	}
2292:../FreeRTOS/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
2293:../FreeRTOS/tasks.c **** }
 2213              		.loc 1 2293 0
 2214 0d42 1837     		adds	r7, r7, #24
 2215 0d44 BD46     		mov	sp, r7
 2216              		@ sp needed
 2217 0d46 80BD     		pop	{r7, pc}
 2218              		.cfi_endproc
 2219              	.LFE20:
 2221              		.align	2
 2222              		.global	xTaskRemoveFromEventList
 2223              		.thumb
 2224              		.thumb_func
 2226              	xTaskRemoveFromEventList:
 2227              	.LFB21:
2294:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2295:../FreeRTOS/tasks.c **** 
2296:../FreeRTOS/tasks.c **** #if configUSE_TIMERS == 1
2297:../FreeRTOS/tasks.c **** 
2298:../FreeRTOS/tasks.c **** 	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait )
2299:../FreeRTOS/tasks.c **** 	{
2300:../FreeRTOS/tasks.c **** 	TickType_t xTimeToWake;
2301:../FreeRTOS/tasks.c **** 
2302:../FreeRTOS/tasks.c **** 		configASSERT( pxEventList );
2303:../FreeRTOS/tasks.c **** 
2304:../FreeRTOS/tasks.c **** 		/* This function should not be called by application code hence the
2305:../FreeRTOS/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
2306:../FreeRTOS/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
2307:../FreeRTOS/tasks.c **** 		it should be called from a critical section. */
2308:../FreeRTOS/tasks.c **** 
2309:../FreeRTOS/tasks.c **** 
2310:../FreeRTOS/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
2311:../FreeRTOS/tasks.c **** 		In this case it is assume that this is the only task that is going to
2312:../FreeRTOS/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
2313:../FreeRTOS/tasks.c **** 		can be used in place of vListInsert. */
2314:../FreeRTOS/tasks.c **** 		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
2315:../FreeRTOS/tasks.c **** 
2316:../FreeRTOS/tasks.c **** 		/* We must remove this task from the ready list before adding it to the
2317:../FreeRTOS/tasks.c **** 		blocked list as the same list item is used for both lists.  This
2318:../FreeRTOS/tasks.c **** 		function is called form a critical section. */
2319:../FreeRTOS/tasks.c **** 		if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
2320:../FreeRTOS/tasks.c **** 		{
2321:../FreeRTOS/tasks.c **** 			/* The current task must be in a ready list, so there is no need to
2322:../FreeRTOS/tasks.c **** 			check, and the port reset macro can be called directly. */
2323:../FreeRTOS/tasks.c **** 			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
2324:../FreeRTOS/tasks.c **** 		}
2325:../FreeRTOS/tasks.c **** 		else
2326:../FreeRTOS/tasks.c **** 		{
2327:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2328:../FreeRTOS/tasks.c **** 		}
2329:../FreeRTOS/tasks.c **** 
2330:../FreeRTOS/tasks.c **** 		/* Calculate the time at which the task should be woken if the event does
2331:../FreeRTOS/tasks.c **** 		not occur.  This may overflow but this doesn't matter. */
2332:../FreeRTOS/tasks.c **** 		xTimeToWake = xTickCount + xTicksToWait;
2333:../FreeRTOS/tasks.c **** 
2334:../FreeRTOS/tasks.c **** 		traceTASK_DELAY_UNTIL();
2335:../FreeRTOS/tasks.c **** 		prvAddCurrentTaskToDelayedList( xTimeToWake );
2336:../FreeRTOS/tasks.c **** 	}
2337:../FreeRTOS/tasks.c **** 
2338:../FreeRTOS/tasks.c **** #endif /* configUSE_TIMERS */
2339:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2340:../FreeRTOS/tasks.c **** 
2341:../FreeRTOS/tasks.c **** BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
2342:../FreeRTOS/tasks.c **** {
 2228              		.loc 1 2342 0
 2229              		.cfi_startproc
 2230              		@ args = 0, pretend = 0, frame = 16
 2231              		@ frame_needed = 1, uses_anonymous_args = 0
 2232 0d48 80B5     		push	{r7, lr}
 2233              		.cfi_def_cfa_offset 8
 2234              		.cfi_offset 7, -8
 2235              		.cfi_offset 14, -4
 2236 0d4a 84B0     		sub	sp, sp, #16
 2237              		.cfi_def_cfa_offset 24
 2238 0d4c 00AF     		add	r7, sp, #0
 2239              		.cfi_def_cfa_register 7
 2240 0d4e 7860     		str	r0, [r7, #4]
2343:../FreeRTOS/tasks.c **** TCB_t *pxUnblockedTCB;
2344:../FreeRTOS/tasks.c **** BaseType_t xReturn;
2345:../FreeRTOS/tasks.c **** 
2346:../FreeRTOS/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
2347:../FreeRTOS/tasks.c **** 	called from a critical section within an ISR. */
2348:../FreeRTOS/tasks.c **** 
2349:../FreeRTOS/tasks.c **** 	/* The event list is sorted in priority order, so the first in the list can
2350:../FreeRTOS/tasks.c **** 	be removed as it is known to be the highest priority.  Remove the TCB from
2351:../FreeRTOS/tasks.c **** 	the delayed list, and add it to the ready list.
2352:../FreeRTOS/tasks.c **** 
2353:../FreeRTOS/tasks.c **** 	If an event is for a queue that is locked then this function will never
2354:../FreeRTOS/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
2355:../FreeRTOS/tasks.c **** 	means exclusive access to the event list is guaranteed here.
2356:../FreeRTOS/tasks.c **** 
2357:../FreeRTOS/tasks.c **** 	This function assumes that a check has already been made to ensure that
2358:../FreeRTOS/tasks.c **** 	pxEventList is not empty. */
2359:../FreeRTOS/tasks.c **** 	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 2241              		.loc 1 2359 0
 2242 0d50 7B68     		ldr	r3, [r7, #4]
 2243 0d52 DB68     		ldr	r3, [r3, #12]
 2244 0d54 DB68     		ldr	r3, [r3, #12]
 2245 0d56 BB60     		str	r3, [r7, #8]
2360:../FreeRTOS/tasks.c **** 	configASSERT( pxUnblockedTCB );
2361:../FreeRTOS/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 2246              		.loc 1 2361 0
 2247 0d58 BB68     		ldr	r3, [r7, #8]
 2248 0d5a 1833     		adds	r3, r3, #24
 2249 0d5c 1846     		mov	r0, r3
 2250 0d5e FFF7FEFF 		bl	uxListRemove
2362:../FreeRTOS/tasks.c **** 
2363:../FreeRTOS/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 2251              		.loc 1 2363 0
 2252 0d62 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 2253 0d66 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 2254 0d6a 1B68     		ldr	r3, [r3]
 2255 0d6c 002B     		cmp	r3, #0
 2256 0d6e 26D1     		bne	.L119
2364:../FreeRTOS/tasks.c **** 	{
2365:../FreeRTOS/tasks.c **** 		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 2257              		.loc 1 2365 0
 2258 0d70 BB68     		ldr	r3, [r7, #8]
 2259 0d72 0433     		adds	r3, r3, #4
 2260 0d74 1846     		mov	r0, r3
 2261 0d76 FFF7FEFF 		bl	uxListRemove
2366:../FreeRTOS/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
 2262              		.loc 1 2366 0
 2263 0d7a BB68     		ldr	r3, [r7, #8]
 2264 0d7c DA6A     		ldr	r2, [r3, #44]
 2265 0d7e 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2266 0d82 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2267 0d86 1B68     		ldr	r3, [r3]
 2268 0d88 9A42     		cmp	r2, r3
 2269 0d8a 06D9     		bls	.L120
 2270              		.loc 1 2366 0 is_stmt 0 discriminator 1
 2271 0d8c BB68     		ldr	r3, [r7, #8]
 2272 0d8e DA6A     		ldr	r2, [r3, #44]
 2273 0d90 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2274 0d94 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2275 0d98 1A60     		str	r2, [r3]
 2276              	.L120:
 2277              		.loc 1 2366 0 discriminator 2
 2278 0d9a BB68     		ldr	r3, [r7, #8]
 2279 0d9c DA6A     		ldr	r2, [r3, #44]
 2280 0d9e 1346     		mov	r3, r2
 2281 0da0 9B00     		lsls	r3, r3, #2
 2282 0da2 1344     		add	r3, r3, r2
 2283 0da4 9B00     		lsls	r3, r3, #2
 2284 0da6 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 2285 0daa C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 2286 0dae 1A44     		add	r2, r2, r3
 2287 0db0 BB68     		ldr	r3, [r7, #8]
 2288 0db2 0433     		adds	r3, r3, #4
 2289 0db4 1046     		mov	r0, r2
 2290 0db6 1946     		mov	r1, r3
 2291 0db8 FFF7FEFF 		bl	vListInsertEnd
 2292 0dbc 08E0     		b	.L121
 2293              	.L119:
2367:../FreeRTOS/tasks.c **** 	}
2368:../FreeRTOS/tasks.c **** 	else
2369:../FreeRTOS/tasks.c **** 	{
2370:../FreeRTOS/tasks.c **** 		/* The delayed and ready lists cannot be accessed, so hold this task
2371:../FreeRTOS/tasks.c **** 		pending until the scheduler is resumed. */
2372:../FreeRTOS/tasks.c **** 		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 2294              		.loc 1 2372 0 is_stmt 1
 2295 0dbe BB68     		ldr	r3, [r7, #8]
 2296 0dc0 1833     		adds	r3, r3, #24
 2297 0dc2 40F20000 		movw	r0, #:lower16:xPendingReadyList
 2298 0dc6 C0F20000 		movt	r0, #:upper16:xPendingReadyList
 2299 0dca 1946     		mov	r1, r3
 2300 0dcc FFF7FEFF 		bl	vListInsertEnd
 2301              	.L121:
2373:../FreeRTOS/tasks.c **** 	}
2374:../FreeRTOS/tasks.c **** 
2375:../FreeRTOS/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 2302              		.loc 1 2375 0
 2303 0dd0 BB68     		ldr	r3, [r7, #8]
 2304 0dd2 DA6A     		ldr	r2, [r3, #44]
 2305 0dd4 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2306 0dd8 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2307 0ddc 1B68     		ldr	r3, [r3]
 2308 0dde DB6A     		ldr	r3, [r3, #44]
 2309 0de0 9A42     		cmp	r2, r3
 2310 0de2 08D9     		bls	.L122
2376:../FreeRTOS/tasks.c **** 	{
2377:../FreeRTOS/tasks.c **** 		/* Return true if the task removed from the event list has a higher
2378:../FreeRTOS/tasks.c **** 		priority than the calling task.  This allows the calling task to know if
2379:../FreeRTOS/tasks.c **** 		it should force a context switch now. */
2380:../FreeRTOS/tasks.c **** 		xReturn = pdTRUE;
 2311              		.loc 1 2380 0
 2312 0de4 0123     		movs	r3, #1
 2313 0de6 FB60     		str	r3, [r7, #12]
2381:../FreeRTOS/tasks.c **** 
2382:../FreeRTOS/tasks.c **** 		/* Mark that a yield is pending in case the user is not using the
2383:../FreeRTOS/tasks.c **** 		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
2384:../FreeRTOS/tasks.c **** 		xYieldPending = pdTRUE;
 2314              		.loc 1 2384 0
 2315 0de8 40F20003 		movw	r3, #:lower16:xYieldPending
 2316 0dec C0F20003 		movt	r3, #:upper16:xYieldPending
 2317 0df0 0122     		movs	r2, #1
 2318 0df2 1A60     		str	r2, [r3]
 2319 0df4 01E0     		b	.L123
 2320              	.L122:
2385:../FreeRTOS/tasks.c **** 	}
2386:../FreeRTOS/tasks.c **** 	else
2387:../FreeRTOS/tasks.c **** 	{
2388:../FreeRTOS/tasks.c **** 		xReturn = pdFALSE;
 2321              		.loc 1 2388 0
 2322 0df6 0023     		movs	r3, #0
 2323 0df8 FB60     		str	r3, [r7, #12]
 2324              	.L123:
2389:../FreeRTOS/tasks.c **** 	}
2390:../FreeRTOS/tasks.c **** 
2391:../FreeRTOS/tasks.c **** 	return xReturn;
 2325              		.loc 1 2391 0
 2326 0dfa FB68     		ldr	r3, [r7, #12]
2392:../FreeRTOS/tasks.c **** }
 2327              		.loc 1 2392 0
 2328 0dfc 1846     		mov	r0, r3
 2329 0dfe 1037     		adds	r7, r7, #16
 2330 0e00 BD46     		mov	sp, r7
 2331              		@ sp needed
 2332 0e02 80BD     		pop	{r7, pc}
 2333              		.cfi_endproc
 2334              	.LFE21:
 2336              		.align	2
 2337              		.global	xTaskRemoveFromUnorderedEventList
 2338              		.thumb
 2339              		.thumb_func
 2341              	xTaskRemoveFromUnorderedEventList:
 2342              	.LFB22:
2393:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2394:../FreeRTOS/tasks.c **** 
2395:../FreeRTOS/tasks.c **** BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemV
2396:../FreeRTOS/tasks.c **** {
 2343              		.loc 1 2396 0
 2344              		.cfi_startproc
 2345              		@ args = 0, pretend = 0, frame = 16
 2346              		@ frame_needed = 1, uses_anonymous_args = 0
 2347 0e04 80B5     		push	{r7, lr}
 2348              		.cfi_def_cfa_offset 8
 2349              		.cfi_offset 7, -8
 2350              		.cfi_offset 14, -4
 2351 0e06 84B0     		sub	sp, sp, #16
 2352              		.cfi_def_cfa_offset 24
 2353 0e08 00AF     		add	r7, sp, #0
 2354              		.cfi_def_cfa_register 7
 2355 0e0a 7860     		str	r0, [r7, #4]
 2356 0e0c 3960     		str	r1, [r7]
2397:../FreeRTOS/tasks.c **** TCB_t *pxUnblockedTCB;
2398:../FreeRTOS/tasks.c **** BaseType_t xReturn;
2399:../FreeRTOS/tasks.c **** 
2400:../FreeRTOS/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2401:../FreeRTOS/tasks.c **** 	the event flags implementation. */
2402:../FreeRTOS/tasks.c **** 	configASSERT( uxSchedulerSuspended != pdFALSE );
2403:../FreeRTOS/tasks.c **** 
2404:../FreeRTOS/tasks.c **** 	/* Store the new item value in the event list. */
2405:../FreeRTOS/tasks.c **** 	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 2357              		.loc 1 2405 0
 2358 0e0e 3B68     		ldr	r3, [r7]
 2359 0e10 43F00042 		orr	r2, r3, #-2147483648
 2360 0e14 7B68     		ldr	r3, [r7, #4]
 2361 0e16 1A60     		str	r2, [r3]
2406:../FreeRTOS/tasks.c **** 
2407:../FreeRTOS/tasks.c **** 	/* Remove the event list form the event flag.  Interrupts do not access
2408:../FreeRTOS/tasks.c **** 	event flags. */
2409:../FreeRTOS/tasks.c **** 	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
 2362              		.loc 1 2409 0
 2363 0e18 7B68     		ldr	r3, [r7, #4]
 2364 0e1a DB68     		ldr	r3, [r3, #12]
 2365 0e1c BB60     		str	r3, [r7, #8]
2410:../FreeRTOS/tasks.c **** 	configASSERT( pxUnblockedTCB );
2411:../FreeRTOS/tasks.c **** 	( void ) uxListRemove( pxEventListItem );
 2366              		.loc 1 2411 0
 2367 0e1e 7868     		ldr	r0, [r7, #4]
 2368 0e20 FFF7FEFF 		bl	uxListRemove
2412:../FreeRTOS/tasks.c **** 
2413:../FreeRTOS/tasks.c **** 	/* Remove the task from the delayed list and add it to the ready list.  The
2414:../FreeRTOS/tasks.c **** 	scheduler is suspended so interrupts will not be accessing the ready
2415:../FreeRTOS/tasks.c **** 	lists. */
2416:../FreeRTOS/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 2369              		.loc 1 2416 0
 2370 0e24 BB68     		ldr	r3, [r7, #8]
 2371 0e26 0433     		adds	r3, r3, #4
 2372 0e28 1846     		mov	r0, r3
 2373 0e2a FFF7FEFF 		bl	uxListRemove
2417:../FreeRTOS/tasks.c **** 	prvAddTaskToReadyList( pxUnblockedTCB );
 2374              		.loc 1 2417 0
 2375 0e2e BB68     		ldr	r3, [r7, #8]
 2376 0e30 DA6A     		ldr	r2, [r3, #44]
 2377 0e32 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2378 0e36 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2379 0e3a 1B68     		ldr	r3, [r3]
 2380 0e3c 9A42     		cmp	r2, r3
 2381 0e3e 06D9     		bls	.L126
 2382              		.loc 1 2417 0 is_stmt 0 discriminator 1
 2383 0e40 BB68     		ldr	r3, [r7, #8]
 2384 0e42 DA6A     		ldr	r2, [r3, #44]
 2385 0e44 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2386 0e48 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2387 0e4c 1A60     		str	r2, [r3]
 2388              	.L126:
 2389              		.loc 1 2417 0 discriminator 2
 2390 0e4e BB68     		ldr	r3, [r7, #8]
 2391 0e50 DA6A     		ldr	r2, [r3, #44]
 2392 0e52 1346     		mov	r3, r2
 2393 0e54 9B00     		lsls	r3, r3, #2
 2394 0e56 1344     		add	r3, r3, r2
 2395 0e58 9B00     		lsls	r3, r3, #2
 2396 0e5a 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 2397 0e5e C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 2398 0e62 1A44     		add	r2, r2, r3
 2399 0e64 BB68     		ldr	r3, [r7, #8]
 2400 0e66 0433     		adds	r3, r3, #4
 2401 0e68 1046     		mov	r0, r2
 2402 0e6a 1946     		mov	r1, r3
 2403 0e6c FFF7FEFF 		bl	vListInsertEnd
2418:../FreeRTOS/tasks.c **** 
2419:../FreeRTOS/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 2404              		.loc 1 2419 0 is_stmt 1 discriminator 2
 2405 0e70 BB68     		ldr	r3, [r7, #8]
 2406 0e72 DA6A     		ldr	r2, [r3, #44]
 2407 0e74 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2408 0e78 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2409 0e7c 1B68     		ldr	r3, [r3]
 2410 0e7e DB6A     		ldr	r3, [r3, #44]
 2411 0e80 9A42     		cmp	r2, r3
 2412 0e82 08D9     		bls	.L127
2420:../FreeRTOS/tasks.c **** 	{
2421:../FreeRTOS/tasks.c **** 		/* Return true if the task removed from the event list has
2422:../FreeRTOS/tasks.c **** 		a higher priority than the calling task.  This allows
2423:../FreeRTOS/tasks.c **** 		the calling task to know if it should force a context
2424:../FreeRTOS/tasks.c **** 		switch now. */
2425:../FreeRTOS/tasks.c **** 		xReturn = pdTRUE;
 2413              		.loc 1 2425 0
 2414 0e84 0123     		movs	r3, #1
 2415 0e86 FB60     		str	r3, [r7, #12]
2426:../FreeRTOS/tasks.c **** 
2427:../FreeRTOS/tasks.c **** 		/* Mark that a yield is pending in case the user is not using the
2428:../FreeRTOS/tasks.c **** 		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
2429:../FreeRTOS/tasks.c **** 		xYieldPending = pdTRUE;
 2416              		.loc 1 2429 0
 2417 0e88 40F20003 		movw	r3, #:lower16:xYieldPending
 2418 0e8c C0F20003 		movt	r3, #:upper16:xYieldPending
 2419 0e90 0122     		movs	r2, #1
 2420 0e92 1A60     		str	r2, [r3]
 2421 0e94 01E0     		b	.L128
 2422              	.L127:
2430:../FreeRTOS/tasks.c **** 	}
2431:../FreeRTOS/tasks.c **** 	else
2432:../FreeRTOS/tasks.c **** 	{
2433:../FreeRTOS/tasks.c **** 		xReturn = pdFALSE;
 2423              		.loc 1 2433 0
 2424 0e96 0023     		movs	r3, #0
 2425 0e98 FB60     		str	r3, [r7, #12]
 2426              	.L128:
2434:../FreeRTOS/tasks.c **** 	}
2435:../FreeRTOS/tasks.c **** 
2436:../FreeRTOS/tasks.c **** 	return xReturn;
 2427              		.loc 1 2436 0
 2428 0e9a FB68     		ldr	r3, [r7, #12]
2437:../FreeRTOS/tasks.c **** }
 2429              		.loc 1 2437 0
 2430 0e9c 1846     		mov	r0, r3
 2431 0e9e 1037     		adds	r7, r7, #16
 2432 0ea0 BD46     		mov	sp, r7
 2433              		@ sp needed
 2434 0ea2 80BD     		pop	{r7, pc}
 2435              		.cfi_endproc
 2436              	.LFE22:
 2438              		.align	2
 2439              		.global	vTaskSetTimeOutState
 2440              		.thumb
 2441              		.thumb_func
 2443              	vTaskSetTimeOutState:
 2444              	.LFB23:
2438:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2439:../FreeRTOS/tasks.c **** 
2440:../FreeRTOS/tasks.c **** void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
2441:../FreeRTOS/tasks.c **** {
 2445              		.loc 1 2441 0
 2446              		.cfi_startproc
 2447              		@ args = 0, pretend = 0, frame = 8
 2448              		@ frame_needed = 1, uses_anonymous_args = 0
 2449              		@ link register save eliminated.
 2450 0ea4 80B4     		push	{r7}
 2451              		.cfi_def_cfa_offset 4
 2452              		.cfi_offset 7, -4
 2453 0ea6 83B0     		sub	sp, sp, #12
 2454              		.cfi_def_cfa_offset 16
 2455 0ea8 00AF     		add	r7, sp, #0
 2456              		.cfi_def_cfa_register 7
 2457 0eaa 7860     		str	r0, [r7, #4]
2442:../FreeRTOS/tasks.c **** 	configASSERT( pxTimeOut );
2443:../FreeRTOS/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 2458              		.loc 1 2443 0
 2459 0eac 40F20003 		movw	r3, #:lower16:xNumOfOverflows
 2460 0eb0 C0F20003 		movt	r3, #:upper16:xNumOfOverflows
 2461 0eb4 1A68     		ldr	r2, [r3]
 2462 0eb6 7B68     		ldr	r3, [r7, #4]
 2463 0eb8 1A60     		str	r2, [r3]
2444:../FreeRTOS/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 2464              		.loc 1 2444 0
 2465 0eba 40F20003 		movw	r3, #:lower16:xTickCount
 2466 0ebe C0F20003 		movt	r3, #:upper16:xTickCount
 2467 0ec2 1A68     		ldr	r2, [r3]
 2468 0ec4 7B68     		ldr	r3, [r7, #4]
 2469 0ec6 5A60     		str	r2, [r3, #4]
2445:../FreeRTOS/tasks.c **** }
 2470              		.loc 1 2445 0
 2471 0ec8 0C37     		adds	r7, r7, #12
 2472 0eca BD46     		mov	sp, r7
 2473              		@ sp needed
 2474 0ecc 5DF8047B 		ldr	r7, [sp], #4
 2475 0ed0 7047     		bx	lr
 2476              		.cfi_endproc
 2477              	.LFE23:
 2479 0ed2 00BF     		.align	2
 2480              		.global	xTaskCheckForTimeOut
 2481              		.thumb
 2482              		.thumb_func
 2484              	xTaskCheckForTimeOut:
 2485              	.LFB24:
2446:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2447:../FreeRTOS/tasks.c **** 
2448:../FreeRTOS/tasks.c **** BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
2449:../FreeRTOS/tasks.c **** {
 2486              		.loc 1 2449 0
 2487              		.cfi_startproc
 2488              		@ args = 0, pretend = 0, frame = 16
 2489              		@ frame_needed = 1, uses_anonymous_args = 0
 2490 0ed4 80B5     		push	{r7, lr}
 2491              		.cfi_def_cfa_offset 8
 2492              		.cfi_offset 7, -8
 2493              		.cfi_offset 14, -4
 2494 0ed6 84B0     		sub	sp, sp, #16
 2495              		.cfi_def_cfa_offset 24
 2496 0ed8 00AF     		add	r7, sp, #0
 2497              		.cfi_def_cfa_register 7
 2498 0eda 7860     		str	r0, [r7, #4]
 2499 0edc 3960     		str	r1, [r7]
2450:../FreeRTOS/tasks.c **** BaseType_t xReturn;
2451:../FreeRTOS/tasks.c **** 
2452:../FreeRTOS/tasks.c **** 	configASSERT( pxTimeOut );
2453:../FreeRTOS/tasks.c **** 	configASSERT( pxTicksToWait );
2454:../FreeRTOS/tasks.c **** 
2455:../FreeRTOS/tasks.c **** 	taskENTER_CRITICAL();
 2500              		.loc 1 2455 0
 2501 0ede FFF7FEFF 		bl	vPortEnterCritical
 2502              	.LBB8:
2456:../FreeRTOS/tasks.c **** 	{
2457:../FreeRTOS/tasks.c **** 		/* Minor optimisation.  The tick count cannot change in this block. */
2458:../FreeRTOS/tasks.c **** 		const TickType_t xConstTickCount = xTickCount;
 2503              		.loc 1 2458 0
 2504 0ee2 40F20003 		movw	r3, #:lower16:xTickCount
 2505 0ee6 C0F20003 		movt	r3, #:upper16:xTickCount
 2506 0eea 1B68     		ldr	r3, [r3]
 2507 0eec BB60     		str	r3, [r7, #8]
2459:../FreeRTOS/tasks.c **** 
2460:../FreeRTOS/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
2461:../FreeRTOS/tasks.c **** 			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
2462:../FreeRTOS/tasks.c **** 			the maximum block time then the task should block indefinitely, and
2463:../FreeRTOS/tasks.c **** 			therefore never time out. */
2464:../FreeRTOS/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
 2508              		.loc 1 2464 0
 2509 0eee 3B68     		ldr	r3, [r7]
 2510 0ef0 1B68     		ldr	r3, [r3]
 2511 0ef2 B3F1FF3F 		cmp	r3, #-1
 2512 0ef6 02D1     		bne	.L132
2465:../FreeRTOS/tasks.c **** 			{
2466:../FreeRTOS/tasks.c **** 				xReturn = pdFALSE;
 2513              		.loc 1 2466 0
 2514 0ef8 0023     		movs	r3, #0
 2515 0efa FB60     		str	r3, [r7, #12]
 2516 0efc 29E0     		b	.L133
 2517              	.L132:
2467:../FreeRTOS/tasks.c **** 			}
2468:../FreeRTOS/tasks.c **** 			else /* We are not blocking indefinitely, perform the checks below. */
2469:../FreeRTOS/tasks.c **** 		#endif
2470:../FreeRTOS/tasks.c **** 
2471:../FreeRTOS/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEn
 2518              		.loc 1 2471 0
 2519 0efe 7B68     		ldr	r3, [r7, #4]
 2520 0f00 1A68     		ldr	r2, [r3]
 2521 0f02 40F20003 		movw	r3, #:lower16:xNumOfOverflows
 2522 0f06 C0F20003 		movt	r3, #:upper16:xNumOfOverflows
 2523 0f0a 1B68     		ldr	r3, [r3]
 2524 0f0c 9A42     		cmp	r2, r3
 2525 0f0e 07D0     		beq	.L134
 2526              		.loc 1 2471 0 is_stmt 0 discriminator 1
 2527 0f10 7B68     		ldr	r3, [r7, #4]
 2528 0f12 5A68     		ldr	r2, [r3, #4]
 2529 0f14 BB68     		ldr	r3, [r7, #8]
 2530 0f16 9A42     		cmp	r2, r3
 2531 0f18 02D8     		bhi	.L134
2472:../FreeRTOS/tasks.c **** 		{
2473:../FreeRTOS/tasks.c **** 			/* The tick count is greater than the time at which vTaskSetTimeout()
2474:../FreeRTOS/tasks.c **** 			was called, but has also overflowed since vTaskSetTimeOut() was called.
2475:../FreeRTOS/tasks.c **** 			It must have wrapped all the way around and gone past us again. This
2476:../FreeRTOS/tasks.c **** 			passed since vTaskSetTimeout() was called. */
2477:../FreeRTOS/tasks.c **** 			xReturn = pdTRUE;
 2532              		.loc 1 2477 0 is_stmt 1
 2533 0f1a 0123     		movs	r3, #1
 2534 0f1c FB60     		str	r3, [r7, #12]
 2535 0f1e 18E0     		b	.L133
 2536              	.L134:
2478:../FreeRTOS/tasks.c **** 		}
2479:../FreeRTOS/tasks.c **** 		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
 2537              		.loc 1 2479 0
 2538 0f20 7B68     		ldr	r3, [r7, #4]
 2539 0f22 5B68     		ldr	r3, [r3, #4]
 2540 0f24 BA68     		ldr	r2, [r7, #8]
 2541 0f26 D21A     		subs	r2, r2, r3
 2542 0f28 3B68     		ldr	r3, [r7]
 2543 0f2a 1B68     		ldr	r3, [r3]
 2544 0f2c 9A42     		cmp	r2, r3
 2545 0f2e 0ED2     		bcs	.L135
2480:../FreeRTOS/tasks.c **** 		{
2481:../FreeRTOS/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
2482:../FreeRTOS/tasks.c **** 			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
 2546              		.loc 1 2482 0
 2547 0f30 3B68     		ldr	r3, [r7]
 2548 0f32 1A68     		ldr	r2, [r3]
 2549 0f34 7B68     		ldr	r3, [r7, #4]
 2550 0f36 5968     		ldr	r1, [r3, #4]
 2551 0f38 BB68     		ldr	r3, [r7, #8]
 2552 0f3a CB1A     		subs	r3, r1, r3
 2553 0f3c 1A44     		add	r2, r2, r3
 2554 0f3e 3B68     		ldr	r3, [r7]
 2555 0f40 1A60     		str	r2, [r3]
2483:../FreeRTOS/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
 2556              		.loc 1 2483 0
 2557 0f42 7868     		ldr	r0, [r7, #4]
 2558 0f44 FFF7FEFF 		bl	vTaskSetTimeOutState
2484:../FreeRTOS/tasks.c **** 			xReturn = pdFALSE;
 2559              		.loc 1 2484 0
 2560 0f48 0023     		movs	r3, #0
 2561 0f4a FB60     		str	r3, [r7, #12]
 2562 0f4c 01E0     		b	.L133
 2563              	.L135:
2485:../FreeRTOS/tasks.c **** 		}
2486:../FreeRTOS/tasks.c **** 		else
2487:../FreeRTOS/tasks.c **** 		{
2488:../FreeRTOS/tasks.c **** 			xReturn = pdTRUE;
 2564              		.loc 1 2488 0
 2565 0f4e 0123     		movs	r3, #1
 2566 0f50 FB60     		str	r3, [r7, #12]
 2567              	.L133:
 2568              	.LBE8:
2489:../FreeRTOS/tasks.c **** 		}
2490:../FreeRTOS/tasks.c **** 	}
2491:../FreeRTOS/tasks.c **** 	taskEXIT_CRITICAL();
 2569              		.loc 1 2491 0
 2570 0f52 FFF7FEFF 		bl	vPortExitCritical
2492:../FreeRTOS/tasks.c **** 
2493:../FreeRTOS/tasks.c **** 	return xReturn;
 2571              		.loc 1 2493 0
 2572 0f56 FB68     		ldr	r3, [r7, #12]
2494:../FreeRTOS/tasks.c **** }
 2573              		.loc 1 2494 0
 2574 0f58 1846     		mov	r0, r3
 2575 0f5a 1037     		adds	r7, r7, #16
 2576 0f5c BD46     		mov	sp, r7
 2577              		@ sp needed
 2578 0f5e 80BD     		pop	{r7, pc}
 2579              		.cfi_endproc
 2580              	.LFE24:
 2582              		.align	2
 2583              		.global	vTaskMissedYield
 2584              		.thumb
 2585              		.thumb_func
 2587              	vTaskMissedYield:
 2588              	.LFB25:
2495:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2496:../FreeRTOS/tasks.c **** 
2497:../FreeRTOS/tasks.c **** void vTaskMissedYield( void )
2498:../FreeRTOS/tasks.c **** {
 2589              		.loc 1 2498 0
 2590              		.cfi_startproc
 2591              		@ args = 0, pretend = 0, frame = 0
 2592              		@ frame_needed = 1, uses_anonymous_args = 0
 2593              		@ link register save eliminated.
 2594 0f60 80B4     		push	{r7}
 2595              		.cfi_def_cfa_offset 4
 2596              		.cfi_offset 7, -4
 2597 0f62 00AF     		add	r7, sp, #0
 2598              		.cfi_def_cfa_register 7
2499:../FreeRTOS/tasks.c **** 	xYieldPending = pdTRUE;
 2599              		.loc 1 2499 0
 2600 0f64 40F20003 		movw	r3, #:lower16:xYieldPending
 2601 0f68 C0F20003 		movt	r3, #:upper16:xYieldPending
 2602 0f6c 0122     		movs	r2, #1
 2603 0f6e 1A60     		str	r2, [r3]
2500:../FreeRTOS/tasks.c **** }
 2604              		.loc 1 2500 0
 2605 0f70 BD46     		mov	sp, r7
 2606              		@ sp needed
 2607 0f72 5DF8047B 		ldr	r7, [sp], #4
 2608 0f76 7047     		bx	lr
 2609              		.cfi_endproc
 2610              	.LFE25:
 2612              		.align	2
 2613              		.thumb
 2614              		.thumb_func
 2616              	prvIdleTask:
 2617              	.LFB26:
2501:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2502:../FreeRTOS/tasks.c **** 
2503:../FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2504:../FreeRTOS/tasks.c **** 
2505:../FreeRTOS/tasks.c **** 	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
2506:../FreeRTOS/tasks.c **** 	{
2507:../FreeRTOS/tasks.c **** 	UBaseType_t uxReturn;
2508:../FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
2509:../FreeRTOS/tasks.c **** 
2510:../FreeRTOS/tasks.c **** 		if( xTask != NULL )
2511:../FreeRTOS/tasks.c **** 		{
2512:../FreeRTOS/tasks.c **** 			pxTCB = ( TCB_t * ) xTask;
2513:../FreeRTOS/tasks.c **** 			uxReturn = pxTCB->uxTaskNumber;
2514:../FreeRTOS/tasks.c **** 		}
2515:../FreeRTOS/tasks.c **** 		else
2516:../FreeRTOS/tasks.c **** 		{
2517:../FreeRTOS/tasks.c **** 			uxReturn = 0U;
2518:../FreeRTOS/tasks.c **** 		}
2519:../FreeRTOS/tasks.c **** 
2520:../FreeRTOS/tasks.c **** 		return uxReturn;
2521:../FreeRTOS/tasks.c **** 	}
2522:../FreeRTOS/tasks.c **** 
2523:../FreeRTOS/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2524:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2525:../FreeRTOS/tasks.c **** 
2526:../FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2527:../FreeRTOS/tasks.c **** 
2528:../FreeRTOS/tasks.c **** 	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
2529:../FreeRTOS/tasks.c **** 	{
2530:../FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
2531:../FreeRTOS/tasks.c **** 
2532:../FreeRTOS/tasks.c **** 		if( xTask != NULL )
2533:../FreeRTOS/tasks.c **** 		{
2534:../FreeRTOS/tasks.c **** 			pxTCB = ( TCB_t * ) xTask;
2535:../FreeRTOS/tasks.c **** 			pxTCB->uxTaskNumber = uxHandle;
2536:../FreeRTOS/tasks.c **** 		}
2537:../FreeRTOS/tasks.c **** 	}
2538:../FreeRTOS/tasks.c **** 
2539:../FreeRTOS/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2540:../FreeRTOS/tasks.c **** 
2541:../FreeRTOS/tasks.c **** /*
2542:../FreeRTOS/tasks.c ****  * -----------------------------------------------------------
2543:../FreeRTOS/tasks.c ****  * The Idle task.
2544:../FreeRTOS/tasks.c ****  * ----------------------------------------------------------
2545:../FreeRTOS/tasks.c ****  *
2546:../FreeRTOS/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
2547:../FreeRTOS/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
2548:../FreeRTOS/tasks.c ****  *
2549:../FreeRTOS/tasks.c ****  * void prvIdleTask( void *pvParameters );
2550:../FreeRTOS/tasks.c ****  *
2551:../FreeRTOS/tasks.c ****  */
2552:../FreeRTOS/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
2553:../FreeRTOS/tasks.c **** {
 2618              		.loc 1 2553 0
 2619              		.cfi_startproc
 2620              		@ args = 0, pretend = 0, frame = 8
 2621              		@ frame_needed = 1, uses_anonymous_args = 0
 2622 0f78 80B5     		push	{r7, lr}
 2623              		.cfi_def_cfa_offset 8
 2624              		.cfi_offset 7, -8
 2625              		.cfi_offset 14, -4
 2626 0f7a 82B0     		sub	sp, sp, #8
 2627              		.cfi_def_cfa_offset 16
 2628 0f7c 00AF     		add	r7, sp, #0
 2629              		.cfi_def_cfa_register 7
 2630 0f7e 7860     		str	r0, [r7, #4]
 2631              	.L140:
2554:../FreeRTOS/tasks.c **** 	/* Stop warnings. */
2555:../FreeRTOS/tasks.c **** 	( void ) pvParameters;
2556:../FreeRTOS/tasks.c **** 
2557:../FreeRTOS/tasks.c **** 	for( ;; )
2558:../FreeRTOS/tasks.c **** 	{
2559:../FreeRTOS/tasks.c **** 		/* See if any tasks have been deleted. */
2560:../FreeRTOS/tasks.c **** 		prvCheckTasksWaitingTermination();
 2632              		.loc 1 2560 0
 2633 0f80 00F09EF8 		bl	prvCheckTasksWaitingTermination
2561:../FreeRTOS/tasks.c **** 
2562:../FreeRTOS/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
2563:../FreeRTOS/tasks.c **** 		{
2564:../FreeRTOS/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
2565:../FreeRTOS/tasks.c **** 			see if any other task has become available.  If we are using
2566:../FreeRTOS/tasks.c **** 			preemption we don't need to do this as any task becoming available
2567:../FreeRTOS/tasks.c **** 			will automatically get the processor anyway. */
2568:../FreeRTOS/tasks.c **** 			taskYIELD();
2569:../FreeRTOS/tasks.c **** 		}
2570:../FreeRTOS/tasks.c **** 		#endif /* configUSE_PREEMPTION */
2571:../FreeRTOS/tasks.c **** 
2572:../FreeRTOS/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
2573:../FreeRTOS/tasks.c **** 		{
2574:../FreeRTOS/tasks.c **** 			/* When using preemption tasks of equal priority will be
2575:../FreeRTOS/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
2576:../FreeRTOS/tasks.c **** 			to run then the idle task should yield before the end of the
2577:../FreeRTOS/tasks.c **** 			timeslice.
2578:../FreeRTOS/tasks.c **** 
2579:../FreeRTOS/tasks.c **** 			A critical region is not required here as we are just reading from
2580:../FreeRTOS/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
2581:../FreeRTOS/tasks.c **** 			the ready list at the idle priority contains more than one task
2582:../FreeRTOS/tasks.c **** 			then a task other than the idle task is ready to execute. */
2583:../FreeRTOS/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 2634              		.loc 1 2583 0
 2635 0f84 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 2636 0f88 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 2637 0f8c 1B68     		ldr	r3, [r3]
 2638 0f8e 012B     		cmp	r3, #1
 2639 0f90 01D9     		bls	.L139
2584:../FreeRTOS/tasks.c **** 			{
2585:../FreeRTOS/tasks.c **** 				taskYIELD();
 2640              		.loc 1 2585 0
 2641 0f92 FFF7FEFF 		bl	vPortYield
 2642              	.L139:
2586:../FreeRTOS/tasks.c **** 			}
2587:../FreeRTOS/tasks.c **** 			else
2588:../FreeRTOS/tasks.c **** 			{
2589:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2590:../FreeRTOS/tasks.c **** 			}
2591:../FreeRTOS/tasks.c **** 		}
2592:../FreeRTOS/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
2593:../FreeRTOS/tasks.c **** 
2594:../FreeRTOS/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
2595:../FreeRTOS/tasks.c **** 		{
2596:../FreeRTOS/tasks.c **** 			extern void vApplicationIdleHook( void );
2597:../FreeRTOS/tasks.c **** 
2598:../FreeRTOS/tasks.c **** 			/* Call the user defined function from within the idle task.  This
2599:../FreeRTOS/tasks.c **** 			allows the application designer to add background functionality
2600:../FreeRTOS/tasks.c **** 			without the overhead of a separate task.
2601:../FreeRTOS/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
2602:../FreeRTOS/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
2603:../FreeRTOS/tasks.c **** 			vApplicationIdleHook();
2604:../FreeRTOS/tasks.c **** 		}
2605:../FreeRTOS/tasks.c **** 		#endif /* configUSE_IDLE_HOOK */
2606:../FreeRTOS/tasks.c **** 
2607:../FreeRTOS/tasks.c **** 		/* This conditional compilation should use inequality to 0, not equality
2608:../FreeRTOS/tasks.c **** 		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
2609:../FreeRTOS/tasks.c **** 		user defined low power mode	implementations require
2610:../FreeRTOS/tasks.c **** 		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
2611:../FreeRTOS/tasks.c **** 		#if ( configUSE_TICKLESS_IDLE != 0 )
2612:../FreeRTOS/tasks.c **** 		{
2613:../FreeRTOS/tasks.c **** 		TickType_t xExpectedIdleTime;
2614:../FreeRTOS/tasks.c **** 
2615:../FreeRTOS/tasks.c **** 			/* It is not desirable to suspend then resume the scheduler on
2616:../FreeRTOS/tasks.c **** 			each iteration of the idle task.  Therefore, a preliminary
2617:../FreeRTOS/tasks.c **** 			test of the expected idle time is performed without the
2618:../FreeRTOS/tasks.c **** 			scheduler suspended.  The result here is not necessarily
2619:../FreeRTOS/tasks.c **** 			valid. */
2620:../FreeRTOS/tasks.c **** 			xExpectedIdleTime = prvGetExpectedIdleTime();
2621:../FreeRTOS/tasks.c **** 
2622:../FreeRTOS/tasks.c **** 			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
2623:../FreeRTOS/tasks.c **** 			{
2624:../FreeRTOS/tasks.c **** 				vTaskSuspendAll();
2625:../FreeRTOS/tasks.c **** 				{
2626:../FreeRTOS/tasks.c **** 					/* Now the scheduler is suspended, the expected idle
2627:../FreeRTOS/tasks.c **** 					time can be sampled again, and this time its value can
2628:../FreeRTOS/tasks.c **** 					be used. */
2629:../FreeRTOS/tasks.c **** 					configASSERT( xNextTaskUnblockTime >= xTickCount );
2630:../FreeRTOS/tasks.c **** 					xExpectedIdleTime = prvGetExpectedIdleTime();
2631:../FreeRTOS/tasks.c **** 
2632:../FreeRTOS/tasks.c **** 					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
2633:../FreeRTOS/tasks.c **** 					{
2634:../FreeRTOS/tasks.c **** 						traceLOW_POWER_IDLE_BEGIN();
2635:../FreeRTOS/tasks.c **** 						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
2636:../FreeRTOS/tasks.c **** 						traceLOW_POWER_IDLE_END();
2637:../FreeRTOS/tasks.c **** 					}
2638:../FreeRTOS/tasks.c **** 					else
2639:../FreeRTOS/tasks.c **** 					{
2640:../FreeRTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2641:../FreeRTOS/tasks.c **** 					}
2642:../FreeRTOS/tasks.c **** 				}
2643:../FreeRTOS/tasks.c **** 				( void ) xTaskResumeAll();
2644:../FreeRTOS/tasks.c **** 			}
2645:../FreeRTOS/tasks.c **** 			else
2646:../FreeRTOS/tasks.c **** 			{
2647:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2648:../FreeRTOS/tasks.c **** 			}
2649:../FreeRTOS/tasks.c **** 		}
2650:../FreeRTOS/tasks.c **** 		#endif /* configUSE_TICKLESS_IDLE */
2651:../FreeRTOS/tasks.c **** 	}
 2643              		.loc 1 2651 0
 2644 0f96 F3E7     		b	.L140
 2645              		.cfi_endproc
 2646              	.LFE26:
 2648              		.align	2
 2649              		.thumb
 2650              		.thumb_func
 2652              	prvInitialiseTCBVariables:
 2653              	.LFB27:
2652:../FreeRTOS/tasks.c **** }
2653:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2654:../FreeRTOS/tasks.c **** 
2655:../FreeRTOS/tasks.c **** #if configUSE_TICKLESS_IDLE != 0
2656:../FreeRTOS/tasks.c **** 
2657:../FreeRTOS/tasks.c **** 	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
2658:../FreeRTOS/tasks.c **** 	{
2659:../FreeRTOS/tasks.c **** 	eSleepModeStatus eReturn = eStandardSleep;
2660:../FreeRTOS/tasks.c **** 
2661:../FreeRTOS/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
2662:../FreeRTOS/tasks.c **** 		{
2663:../FreeRTOS/tasks.c **** 			/* A task was made ready while the scheduler was suspended. */
2664:../FreeRTOS/tasks.c **** 			eReturn = eAbortSleep;
2665:../FreeRTOS/tasks.c **** 		}
2666:../FreeRTOS/tasks.c **** 		else if( xYieldPending != pdFALSE )
2667:../FreeRTOS/tasks.c **** 		{
2668:../FreeRTOS/tasks.c **** 			/* A yield was pended while the scheduler was suspended. */
2669:../FreeRTOS/tasks.c **** 			eReturn = eAbortSleep;
2670:../FreeRTOS/tasks.c **** 		}
2671:../FreeRTOS/tasks.c **** 		else
2672:../FreeRTOS/tasks.c **** 		{
2673:../FreeRTOS/tasks.c **** 			#if configUSE_TIMERS == 0
2674:../FreeRTOS/tasks.c **** 			{
2675:../FreeRTOS/tasks.c **** 				/* The idle task exists in addition to the application tasks. */
2676:../FreeRTOS/tasks.c **** 				const UBaseType_t uxNonApplicationTasks = 1;
2677:../FreeRTOS/tasks.c **** 
2678:../FreeRTOS/tasks.c **** 				/* If timers are not being used and all the tasks are in the
2679:../FreeRTOS/tasks.c **** 				suspended list (which might mean they have an infinite block
2680:../FreeRTOS/tasks.c **** 				time rather than actually being suspended) then it is safe to
2681:../FreeRTOS/tasks.c **** 				turn all clocks off and just wait for external interrupts. */
2682:../FreeRTOS/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicati
2683:../FreeRTOS/tasks.c **** 				{
2684:../FreeRTOS/tasks.c **** 					eReturn = eNoTasksWaitingTimeout;
2685:../FreeRTOS/tasks.c **** 				}
2686:../FreeRTOS/tasks.c **** 				else
2687:../FreeRTOS/tasks.c **** 				{
2688:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
2689:../FreeRTOS/tasks.c **** 				}
2690:../FreeRTOS/tasks.c **** 			}
2691:../FreeRTOS/tasks.c **** 			#endif /* configUSE_TIMERS */
2692:../FreeRTOS/tasks.c **** 		}
2693:../FreeRTOS/tasks.c **** 
2694:../FreeRTOS/tasks.c **** 		return eReturn;
2695:../FreeRTOS/tasks.c **** 	}
2696:../FreeRTOS/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2697:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2698:../FreeRTOS/tasks.c **** 
2699:../FreeRTOS/tasks.c **** static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t 
2700:../FreeRTOS/tasks.c **** {
 2654              		.loc 1 2700 0
 2655              		.cfi_startproc
 2656              		@ args = 4, pretend = 0, frame = 24
 2657              		@ frame_needed = 1, uses_anonymous_args = 0
 2658 0f98 80B5     		push	{r7, lr}
 2659              		.cfi_def_cfa_offset 8
 2660              		.cfi_offset 7, -8
 2661              		.cfi_offset 14, -4
 2662 0f9a 86B0     		sub	sp, sp, #24
 2663              		.cfi_def_cfa_offset 32
 2664 0f9c 00AF     		add	r7, sp, #0
 2665              		.cfi_def_cfa_register 7
 2666 0f9e F860     		str	r0, [r7, #12]
 2667 0fa0 B960     		str	r1, [r7, #8]
 2668 0fa2 7A60     		str	r2, [r7, #4]
 2669 0fa4 3B60     		str	r3, [r7]
2701:../FreeRTOS/tasks.c **** UBaseType_t x;
2702:../FreeRTOS/tasks.c **** 
2703:../FreeRTOS/tasks.c **** 	/* Store the task name in the TCB. */
2704:../FreeRTOS/tasks.c **** 	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 2670              		.loc 1 2704 0
 2671 0fa6 0023     		movs	r3, #0
 2672 0fa8 7B61     		str	r3, [r7, #20]
 2673 0faa 12E0     		b	.L142
 2674              	.L145:
2705:../FreeRTOS/tasks.c **** 	{
2706:../FreeRTOS/tasks.c **** 		pxTCB->pcTaskName[ x ] = pcName[ x ];
 2675              		.loc 1 2706 0
 2676 0fac BA68     		ldr	r2, [r7, #8]
 2677 0fae 7B69     		ldr	r3, [r7, #20]
 2678 0fb0 1344     		add	r3, r3, r2
 2679 0fb2 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 2680 0fb4 F968     		ldr	r1, [r7, #12]
 2681 0fb6 7B69     		ldr	r3, [r7, #20]
 2682 0fb8 0B44     		add	r3, r3, r1
 2683 0fba 3033     		adds	r3, r3, #48
 2684 0fbc 1A71     		strb	r2, [r3, #4]
2707:../FreeRTOS/tasks.c **** 
2708:../FreeRTOS/tasks.c **** 		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
2709:../FreeRTOS/tasks.c **** 		configMAX_TASK_NAME_LEN characters just in case the memory after the
2710:../FreeRTOS/tasks.c **** 		string is not accessible (extremely unlikely). */
2711:../FreeRTOS/tasks.c **** 		if( pcName[ x ] == 0x00 )
 2685              		.loc 1 2711 0
 2686 0fbe BA68     		ldr	r2, [r7, #8]
 2687 0fc0 7B69     		ldr	r3, [r7, #20]
 2688 0fc2 1344     		add	r3, r3, r2
 2689 0fc4 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2690 0fc6 002B     		cmp	r3, #0
 2691 0fc8 00D1     		bne	.L143
2712:../FreeRTOS/tasks.c **** 		{
2713:../FreeRTOS/tasks.c **** 			break;
 2692              		.loc 1 2713 0
 2693 0fca 05E0     		b	.L144
 2694              	.L143:
2704:../FreeRTOS/tasks.c **** 	{
 2695              		.loc 1 2704 0
 2696 0fcc 7B69     		ldr	r3, [r7, #20]
 2697 0fce 0133     		adds	r3, r3, #1
 2698 0fd0 7B61     		str	r3, [r7, #20]
 2699              	.L142:
2704:../FreeRTOS/tasks.c **** 	{
 2700              		.loc 1 2704 0 is_stmt 0 discriminator 1
 2701 0fd2 7B69     		ldr	r3, [r7, #20]
 2702 0fd4 0F2B     		cmp	r3, #15
 2703 0fd6 E9D9     		bls	.L145
 2704              	.L144:
2714:../FreeRTOS/tasks.c **** 		}
2715:../FreeRTOS/tasks.c **** 		else
2716:../FreeRTOS/tasks.c **** 		{
2717:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2718:../FreeRTOS/tasks.c **** 		}
2719:../FreeRTOS/tasks.c **** 	}
2720:../FreeRTOS/tasks.c **** 
2721:../FreeRTOS/tasks.c **** 	/* Ensure the name string is terminated in the case that the string length
2722:../FreeRTOS/tasks.c **** 	was greater or equal to configMAX_TASK_NAME_LEN. */
2723:../FreeRTOS/tasks.c **** 	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 2705              		.loc 1 2723 0 is_stmt 1
 2706 0fd8 FB68     		ldr	r3, [r7, #12]
 2707 0fda 0022     		movs	r2, #0
 2708 0fdc 83F84320 		strb	r2, [r3, #67]
2724:../FreeRTOS/tasks.c **** 
2725:../FreeRTOS/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
2726:../FreeRTOS/tasks.c **** 	remove the privilege bit if one is present. */
2727:../FreeRTOS/tasks.c **** 	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 2709              		.loc 1 2727 0
 2710 0fe0 7B68     		ldr	r3, [r7, #4]
 2711 0fe2 042B     		cmp	r3, #4
 2712 0fe4 01D9     		bls	.L146
2728:../FreeRTOS/tasks.c **** 	{
2729:../FreeRTOS/tasks.c **** 		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 2713              		.loc 1 2729 0
 2714 0fe6 0423     		movs	r3, #4
 2715 0fe8 7B60     		str	r3, [r7, #4]
 2716              	.L146:
2730:../FreeRTOS/tasks.c **** 	}
2731:../FreeRTOS/tasks.c **** 	else
2732:../FreeRTOS/tasks.c **** 	{
2733:../FreeRTOS/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
2734:../FreeRTOS/tasks.c **** 	}
2735:../FreeRTOS/tasks.c **** 
2736:../FreeRTOS/tasks.c **** 	pxTCB->uxPriority = uxPriority;
 2717              		.loc 1 2736 0
 2718 0fea FB68     		ldr	r3, [r7, #12]
 2719 0fec 7A68     		ldr	r2, [r7, #4]
 2720 0fee DA62     		str	r2, [r3, #44]
2737:../FreeRTOS/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
2738:../FreeRTOS/tasks.c **** 	{
2739:../FreeRTOS/tasks.c **** 		pxTCB->uxBasePriority = uxPriority;
 2721              		.loc 1 2739 0
 2722 0ff0 FB68     		ldr	r3, [r7, #12]
 2723 0ff2 7A68     		ldr	r2, [r7, #4]
 2724 0ff4 5A64     		str	r2, [r3, #68]
2740:../FreeRTOS/tasks.c **** 	}
2741:../FreeRTOS/tasks.c **** 	#endif /* configUSE_MUTEXES */
2742:../FreeRTOS/tasks.c **** 
2743:../FreeRTOS/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 2725              		.loc 1 2743 0
 2726 0ff6 FB68     		ldr	r3, [r7, #12]
 2727 0ff8 0433     		adds	r3, r3, #4
 2728 0ffa 1846     		mov	r0, r3
 2729 0ffc FFF7FEFF 		bl	vListInitialiseItem
2744:../FreeRTOS/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 2730              		.loc 1 2744 0
 2731 1000 FB68     		ldr	r3, [r7, #12]
 2732 1002 1833     		adds	r3, r3, #24
 2733 1004 1846     		mov	r0, r3
 2734 1006 FFF7FEFF 		bl	vListInitialiseItem
2745:../FreeRTOS/tasks.c **** 
2746:../FreeRTOS/tasks.c **** 	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
2747:../FreeRTOS/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
2748:../FreeRTOS/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 2735              		.loc 1 2748 0
 2736 100a FB68     		ldr	r3, [r7, #12]
 2737 100c FA68     		ldr	r2, [r7, #12]
 2738 100e 1A61     		str	r2, [r3, #16]
2749:../FreeRTOS/tasks.c **** 
2750:../FreeRTOS/tasks.c **** 	/* Event lists are always in priority order. */
2751:../FreeRTOS/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickT
 2739              		.loc 1 2751 0
 2740 1010 7B68     		ldr	r3, [r7, #4]
 2741 1012 C3F10502 		rsb	r2, r3, #5
 2742 1016 FB68     		ldr	r3, [r7, #12]
 2743 1018 9A61     		str	r2, [r3, #24]
2752:../FreeRTOS/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 2744              		.loc 1 2752 0
 2745 101a FB68     		ldr	r3, [r7, #12]
 2746 101c FA68     		ldr	r2, [r7, #12]
 2747 101e 5A62     		str	r2, [r3, #36]
2753:../FreeRTOS/tasks.c **** 
2754:../FreeRTOS/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
2755:../FreeRTOS/tasks.c **** 	{
2756:../FreeRTOS/tasks.c **** 		pxTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
2757:../FreeRTOS/tasks.c **** 	}
2758:../FreeRTOS/tasks.c **** 	#endif /* portCRITICAL_NESTING_IN_TCB */
2759:../FreeRTOS/tasks.c **** 
2760:../FreeRTOS/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
2761:../FreeRTOS/tasks.c **** 	{
2762:../FreeRTOS/tasks.c **** 		pxTCB->pxTaskTag = NULL;
2763:../FreeRTOS/tasks.c **** 	}
2764:../FreeRTOS/tasks.c **** 	#endif /* configUSE_APPLICATION_TASK_TAG */
2765:../FreeRTOS/tasks.c **** 
2766:../FreeRTOS/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
2767:../FreeRTOS/tasks.c **** 	{
2768:../FreeRTOS/tasks.c **** 		pxTCB->ulRunTimeCounter = 0UL;
2769:../FreeRTOS/tasks.c **** 	}
2770:../FreeRTOS/tasks.c **** 	#endif /* configGENERATE_RUN_TIME_STATS */
2771:../FreeRTOS/tasks.c **** 
2772:../FreeRTOS/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
2773:../FreeRTOS/tasks.c **** 	{
2774:../FreeRTOS/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
2775:../FreeRTOS/tasks.c **** 	}
2776:../FreeRTOS/tasks.c **** 	#else /* portUSING_MPU_WRAPPERS */
2777:../FreeRTOS/tasks.c **** 	{
2778:../FreeRTOS/tasks.c **** 		( void ) xRegions;
2779:../FreeRTOS/tasks.c **** 		( void ) usStackDepth;
2780:../FreeRTOS/tasks.c **** 	}
2781:../FreeRTOS/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS */
2782:../FreeRTOS/tasks.c **** 
2783:../FreeRTOS/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
2784:../FreeRTOS/tasks.c **** 	{
2785:../FreeRTOS/tasks.c **** 		/* Initialise this task's Newlib reent structure. */
2786:../FreeRTOS/tasks.c **** 		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
2787:../FreeRTOS/tasks.c **** 	}
2788:../FreeRTOS/tasks.c **** 	#endif /* configUSE_NEWLIB_REENTRANT */
2789:../FreeRTOS/tasks.c **** }
 2748              		.loc 1 2789 0
 2749 1020 1837     		adds	r7, r7, #24
 2750 1022 BD46     		mov	sp, r7
 2751              		@ sp needed
 2752 1024 80BD     		pop	{r7, pc}
 2753              		.cfi_endproc
 2754              	.LFE27:
 2756 1026 00BF     		.align	2
 2757              		.thumb
 2758              		.thumb_func
 2760              	prvInitialiseTaskLists:
 2761              	.LFB28:
2790:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2791:../FreeRTOS/tasks.c **** 
2792:../FreeRTOS/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
2793:../FreeRTOS/tasks.c **** 
2794:../FreeRTOS/tasks.c **** 	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
2795:../FreeRTOS/tasks.c **** 	{
2796:../FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
2797:../FreeRTOS/tasks.c **** 
2798:../FreeRTOS/tasks.c **** 		/* If null is passed in here then we are deleting ourselves. */
2799:../FreeRTOS/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
2800:../FreeRTOS/tasks.c **** 
2801:../FreeRTOS/tasks.c ****         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
2802:../FreeRTOS/tasks.c **** 	}
2803:../FreeRTOS/tasks.c **** 
2804:../FreeRTOS/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
2805:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2806:../FreeRTOS/tasks.c **** 
2807:../FreeRTOS/tasks.c **** static void prvInitialiseTaskLists( void )
2808:../FreeRTOS/tasks.c **** {
 2762              		.loc 1 2808 0
 2763              		.cfi_startproc
 2764              		@ args = 0, pretend = 0, frame = 8
 2765              		@ frame_needed = 1, uses_anonymous_args = 0
 2766 1028 80B5     		push	{r7, lr}
 2767              		.cfi_def_cfa_offset 8
 2768              		.cfi_offset 7, -8
 2769              		.cfi_offset 14, -4
 2770 102a 82B0     		sub	sp, sp, #8
 2771              		.cfi_def_cfa_offset 16
 2772 102c 00AF     		add	r7, sp, #0
 2773              		.cfi_def_cfa_register 7
2809:../FreeRTOS/tasks.c **** UBaseType_t uxPriority;
2810:../FreeRTOS/tasks.c **** 
2811:../FreeRTOS/tasks.c **** 	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriorit
 2774              		.loc 1 2811 0
 2775 102e 0023     		movs	r3, #0
 2776 1030 7B60     		str	r3, [r7, #4]
 2777 1032 0FE0     		b	.L148
 2778              	.L149:
2812:../FreeRTOS/tasks.c **** 	{
2813:../FreeRTOS/tasks.c **** 		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 2779              		.loc 1 2813 0 discriminator 2
 2780 1034 7A68     		ldr	r2, [r7, #4]
 2781 1036 1346     		mov	r3, r2
 2782 1038 9B00     		lsls	r3, r3, #2
 2783 103a 1344     		add	r3, r3, r2
 2784 103c 9B00     		lsls	r3, r3, #2
 2785 103e 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 2786 1042 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 2787 1046 1344     		add	r3, r3, r2
 2788 1048 1846     		mov	r0, r3
 2789 104a FFF7FEFF 		bl	vListInitialise
2811:../FreeRTOS/tasks.c **** 	{
 2790              		.loc 1 2811 0 discriminator 2
 2791 104e 7B68     		ldr	r3, [r7, #4]
 2792 1050 0133     		adds	r3, r3, #1
 2793 1052 7B60     		str	r3, [r7, #4]
 2794              	.L148:
2811:../FreeRTOS/tasks.c **** 	{
 2795              		.loc 1 2811 0 is_stmt 0 discriminator 1
 2796 1054 7B68     		ldr	r3, [r7, #4]
 2797 1056 042B     		cmp	r3, #4
 2798 1058 ECD9     		bls	.L149
2814:../FreeRTOS/tasks.c **** 	}
2815:../FreeRTOS/tasks.c **** 
2816:../FreeRTOS/tasks.c **** 	vListInitialise( &xDelayedTaskList1 );
 2799              		.loc 1 2816 0 is_stmt 1
 2800 105a 40F20000 		movw	r0, #:lower16:xDelayedTaskList1
 2801 105e C0F20000 		movt	r0, #:upper16:xDelayedTaskList1
 2802 1062 FFF7FEFF 		bl	vListInitialise
2817:../FreeRTOS/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
 2803              		.loc 1 2817 0
 2804 1066 40F20000 		movw	r0, #:lower16:xDelayedTaskList2
 2805 106a C0F20000 		movt	r0, #:upper16:xDelayedTaskList2
 2806 106e FFF7FEFF 		bl	vListInitialise
2818:../FreeRTOS/tasks.c **** 	vListInitialise( &xPendingReadyList );
 2807              		.loc 1 2818 0
 2808 1072 40F20000 		movw	r0, #:lower16:xPendingReadyList
 2809 1076 C0F20000 		movt	r0, #:upper16:xPendingReadyList
 2810 107a FFF7FEFF 		bl	vListInitialise
2819:../FreeRTOS/tasks.c **** 
2820:../FreeRTOS/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2821:../FreeRTOS/tasks.c **** 	{
2822:../FreeRTOS/tasks.c **** 		vListInitialise( &xTasksWaitingTermination );
 2811              		.loc 1 2822 0
 2812 107e 40F20000 		movw	r0, #:lower16:xTasksWaitingTermination
 2813 1082 C0F20000 		movt	r0, #:upper16:xTasksWaitingTermination
 2814 1086 FFF7FEFF 		bl	vListInitialise
2823:../FreeRTOS/tasks.c **** 	}
2824:../FreeRTOS/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
2825:../FreeRTOS/tasks.c **** 
2826:../FreeRTOS/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
2827:../FreeRTOS/tasks.c **** 	{
2828:../FreeRTOS/tasks.c **** 		vListInitialise( &xSuspendedTaskList );
 2815              		.loc 1 2828 0
 2816 108a 40F20000 		movw	r0, #:lower16:xSuspendedTaskList
 2817 108e C0F20000 		movt	r0, #:upper16:xSuspendedTaskList
 2818 1092 FFF7FEFF 		bl	vListInitialise
2829:../FreeRTOS/tasks.c **** 	}
2830:../FreeRTOS/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
2831:../FreeRTOS/tasks.c **** 
2832:../FreeRTOS/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
2833:../FreeRTOS/tasks.c **** 	using list2. */
2834:../FreeRTOS/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
 2819              		.loc 1 2834 0
 2820 1096 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2821 109a C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2822 109e 40F20002 		movw	r2, #:lower16:xDelayedTaskList1
 2823 10a2 C0F20002 		movt	r2, #:upper16:xDelayedTaskList1
 2824 10a6 1A60     		str	r2, [r3]
2835:../FreeRTOS/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 2825              		.loc 1 2835 0
 2826 10a8 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 2827 10ac C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 2828 10b0 40F20002 		movw	r2, #:lower16:xDelayedTaskList2
 2829 10b4 C0F20002 		movt	r2, #:upper16:xDelayedTaskList2
 2830 10b8 1A60     		str	r2, [r3]
2836:../FreeRTOS/tasks.c **** }
 2831              		.loc 1 2836 0
 2832 10ba 0837     		adds	r7, r7, #8
 2833 10bc BD46     		mov	sp, r7
 2834              		@ sp needed
 2835 10be 80BD     		pop	{r7, pc}
 2836              		.cfi_endproc
 2837              	.LFE28:
 2839              		.align	2
 2840              		.thumb
 2841              		.thumb_func
 2843              	prvCheckTasksWaitingTermination:
 2844              	.LFB29:
2837:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2838:../FreeRTOS/tasks.c **** 
2839:../FreeRTOS/tasks.c **** static void prvCheckTasksWaitingTermination( void )
2840:../FreeRTOS/tasks.c **** {
 2845              		.loc 1 2840 0
 2846              		.cfi_startproc
 2847              		@ args = 0, pretend = 0, frame = 8
 2848              		@ frame_needed = 1, uses_anonymous_args = 0
 2849 10c0 80B5     		push	{r7, lr}
 2850              		.cfi_def_cfa_offset 8
 2851              		.cfi_offset 7, -8
 2852              		.cfi_offset 14, -4
 2853 10c2 82B0     		sub	sp, sp, #8
 2854              		.cfi_def_cfa_offset 16
 2855 10c4 00AF     		add	r7, sp, #0
 2856              		.cfi_def_cfa_register 7
 2857              	.LBB9:
2841:../FreeRTOS/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2842:../FreeRTOS/tasks.c **** 	{
2843:../FreeRTOS/tasks.c **** 		BaseType_t xListIsEmpty;
2844:../FreeRTOS/tasks.c **** 
2845:../FreeRTOS/tasks.c **** 		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
2846:../FreeRTOS/tasks.c **** 		too often in the idle task. */
2847:../FreeRTOS/tasks.c **** 		while( uxTasksDeleted > ( UBaseType_t ) 0U )
 2858              		.loc 1 2847 0
 2859 10c6 3AE0     		b	.L151
 2860              	.L152:
2848:../FreeRTOS/tasks.c **** 		{
2849:../FreeRTOS/tasks.c **** 			vTaskSuspendAll();
 2861              		.loc 1 2849 0
 2862 10c8 FFF7FEFF 		bl	vTaskSuspendAll
2850:../FreeRTOS/tasks.c **** 			{
2851:../FreeRTOS/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 2863              		.loc 1 2851 0
 2864 10cc 40F20003 		movw	r3, #:lower16:xTasksWaitingTermination
 2865 10d0 C0F20003 		movt	r3, #:upper16:xTasksWaitingTermination
 2866 10d4 1B68     		ldr	r3, [r3]
 2867 10d6 002B     		cmp	r3, #0
 2868 10d8 14BF     		ite	ne
 2869 10da 0023     		movne	r3, #0
 2870 10dc 0123     		moveq	r3, #1
 2871 10de DBB2     		uxtb	r3, r3
 2872 10e0 7B60     		str	r3, [r7, #4]
2852:../FreeRTOS/tasks.c **** 			}
2853:../FreeRTOS/tasks.c **** 			( void ) xTaskResumeAll();
 2873              		.loc 1 2853 0
 2874 10e2 FFF7FEFF 		bl	xTaskResumeAll
2854:../FreeRTOS/tasks.c **** 
2855:../FreeRTOS/tasks.c **** 			if( xListIsEmpty == pdFALSE )
 2875              		.loc 1 2855 0
 2876 10e6 7B68     		ldr	r3, [r7, #4]
 2877 10e8 002B     		cmp	r3, #0
 2878 10ea 28D1     		bne	.L151
 2879              	.LBB10:
2856:../FreeRTOS/tasks.c **** 			{
2857:../FreeRTOS/tasks.c **** 				TCB_t *pxTCB;
2858:../FreeRTOS/tasks.c **** 
2859:../FreeRTOS/tasks.c **** 				taskENTER_CRITICAL();
 2880              		.loc 1 2859 0
 2881 10ec FFF7FEFF 		bl	vPortEnterCritical
2860:../FreeRTOS/tasks.c **** 				{
2861:../FreeRTOS/tasks.c **** 					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 2882              		.loc 1 2861 0
 2883 10f0 40F20003 		movw	r3, #:lower16:xTasksWaitingTermination
 2884 10f4 C0F20003 		movt	r3, #:upper16:xTasksWaitingTermination
 2885 10f8 DB68     		ldr	r3, [r3, #12]
 2886 10fa DB68     		ldr	r3, [r3, #12]
 2887 10fc 3B60     		str	r3, [r7]
2862:../FreeRTOS/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 2888              		.loc 1 2862 0
 2889 10fe 3B68     		ldr	r3, [r7]
 2890 1100 0433     		adds	r3, r3, #4
 2891 1102 1846     		mov	r0, r3
 2892 1104 FFF7FEFF 		bl	uxListRemove
2863:../FreeRTOS/tasks.c **** 					--uxCurrentNumberOfTasks;
 2893              		.loc 1 2863 0
 2894 1108 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 2895 110c C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 2896 1110 1B68     		ldr	r3, [r3]
 2897 1112 5A1E     		subs	r2, r3, #1
 2898 1114 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 2899 1118 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 2900 111c 1A60     		str	r2, [r3]
2864:../FreeRTOS/tasks.c **** 					--uxTasksDeleted;
 2901              		.loc 1 2864 0
 2902 111e 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 2903 1122 C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 2904 1126 1B68     		ldr	r3, [r3]
 2905 1128 5A1E     		subs	r2, r3, #1
 2906 112a 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 2907 112e C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 2908 1132 1A60     		str	r2, [r3]
2865:../FreeRTOS/tasks.c **** 				}
2866:../FreeRTOS/tasks.c **** 				taskEXIT_CRITICAL();
 2909              		.loc 1 2866 0
 2910 1134 FFF7FEFF 		bl	vPortExitCritical
2867:../FreeRTOS/tasks.c **** 
2868:../FreeRTOS/tasks.c **** 				prvDeleteTCB( pxTCB );
 2911              		.loc 1 2868 0
 2912 1138 3868     		ldr	r0, [r7]
 2913 113a 00F0B9F8 		bl	prvDeleteTCB
 2914              	.L151:
 2915              	.LBE10:
2847:../FreeRTOS/tasks.c **** 		{
 2916              		.loc 1 2847 0 discriminator 1
 2917 113e 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 2918 1142 C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 2919 1146 1B68     		ldr	r3, [r3]
 2920 1148 002B     		cmp	r3, #0
 2921 114a BDD1     		bne	.L152
 2922              	.LBE9:
2869:../FreeRTOS/tasks.c **** 			}
2870:../FreeRTOS/tasks.c **** 			else
2871:../FreeRTOS/tasks.c **** 			{
2872:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2873:../FreeRTOS/tasks.c **** 			}
2874:../FreeRTOS/tasks.c **** 		}
2875:../FreeRTOS/tasks.c **** 	}
2876:../FreeRTOS/tasks.c **** 	#endif /* vTaskDelete */
2877:../FreeRTOS/tasks.c **** }
 2923              		.loc 1 2877 0
 2924 114c 0837     		adds	r7, r7, #8
 2925 114e BD46     		mov	sp, r7
 2926              		@ sp needed
 2927 1150 80BD     		pop	{r7, pc}
 2928              		.cfi_endproc
 2929              	.LFE29:
 2931 1152 00BF     		.align	2
 2932              		.thumb
 2933              		.thumb_func
 2935              	prvAddCurrentTaskToDelayedList:
 2936              	.LFB30:
2878:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2879:../FreeRTOS/tasks.c **** 
2880:../FreeRTOS/tasks.c **** static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
2881:../FreeRTOS/tasks.c **** {
 2937              		.loc 1 2881 0
 2938              		.cfi_startproc
 2939              		@ args = 0, pretend = 0, frame = 8
 2940              		@ frame_needed = 1, uses_anonymous_args = 0
 2941 1154 80B5     		push	{r7, lr}
 2942              		.cfi_def_cfa_offset 8
 2943              		.cfi_offset 7, -8
 2944              		.cfi_offset 14, -4
 2945 1156 82B0     		sub	sp, sp, #8
 2946              		.cfi_def_cfa_offset 16
 2947 1158 00AF     		add	r7, sp, #0
 2948              		.cfi_def_cfa_register 7
 2949 115a 7860     		str	r0, [r7, #4]
2882:../FreeRTOS/tasks.c **** 	/* The list item will be inserted in wake time order. */
2883:../FreeRTOS/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 2950              		.loc 1 2883 0
 2951 115c 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2952 1160 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2953 1164 1B68     		ldr	r3, [r3]
 2954 1166 7A68     		ldr	r2, [r7, #4]
 2955 1168 5A60     		str	r2, [r3, #4]
2884:../FreeRTOS/tasks.c **** 
2885:../FreeRTOS/tasks.c **** 	if( xTimeToWake < xTickCount )
 2956              		.loc 1 2885 0
 2957 116a 40F20003 		movw	r3, #:lower16:xTickCount
 2958 116e C0F20003 		movt	r3, #:upper16:xTickCount
 2959 1172 1B68     		ldr	r3, [r3]
 2960 1174 7A68     		ldr	r2, [r7, #4]
 2961 1176 9A42     		cmp	r2, r3
 2962 1178 0FD2     		bcs	.L154
2886:../FreeRTOS/tasks.c **** 	{
2887:../FreeRTOS/tasks.c **** 		/* Wake time has overflowed.  Place this item in the overflow list. */
2888:../FreeRTOS/tasks.c **** 		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 2963              		.loc 1 2888 0
 2964 117a 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 2965 117e C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 2966 1182 1A68     		ldr	r2, [r3]
 2967 1184 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2968 1188 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2969 118c 1B68     		ldr	r3, [r3]
 2970 118e 0433     		adds	r3, r3, #4
 2971 1190 1046     		mov	r0, r2
 2972 1192 1946     		mov	r1, r3
 2973 1194 FFF7FEFF 		bl	vListInsert
 2974 1198 1CE0     		b	.L153
 2975              	.L154:
2889:../FreeRTOS/tasks.c **** 	}
2890:../FreeRTOS/tasks.c **** 	else
2891:../FreeRTOS/tasks.c **** 	{
2892:../FreeRTOS/tasks.c **** 		/* The wake time has not overflowed, so the current block list is used. */
2893:../FreeRTOS/tasks.c **** 		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 2976              		.loc 1 2893 0
 2977 119a 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2978 119e C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2979 11a2 1A68     		ldr	r2, [r3]
 2980 11a4 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2981 11a8 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2982 11ac 1B68     		ldr	r3, [r3]
 2983 11ae 0433     		adds	r3, r3, #4
 2984 11b0 1046     		mov	r0, r2
 2985 11b2 1946     		mov	r1, r3
 2986 11b4 FFF7FEFF 		bl	vListInsert
2894:../FreeRTOS/tasks.c **** 
2895:../FreeRTOS/tasks.c **** 		/* If the task entering the blocked state was placed at the head of the
2896:../FreeRTOS/tasks.c **** 		list of blocked tasks then xNextTaskUnblockTime needs to be updated
2897:../FreeRTOS/tasks.c **** 		too. */
2898:../FreeRTOS/tasks.c **** 		if( xTimeToWake < xNextTaskUnblockTime )
 2987              		.loc 1 2898 0
 2988 11b8 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 2989 11bc C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 2990 11c0 1B68     		ldr	r3, [r3]
 2991 11c2 7A68     		ldr	r2, [r7, #4]
 2992 11c4 9A42     		cmp	r2, r3
 2993 11c6 05D2     		bcs	.L153
2899:../FreeRTOS/tasks.c **** 		{
2900:../FreeRTOS/tasks.c **** 			xNextTaskUnblockTime = xTimeToWake;
 2994              		.loc 1 2900 0
 2995 11c8 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 2996 11cc C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 2997 11d0 7A68     		ldr	r2, [r7, #4]
 2998 11d2 1A60     		str	r2, [r3]
 2999              	.L153:
2901:../FreeRTOS/tasks.c **** 		}
2902:../FreeRTOS/tasks.c **** 		else
2903:../FreeRTOS/tasks.c **** 		{
2904:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2905:../FreeRTOS/tasks.c **** 		}
2906:../FreeRTOS/tasks.c **** 	}
2907:../FreeRTOS/tasks.c **** }
 3000              		.loc 1 2907 0
 3001 11d4 0837     		adds	r7, r7, #8
 3002 11d6 BD46     		mov	sp, r7
 3003              		@ sp needed
 3004 11d8 80BD     		pop	{r7, pc}
 3005              		.cfi_endproc
 3006              	.LFE30:
 3008 11da 00BF     		.align	2
 3009              		.thumb
 3010              		.thumb_func
 3012              	prvAllocateTCBAndStack:
 3013              	.LFB31:
2908:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2909:../FreeRTOS/tasks.c **** 
2910:../FreeRTOS/tasks.c **** static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuff
2911:../FreeRTOS/tasks.c **** {
 3014              		.loc 1 2911 0
 3015              		.cfi_startproc
 3016              		@ args = 0, pretend = 0, frame = 16
 3017              		@ frame_needed = 1, uses_anonymous_args = 0
 3018 11dc 80B5     		push	{r7, lr}
 3019              		.cfi_def_cfa_offset 8
 3020              		.cfi_offset 7, -8
 3021              		.cfi_offset 14, -4
 3022 11de 84B0     		sub	sp, sp, #16
 3023              		.cfi_def_cfa_offset 24
 3024 11e0 00AF     		add	r7, sp, #0
 3025              		.cfi_def_cfa_register 7
 3026 11e2 0346     		mov	r3, r0
 3027 11e4 3960     		str	r1, [r7]
 3028 11e6 FB80     		strh	r3, [r7, #6]	@ movhi
2912:../FreeRTOS/tasks.c **** TCB_t *pxNewTCB;
2913:../FreeRTOS/tasks.c **** 
2914:../FreeRTOS/tasks.c **** 	/* Allocate space for the TCB.  Where the memory comes from depends on
2915:../FreeRTOS/tasks.c **** 	the implementation of the port malloc function. */
2916:../FreeRTOS/tasks.c **** 	pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 3029              		.loc 1 2916 0
 3030 11e8 4820     		movs	r0, #72
 3031 11ea FFF7FEFF 		bl	pvPortMalloc
 3032 11ee F860     		str	r0, [r7, #12]
2917:../FreeRTOS/tasks.c **** 
2918:../FreeRTOS/tasks.c **** 	if( pxNewTCB != NULL )
 3033              		.loc 1 2918 0
 3034 11f0 FB68     		ldr	r3, [r7, #12]
 3035 11f2 002B     		cmp	r3, #0
 3036 11f4 1FD0     		beq	.L157
2919:../FreeRTOS/tasks.c **** 	{
2920:../FreeRTOS/tasks.c **** 		/* Allocate space for the stack used by the task being created.
2921:../FreeRTOS/tasks.c **** 		The base of the stack memory stored in the TCB so the task can
2922:../FreeRTOS/tasks.c **** 		be deleted later if required. */
2923:../FreeRTOS/tasks.c **** 		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof
 3037              		.loc 1 2923 0
 3038 11f6 3B68     		ldr	r3, [r7]
 3039 11f8 002B     		cmp	r3, #0
 3040 11fa 06D1     		bne	.L158
 3041              		.loc 1 2923 0 is_stmt 0 discriminator 1
 3042 11fc FB88     		ldrh	r3, [r7, #6]
 3043 11fe 9B00     		lsls	r3, r3, #2
 3044 1200 1846     		mov	r0, r3
 3045 1202 FFF7FEFF 		bl	pvPortMalloc
 3046 1206 0346     		mov	r3, r0
 3047 1208 00E0     		b	.L159
 3048              	.L158:
 3049              		.loc 1 2923 0 discriminator 2
 3050 120a 3B68     		ldr	r3, [r7]
 3051              	.L159:
 3052              		.loc 1 2923 0 discriminator 3
 3053 120c FA68     		ldr	r2, [r7, #12]
 3054 120e 1363     		str	r3, [r2, #48]
2924:../FreeRTOS/tasks.c **** 
2925:../FreeRTOS/tasks.c **** 		if( pxNewTCB->pxStack == NULL )
 3055              		.loc 1 2925 0 is_stmt 1 discriminator 3
 3056 1210 FB68     		ldr	r3, [r7, #12]
 3057 1212 1B6B     		ldr	r3, [r3, #48]
 3058 1214 002B     		cmp	r3, #0
 3059 1216 05D1     		bne	.L160
2926:../FreeRTOS/tasks.c **** 		{
2927:../FreeRTOS/tasks.c **** 			/* Could not allocate the stack.  Delete the allocated TCB. */
2928:../FreeRTOS/tasks.c **** 			vPortFree( pxNewTCB );
 3060              		.loc 1 2928 0
 3061 1218 F868     		ldr	r0, [r7, #12]
 3062 121a FFF7FEFF 		bl	vPortFree
2929:../FreeRTOS/tasks.c **** 			pxNewTCB = NULL;
 3063              		.loc 1 2929 0
 3064 121e 0023     		movs	r3, #0
 3065 1220 FB60     		str	r3, [r7, #12]
 3066 1222 08E0     		b	.L157
 3067              	.L160:
2930:../FreeRTOS/tasks.c **** 		}
2931:../FreeRTOS/tasks.c **** 		else
2932:../FreeRTOS/tasks.c **** 		{
2933:../FreeRTOS/tasks.c **** 			/* Avoid dependency on memset() if it is not required. */
2934:../FreeRTOS/tasks.c **** 			#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_ux
2935:../FreeRTOS/tasks.c **** 			{
2936:../FreeRTOS/tasks.c **** 				/* Just to help debugging. */
2937:../FreeRTOS/tasks.c **** 				( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeo
 3068              		.loc 1 2937 0
 3069 1224 FB68     		ldr	r3, [r7, #12]
 3070 1226 1A6B     		ldr	r2, [r3, #48]
 3071 1228 FB88     		ldrh	r3, [r7, #6]
 3072 122a 9B00     		lsls	r3, r3, #2
 3073 122c 1046     		mov	r0, r2
 3074 122e A521     		movs	r1, #165
 3075 1230 1A46     		mov	r2, r3
 3076 1232 FFF7FEFF 		bl	memset
 3077              	.L157:
2938:../FreeRTOS/tasks.c **** 			}
2939:../FreeRTOS/tasks.c **** 			#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( I
2940:../FreeRTOS/tasks.c **** 		}
2941:../FreeRTOS/tasks.c **** 	}
2942:../FreeRTOS/tasks.c **** 
2943:../FreeRTOS/tasks.c **** 	return pxNewTCB;
 3078              		.loc 1 2943 0
 3079 1236 FB68     		ldr	r3, [r7, #12]
2944:../FreeRTOS/tasks.c **** }
 3080              		.loc 1 2944 0
 3081 1238 1846     		mov	r0, r3
 3082 123a 1037     		adds	r7, r7, #16
 3083 123c BD46     		mov	sp, r7
 3084              		@ sp needed
 3085 123e 80BD     		pop	{r7, pc}
 3086              		.cfi_endproc
 3087              	.LFE31:
 3089              		.align	2
 3090              		.thumb
 3091              		.thumb_func
 3093              	prvTaskCheckFreeStackSpace:
 3094              	.LFB32:
2945:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2946:../FreeRTOS/tasks.c **** 
2947:../FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2948:../FreeRTOS/tasks.c **** 
2949:../FreeRTOS/tasks.c **** 	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, e
2950:../FreeRTOS/tasks.c **** 	{
2951:../FreeRTOS/tasks.c **** 	volatile TCB_t *pxNextTCB, *pxFirstTCB;
2952:../FreeRTOS/tasks.c **** 	UBaseType_t uxTask = 0;
2953:../FreeRTOS/tasks.c **** 
2954:../FreeRTOS/tasks.c **** 		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
2955:../FreeRTOS/tasks.c **** 		{
2956:../FreeRTOS/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2957:../FreeRTOS/tasks.c **** 
2958:../FreeRTOS/tasks.c **** 			/* Populate an TaskStatus_t structure within the
2959:../FreeRTOS/tasks.c **** 			pxTaskStatusArray array for each task that is referenced from
2960:../FreeRTOS/tasks.c **** 			pxList.  See the definition of TaskStatus_t in task.h for the
2961:../FreeRTOS/tasks.c **** 			meaning of each TaskStatus_t structure member. */
2962:../FreeRTOS/tasks.c **** 			do
2963:../FreeRTOS/tasks.c **** 			{
2964:../FreeRTOS/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2965:../FreeRTOS/tasks.c **** 
2966:../FreeRTOS/tasks.c **** 				pxTaskStatusArray[ uxTask ].xHandle = ( TaskHandle_t ) pxNextTCB;
2967:../FreeRTOS/tasks.c **** 				pxTaskStatusArray[ uxTask ].pcTaskName = ( const char * ) &( pxNextTCB->pcTaskName [ 0 ] );
2968:../FreeRTOS/tasks.c **** 				pxTaskStatusArray[ uxTask ].xTaskNumber = pxNextTCB->uxTCBNumber;
2969:../FreeRTOS/tasks.c **** 				pxTaskStatusArray[ uxTask ].eCurrentState = eState;
2970:../FreeRTOS/tasks.c **** 				pxTaskStatusArray[ uxTask ].uxCurrentPriority = pxNextTCB->uxPriority;
2971:../FreeRTOS/tasks.c **** 
2972:../FreeRTOS/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
2973:../FreeRTOS/tasks.c **** 				{
2974:../FreeRTOS/tasks.c **** 					/* If the task is in the suspended list then there is a chance
2975:../FreeRTOS/tasks.c **** 					it is actually just blocked indefinitely - so really it should
2976:../FreeRTOS/tasks.c **** 					be reported as being in the Blocked state. */
2977:../FreeRTOS/tasks.c **** 					if( eState == eSuspended )
2978:../FreeRTOS/tasks.c **** 					{
2979:../FreeRTOS/tasks.c **** 						if( listLIST_ITEM_CONTAINER( &( pxNextTCB->xEventListItem ) ) != NULL )
2980:../FreeRTOS/tasks.c **** 						{
2981:../FreeRTOS/tasks.c **** 							pxTaskStatusArray[ uxTask ].eCurrentState = eBlocked;
2982:../FreeRTOS/tasks.c **** 						}
2983:../FreeRTOS/tasks.c **** 					}
2984:../FreeRTOS/tasks.c **** 				}
2985:../FreeRTOS/tasks.c **** 				#endif /* INCLUDE_vTaskSuspend */
2986:../FreeRTOS/tasks.c **** 
2987:../FreeRTOS/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
2988:../FreeRTOS/tasks.c **** 				{
2989:../FreeRTOS/tasks.c **** 					pxTaskStatusArray[ uxTask ].uxBasePriority = pxNextTCB->uxBasePriority;
2990:../FreeRTOS/tasks.c **** 				}
2991:../FreeRTOS/tasks.c **** 				#else
2992:../FreeRTOS/tasks.c **** 				{
2993:../FreeRTOS/tasks.c **** 					pxTaskStatusArray[ uxTask ].uxBasePriority = 0;
2994:../FreeRTOS/tasks.c **** 				}
2995:../FreeRTOS/tasks.c **** 				#endif
2996:../FreeRTOS/tasks.c **** 
2997:../FreeRTOS/tasks.c **** 				#if ( configGENERATE_RUN_TIME_STATS == 1 )
2998:../FreeRTOS/tasks.c **** 				{
2999:../FreeRTOS/tasks.c **** 					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = pxNextTCB->ulRunTimeCounter;
3000:../FreeRTOS/tasks.c **** 				}
3001:../FreeRTOS/tasks.c **** 				#else
3002:../FreeRTOS/tasks.c **** 				{
3003:../FreeRTOS/tasks.c **** 					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = 0;
3004:../FreeRTOS/tasks.c **** 				}
3005:../FreeRTOS/tasks.c **** 				#endif
3006:../FreeRTOS/tasks.c **** 
3007:../FreeRTOS/tasks.c **** 				#if ( portSTACK_GROWTH > 0 )
3008:../FreeRTOS/tasks.c **** 				{
3009:../FreeRTOS/tasks.c **** 					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) p
3010:../FreeRTOS/tasks.c **** 				}
3011:../FreeRTOS/tasks.c **** 				#else
3012:../FreeRTOS/tasks.c **** 				{
3013:../FreeRTOS/tasks.c **** 					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) p
3014:../FreeRTOS/tasks.c **** 				}
3015:../FreeRTOS/tasks.c **** 				#endif
3016:../FreeRTOS/tasks.c **** 
3017:../FreeRTOS/tasks.c **** 				uxTask++;
3018:../FreeRTOS/tasks.c **** 
3019:../FreeRTOS/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
3020:../FreeRTOS/tasks.c **** 		}
3021:../FreeRTOS/tasks.c **** 		else
3022:../FreeRTOS/tasks.c **** 		{
3023:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3024:../FreeRTOS/tasks.c **** 		}
3025:../FreeRTOS/tasks.c **** 
3026:../FreeRTOS/tasks.c **** 		return uxTask;
3027:../FreeRTOS/tasks.c **** 	}
3028:../FreeRTOS/tasks.c **** 
3029:../FreeRTOS/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3030:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3031:../FreeRTOS/tasks.c **** 
3032:../FreeRTOS/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
3033:../FreeRTOS/tasks.c **** 
3034:../FreeRTOS/tasks.c **** 	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
3035:../FreeRTOS/tasks.c **** 	{
 3095              		.loc 1 3035 0
 3096              		.cfi_startproc
 3097              		@ args = 0, pretend = 0, frame = 16
 3098              		@ frame_needed = 1, uses_anonymous_args = 0
 3099              		@ link register save eliminated.
 3100 1240 80B4     		push	{r7}
 3101              		.cfi_def_cfa_offset 4
 3102              		.cfi_offset 7, -4
 3103 1242 85B0     		sub	sp, sp, #20
 3104              		.cfi_def_cfa_offset 24
 3105 1244 00AF     		add	r7, sp, #0
 3106              		.cfi_def_cfa_register 7
 3107 1246 7860     		str	r0, [r7, #4]
3036:../FreeRTOS/tasks.c **** 	uint32_t ulCount = 0U;
 3108              		.loc 1 3036 0
 3109 1248 0023     		movs	r3, #0
 3110 124a FB60     		str	r3, [r7, #12]
3037:../FreeRTOS/tasks.c **** 
3038:../FreeRTOS/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
 3111              		.loc 1 3038 0
 3112 124c 05E0     		b	.L163
 3113              	.L164:
3039:../FreeRTOS/tasks.c **** 		{
3040:../FreeRTOS/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
 3114              		.loc 1 3040 0
 3115 124e 7B68     		ldr	r3, [r7, #4]
 3116 1250 0133     		adds	r3, r3, #1
 3117 1252 7B60     		str	r3, [r7, #4]
3041:../FreeRTOS/tasks.c **** 			ulCount++;
 3118              		.loc 1 3041 0
 3119 1254 FB68     		ldr	r3, [r7, #12]
 3120 1256 0133     		adds	r3, r3, #1
 3121 1258 FB60     		str	r3, [r7, #12]
 3122              	.L163:
3038:../FreeRTOS/tasks.c **** 		{
 3123              		.loc 1 3038 0 discriminator 1
 3124 125a 7B68     		ldr	r3, [r7, #4]
 3125 125c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 3126 125e A52B     		cmp	r3, #165
 3127 1260 F5D0     		beq	.L164
3042:../FreeRTOS/tasks.c **** 		}
3043:../FreeRTOS/tasks.c **** 
3044:../FreeRTOS/tasks.c **** 		ulCount /= ( uint32_t ) sizeof( StackType_t );
 3128              		.loc 1 3044 0
 3129 1262 FB68     		ldr	r3, [r7, #12]
 3130 1264 9B08     		lsrs	r3, r3, #2
 3131 1266 FB60     		str	r3, [r7, #12]
3045:../FreeRTOS/tasks.c **** 
3046:../FreeRTOS/tasks.c **** 		return ( uint16_t ) ulCount;
 3132              		.loc 1 3046 0
 3133 1268 FB68     		ldr	r3, [r7, #12]
 3134 126a 9BB2     		uxth	r3, r3
3047:../FreeRTOS/tasks.c **** 	}
 3135              		.loc 1 3047 0
 3136 126c 1846     		mov	r0, r3
 3137 126e 1437     		adds	r7, r7, #20
 3138 1270 BD46     		mov	sp, r7
 3139              		@ sp needed
 3140 1272 5DF8047B 		ldr	r7, [sp], #4
 3141 1276 7047     		bx	lr
 3142              		.cfi_endproc
 3143              	.LFE32:
 3145              		.align	2
 3146              		.global	uxTaskGetStackHighWaterMark
 3147              		.thumb
 3148              		.thumb_func
 3150              	uxTaskGetStackHighWaterMark:
 3151              	.LFB33:
3048:../FreeRTOS/tasks.c **** 
3049:../FreeRTOS/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
3050:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3051:../FreeRTOS/tasks.c **** 
3052:../FreeRTOS/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
3053:../FreeRTOS/tasks.c **** 
3054:../FreeRTOS/tasks.c **** 	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
3055:../FreeRTOS/tasks.c **** 	{
 3152              		.loc 1 3055 0
 3153              		.cfi_startproc
 3154              		@ args = 0, pretend = 0, frame = 24
 3155              		@ frame_needed = 1, uses_anonymous_args = 0
 3156 1278 80B5     		push	{r7, lr}
 3157              		.cfi_def_cfa_offset 8
 3158              		.cfi_offset 7, -8
 3159              		.cfi_offset 14, -4
 3160 127a 86B0     		sub	sp, sp, #24
 3161              		.cfi_def_cfa_offset 32
 3162 127c 00AF     		add	r7, sp, #0
 3163              		.cfi_def_cfa_register 7
 3164 127e 7860     		str	r0, [r7, #4]
3056:../FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
3057:../FreeRTOS/tasks.c **** 	uint8_t *pucEndOfStack;
3058:../FreeRTOS/tasks.c **** 	UBaseType_t uxReturn;
3059:../FreeRTOS/tasks.c **** 
3060:../FreeRTOS/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
 3165              		.loc 1 3060 0
 3166 1280 7B68     		ldr	r3, [r7, #4]
 3167 1282 002B     		cmp	r3, #0
 3168 1284 05D1     		bne	.L167
 3169              		.loc 1 3060 0 is_stmt 0 discriminator 1
 3170 1286 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3171 128a C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3172 128e 1B68     		ldr	r3, [r3]
 3173 1290 00E0     		b	.L168
 3174              	.L167:
 3175              		.loc 1 3060 0 discriminator 2
 3176 1292 7B68     		ldr	r3, [r7, #4]
 3177              	.L168:
 3178              		.loc 1 3060 0 discriminator 3
 3179 1294 7B61     		str	r3, [r7, #20]
3061:../FreeRTOS/tasks.c **** 
3062:../FreeRTOS/tasks.c **** 		#if portSTACK_GROWTH < 0
3063:../FreeRTOS/tasks.c **** 		{
3064:../FreeRTOS/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
 3180              		.loc 1 3064 0 is_stmt 1 discriminator 3
 3181 1296 7B69     		ldr	r3, [r7, #20]
 3182 1298 1B6B     		ldr	r3, [r3, #48]
 3183 129a 3B61     		str	r3, [r7, #16]
3065:../FreeRTOS/tasks.c **** 		}
3066:../FreeRTOS/tasks.c **** 		#else
3067:../FreeRTOS/tasks.c **** 		{
3068:../FreeRTOS/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
3069:../FreeRTOS/tasks.c **** 		}
3070:../FreeRTOS/tasks.c **** 		#endif
3071:../FreeRTOS/tasks.c **** 
3072:../FreeRTOS/tasks.c **** 		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
 3184              		.loc 1 3072 0 discriminator 3
 3185 129c 3869     		ldr	r0, [r7, #16]
 3186 129e FFF7CFFF 		bl	prvTaskCheckFreeStackSpace
 3187 12a2 0346     		mov	r3, r0
 3188 12a4 FB60     		str	r3, [r7, #12]
3073:../FreeRTOS/tasks.c **** 
3074:../FreeRTOS/tasks.c **** 		return uxReturn;
 3189              		.loc 1 3074 0 discriminator 3
 3190 12a6 FB68     		ldr	r3, [r7, #12]
3075:../FreeRTOS/tasks.c **** 	}
 3191              		.loc 1 3075 0 discriminator 3
 3192 12a8 1846     		mov	r0, r3
 3193 12aa 1837     		adds	r7, r7, #24
 3194 12ac BD46     		mov	sp, r7
 3195              		@ sp needed
 3196 12ae 80BD     		pop	{r7, pc}
 3197              		.cfi_endproc
 3198              	.LFE33:
 3200              		.align	2
 3201              		.thumb
 3202              		.thumb_func
 3204              	prvDeleteTCB:
 3205              	.LFB34:
3076:../FreeRTOS/tasks.c **** 
3077:../FreeRTOS/tasks.c **** #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
3078:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3079:../FreeRTOS/tasks.c **** 
3080:../FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
3081:../FreeRTOS/tasks.c **** 
3082:../FreeRTOS/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB )
3083:../FreeRTOS/tasks.c **** 	{
 3206              		.loc 1 3083 0
 3207              		.cfi_startproc
 3208              		@ args = 0, pretend = 0, frame = 8
 3209              		@ frame_needed = 1, uses_anonymous_args = 0
 3210 12b0 80B5     		push	{r7, lr}
 3211              		.cfi_def_cfa_offset 8
 3212              		.cfi_offset 7, -8
 3213              		.cfi_offset 14, -4
 3214 12b2 82B0     		sub	sp, sp, #8
 3215              		.cfi_def_cfa_offset 16
 3216 12b4 00AF     		add	r7, sp, #0
 3217              		.cfi_def_cfa_register 7
 3218 12b6 7860     		str	r0, [r7, #4]
3084:../FreeRTOS/tasks.c **** 		/* This call is required specifically for the TriCore port.  It must be
3085:../FreeRTOS/tasks.c **** 		above the vPortFree() calls.  The call is also used by ports/demos that
3086:../FreeRTOS/tasks.c **** 		want to allocate and clean RAM statically. */
3087:../FreeRTOS/tasks.c **** 		portCLEAN_UP_TCB( pxTCB );
3088:../FreeRTOS/tasks.c **** 
3089:../FreeRTOS/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up
3090:../FreeRTOS/tasks.c **** 		to the task to free any memory allocated at the application level. */
3091:../FreeRTOS/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
3092:../FreeRTOS/tasks.c **** 		{
3093:../FreeRTOS/tasks.c **** 			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
3094:../FreeRTOS/tasks.c **** 		}
3095:../FreeRTOS/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
3096:../FreeRTOS/tasks.c **** 		vPortFreeAligned( pxTCB->pxStack );
 3219              		.loc 1 3096 0
 3220 12b8 7B68     		ldr	r3, [r7, #4]
 3221 12ba 1B6B     		ldr	r3, [r3, #48]
 3222 12bc 1846     		mov	r0, r3
 3223 12be FFF7FEFF 		bl	vPortFree
3097:../FreeRTOS/tasks.c **** 		vPortFree( pxTCB );
 3224              		.loc 1 3097 0
 3225 12c2 7868     		ldr	r0, [r7, #4]
 3226 12c4 FFF7FEFF 		bl	vPortFree
3098:../FreeRTOS/tasks.c **** 	}
 3227              		.loc 1 3098 0
 3228 12c8 0837     		adds	r7, r7, #8
 3229 12ca BD46     		mov	sp, r7
 3230              		@ sp needed
 3231 12cc 80BD     		pop	{r7, pc}
 3232              		.cfi_endproc
 3233              	.LFE34:
 3235 12ce 00BF     		.align	2
 3236              		.thumb
 3237              		.thumb_func
 3239              	prvResetNextTaskUnblockTime:
 3240              	.LFB35:
3099:../FreeRTOS/tasks.c **** 
3100:../FreeRTOS/tasks.c **** #endif /* INCLUDE_vTaskDelete */
3101:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3102:../FreeRTOS/tasks.c **** 
3103:../FreeRTOS/tasks.c **** static void prvResetNextTaskUnblockTime( void )
3104:../FreeRTOS/tasks.c **** {
 3241              		.loc 1 3104 0
 3242              		.cfi_startproc
 3243              		@ args = 0, pretend = 0, frame = 8
 3244              		@ frame_needed = 1, uses_anonymous_args = 0
 3245              		@ link register save eliminated.
 3246 12d0 80B4     		push	{r7}
 3247              		.cfi_def_cfa_offset 4
 3248              		.cfi_offset 7, -4
 3249 12d2 83B0     		sub	sp, sp, #12
 3250              		.cfi_def_cfa_offset 16
 3251 12d4 00AF     		add	r7, sp, #0
 3252              		.cfi_def_cfa_register 7
3105:../FreeRTOS/tasks.c **** TCB_t *pxTCB;
3106:../FreeRTOS/tasks.c **** 
3107:../FreeRTOS/tasks.c **** 	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 3253              		.loc 1 3107 0
 3254 12d6 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 3255 12da C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 3256 12de 1B68     		ldr	r3, [r3]
 3257 12e0 1B68     		ldr	r3, [r3]
 3258 12e2 002B     		cmp	r3, #0
 3259 12e4 01D1     		bne	.L172
 3260              		.loc 1 3107 0 is_stmt 0 discriminator 1
 3261 12e6 0123     		movs	r3, #1
 3262 12e8 00E0     		b	.L173
 3263              	.L172:
 3264              		.loc 1 3107 0 discriminator 2
 3265 12ea 0023     		movs	r3, #0
 3266              	.L173:
 3267              		.loc 1 3107 0 discriminator 3
 3268 12ec 002B     		cmp	r3, #0
 3269 12ee 07D0     		beq	.L174
3108:../FreeRTOS/tasks.c **** 	{
3109:../FreeRTOS/tasks.c **** 		/* The new current delayed list is empty.  Set
3110:../FreeRTOS/tasks.c **** 		xNextTaskUnblockTime to the maximum possible value so it is
3111:../FreeRTOS/tasks.c **** 		extremely unlikely that the
3112:../FreeRTOS/tasks.c **** 		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
3113:../FreeRTOS/tasks.c **** 		there is an item in the delayed list. */
3114:../FreeRTOS/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;
 3270              		.loc 1 3114 0 is_stmt 1
 3271 12f0 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 3272 12f4 C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 3273 12f8 4FF0FF32 		mov	r2, #-1
 3274 12fc 1A60     		str	r2, [r3]
 3275 12fe 0EE0     		b	.L171
 3276              	.L174:
3115:../FreeRTOS/tasks.c **** 	}
3116:../FreeRTOS/tasks.c **** 	else
3117:../FreeRTOS/tasks.c **** 	{
3118:../FreeRTOS/tasks.c **** 		/* The new current delayed list is not empty, get the value of
3119:../FreeRTOS/tasks.c **** 		the item at the head of the delayed list.  This is the time at
3120:../FreeRTOS/tasks.c **** 		which the task at the head of the delayed list should be removed
3121:../FreeRTOS/tasks.c **** 		from the Blocked state. */
3122:../FreeRTOS/tasks.c **** 		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 3277              		.loc 1 3122 0
 3278 1300 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 3279 1304 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 3280 1308 1B68     		ldr	r3, [r3]
 3281 130a DB68     		ldr	r3, [r3, #12]
 3282 130c DB68     		ldr	r3, [r3, #12]
 3283 130e 7B60     		str	r3, [r7, #4]
3123:../FreeRTOS/tasks.c **** 		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
 3284              		.loc 1 3123 0
 3285 1310 7B68     		ldr	r3, [r7, #4]
 3286 1312 5A68     		ldr	r2, [r3, #4]
 3287 1314 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 3288 1318 C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 3289 131c 1A60     		str	r2, [r3]
 3290              	.L171:
3124:../FreeRTOS/tasks.c **** 	}
3125:../FreeRTOS/tasks.c **** }
 3291              		.loc 1 3125 0
 3292 131e 0C37     		adds	r7, r7, #12
 3293 1320 BD46     		mov	sp, r7
 3294              		@ sp needed
 3295 1322 5DF8047B 		ldr	r7, [sp], #4
 3296 1326 7047     		bx	lr
 3297              		.cfi_endproc
 3298              	.LFE35:
 3300              		.align	2
 3301              		.global	xTaskGetCurrentTaskHandle
 3302              		.thumb
 3303              		.thumb_func
 3305              	xTaskGetCurrentTaskHandle:
 3306              	.LFB36:
3126:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3127:../FreeRTOS/tasks.c **** 
3128:../FreeRTOS/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
3129:../FreeRTOS/tasks.c **** 
3130:../FreeRTOS/tasks.c **** 	TaskHandle_t xTaskGetCurrentTaskHandle( void )
3131:../FreeRTOS/tasks.c **** 	{
 3307              		.loc 1 3131 0
 3308              		.cfi_startproc
 3309              		@ args = 0, pretend = 0, frame = 8
 3310              		@ frame_needed = 1, uses_anonymous_args = 0
 3311              		@ link register save eliminated.
 3312 1328 80B4     		push	{r7}
 3313              		.cfi_def_cfa_offset 4
 3314              		.cfi_offset 7, -4
 3315 132a 83B0     		sub	sp, sp, #12
 3316              		.cfi_def_cfa_offset 16
 3317 132c 00AF     		add	r7, sp, #0
 3318              		.cfi_def_cfa_register 7
3132:../FreeRTOS/tasks.c **** 	TaskHandle_t xReturn;
3133:../FreeRTOS/tasks.c **** 
3134:../FreeRTOS/tasks.c **** 		/* A critical section is not required as this is not called from
3135:../FreeRTOS/tasks.c **** 		an interrupt and the current TCB will always be the same for any
3136:../FreeRTOS/tasks.c **** 		individual execution thread. */
3137:../FreeRTOS/tasks.c **** 		xReturn = pxCurrentTCB;
 3319              		.loc 1 3137 0
 3320 132e 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3321 1332 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3322 1336 1B68     		ldr	r3, [r3]
 3323 1338 7B60     		str	r3, [r7, #4]
3138:../FreeRTOS/tasks.c **** 
3139:../FreeRTOS/tasks.c **** 		return xReturn;
 3324              		.loc 1 3139 0
 3325 133a 7B68     		ldr	r3, [r7, #4]
3140:../FreeRTOS/tasks.c **** 	}
 3326              		.loc 1 3140 0
 3327 133c 1846     		mov	r0, r3
 3328 133e 0C37     		adds	r7, r7, #12
 3329 1340 BD46     		mov	sp, r7
 3330              		@ sp needed
 3331 1342 5DF8047B 		ldr	r7, [sp], #4
 3332 1346 7047     		bx	lr
 3333              		.cfi_endproc
 3334              	.LFE36:
 3336              		.align	2
 3337              		.global	vTaskPriorityInherit
 3338              		.thumb
 3339              		.thumb_func
 3341              	vTaskPriorityInherit:
 3342              	.LFB37:
3141:../FreeRTOS/tasks.c **** 
3142:../FreeRTOS/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
3143:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3144:../FreeRTOS/tasks.c **** 
3145:../FreeRTOS/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
3146:../FreeRTOS/tasks.c **** 
3147:../FreeRTOS/tasks.c **** 	BaseType_t xTaskGetSchedulerState( void )
3148:../FreeRTOS/tasks.c **** 	{
3149:../FreeRTOS/tasks.c **** 	BaseType_t xReturn;
3150:../FreeRTOS/tasks.c **** 
3151:../FreeRTOS/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
3152:../FreeRTOS/tasks.c **** 		{
3153:../FreeRTOS/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
3154:../FreeRTOS/tasks.c **** 		}
3155:../FreeRTOS/tasks.c **** 		else
3156:../FreeRTOS/tasks.c **** 		{
3157:../FreeRTOS/tasks.c **** 			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
3158:../FreeRTOS/tasks.c **** 			{
3159:../FreeRTOS/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
3160:../FreeRTOS/tasks.c **** 			}
3161:../FreeRTOS/tasks.c **** 			else
3162:../FreeRTOS/tasks.c **** 			{
3163:../FreeRTOS/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
3164:../FreeRTOS/tasks.c **** 			}
3165:../FreeRTOS/tasks.c **** 		}
3166:../FreeRTOS/tasks.c **** 
3167:../FreeRTOS/tasks.c **** 		return xReturn;
3168:../FreeRTOS/tasks.c **** 	}
3169:../FreeRTOS/tasks.c **** 
3170:../FreeRTOS/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
3171:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3172:../FreeRTOS/tasks.c **** 
3173:../FreeRTOS/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3174:../FreeRTOS/tasks.c **** 
3175:../FreeRTOS/tasks.c **** 	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
3176:../FreeRTOS/tasks.c **** 	{
 3343              		.loc 1 3176 0
 3344              		.cfi_startproc
 3345              		@ args = 0, pretend = 0, frame = 16
 3346              		@ frame_needed = 1, uses_anonymous_args = 0
 3347 1348 80B5     		push	{r7, lr}
 3348              		.cfi_def_cfa_offset 8
 3349              		.cfi_offset 7, -8
 3350              		.cfi_offset 14, -4
 3351 134a 84B0     		sub	sp, sp, #16
 3352              		.cfi_def_cfa_offset 24
 3353 134c 00AF     		add	r7, sp, #0
 3354              		.cfi_def_cfa_register 7
 3355 134e 7860     		str	r0, [r7, #4]
3177:../FreeRTOS/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
 3356              		.loc 1 3177 0
 3357 1350 7B68     		ldr	r3, [r7, #4]
 3358 1352 FB60     		str	r3, [r7, #12]
3178:../FreeRTOS/tasks.c **** 
3179:../FreeRTOS/tasks.c **** 		/* If the mutex was given back by an interrupt while the queue was
3180:../FreeRTOS/tasks.c **** 		locked then the mutex holder might now be NULL. */
3181:../FreeRTOS/tasks.c **** 		if( pxMutexHolder != NULL )
 3359              		.loc 1 3181 0
 3360 1354 7B68     		ldr	r3, [r7, #4]
 3361 1356 002B     		cmp	r3, #0
 3362 1358 62D0     		beq	.L178
3182:../FreeRTOS/tasks.c **** 		{
3183:../FreeRTOS/tasks.c **** 			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 3363              		.loc 1 3183 0
 3364 135a FB68     		ldr	r3, [r7, #12]
 3365 135c DA6A     		ldr	r2, [r3, #44]
 3366 135e 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3367 1362 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3368 1366 1B68     		ldr	r3, [r3]
 3369 1368 DB6A     		ldr	r3, [r3, #44]
 3370 136a 9A42     		cmp	r2, r3
 3371 136c 58D2     		bcs	.L178
3184:../FreeRTOS/tasks.c **** 			{
3185:../FreeRTOS/tasks.c **** 				/* Adjust the mutex holder state to account for its new
3186:../FreeRTOS/tasks.c **** 				priority.  Only reset the event list item value if the value is
3187:../FreeRTOS/tasks.c **** 				not	being used for anything else. */
3188:../FreeRTOS/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE 
 3372              		.loc 1 3188 0
 3373 136e FB68     		ldr	r3, [r7, #12]
 3374 1370 9B69     		ldr	r3, [r3, #24]
 3375 1372 002B     		cmp	r3, #0
 3376 1374 09DB     		blt	.L180
3189:../FreeRTOS/tasks.c **** 				{
3190:../FreeRTOS/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( T
 3377              		.loc 1 3190 0
 3378 1376 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3379 137a C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3380 137e 1B68     		ldr	r3, [r3]
 3381 1380 DB6A     		ldr	r3, [r3, #44]
 3382 1382 C3F10502 		rsb	r2, r3, #5
 3383 1386 FB68     		ldr	r3, [r7, #12]
 3384 1388 9A61     		str	r2, [r3, #24]
 3385              	.L180:
3191:../FreeRTOS/tasks.c **** 				}
3192:../FreeRTOS/tasks.c **** 				else
3193:../FreeRTOS/tasks.c **** 				{
3194:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3195:../FreeRTOS/tasks.c **** 				}
3196:../FreeRTOS/tasks.c **** 
3197:../FreeRTOS/tasks.c **** 				/* If the task being modified is in the ready state it will need to
3198:../FreeRTOS/tasks.c **** 				be moved into a new list. */
3199:../FreeRTOS/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericLis
 3386              		.loc 1 3199 0
 3387 138a FB68     		ldr	r3, [r7, #12]
 3388 138c 5969     		ldr	r1, [r3, #20]
 3389 138e FB68     		ldr	r3, [r7, #12]
 3390 1390 DA6A     		ldr	r2, [r3, #44]
 3391 1392 1346     		mov	r3, r2
 3392 1394 9B00     		lsls	r3, r3, #2
 3393 1396 1344     		add	r3, r3, r2
 3394 1398 9B00     		lsls	r3, r3, #2
 3395 139a 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 3396 139e C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 3397 13a2 1344     		add	r3, r3, r2
 3398 13a4 9942     		cmp	r1, r3
 3399 13a6 01D1     		bne	.L181
 3400              		.loc 1 3199 0 is_stmt 0 discriminator 1
 3401 13a8 0123     		movs	r3, #1
 3402 13aa 00E0     		b	.L182
 3403              	.L181:
 3404              		.loc 1 3199 0 discriminator 2
 3405 13ac 0023     		movs	r3, #0
 3406              	.L182:
 3407              		.loc 1 3199 0 discriminator 3
 3408 13ae 002B     		cmp	r3, #0
 3409 13b0 2ED0     		beq	.L183
3200:../FreeRTOS/tasks.c **** 				{
3201:../FreeRTOS/tasks.c **** 					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 3410              		.loc 1 3201 0 is_stmt 1
 3411 13b2 FB68     		ldr	r3, [r7, #12]
 3412 13b4 0433     		adds	r3, r3, #4
 3413 13b6 1846     		mov	r0, r3
 3414 13b8 FFF7FEFF 		bl	uxListRemove
3202:../FreeRTOS/tasks.c **** 					{
3203:../FreeRTOS/tasks.c **** 						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
3204:../FreeRTOS/tasks.c **** 					}
3205:../FreeRTOS/tasks.c **** 					else
3206:../FreeRTOS/tasks.c **** 					{
3207:../FreeRTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3208:../FreeRTOS/tasks.c **** 					}
3209:../FreeRTOS/tasks.c **** 
3210:../FreeRTOS/tasks.c **** 					/* Inherit the priority before being moved into the new list. */
3211:../FreeRTOS/tasks.c **** 					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 3415              		.loc 1 3211 0
 3416 13bc 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3417 13c0 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3418 13c4 1B68     		ldr	r3, [r3]
 3419 13c6 DA6A     		ldr	r2, [r3, #44]
 3420 13c8 FB68     		ldr	r3, [r7, #12]
 3421 13ca DA62     		str	r2, [r3, #44]
3212:../FreeRTOS/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 3422              		.loc 1 3212 0
 3423 13cc FB68     		ldr	r3, [r7, #12]
 3424 13ce DA6A     		ldr	r2, [r3, #44]
 3425 13d0 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 3426 13d4 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 3427 13d8 1B68     		ldr	r3, [r3]
 3428 13da 9A42     		cmp	r2, r3
 3429 13dc 06D9     		bls	.L184
 3430              		.loc 1 3212 0 is_stmt 0 discriminator 1
 3431 13de FB68     		ldr	r3, [r7, #12]
 3432 13e0 DA6A     		ldr	r2, [r3, #44]
 3433 13e2 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 3434 13e6 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 3435 13ea 1A60     		str	r2, [r3]
 3436              	.L184:
 3437              		.loc 1 3212 0 discriminator 2
 3438 13ec FB68     		ldr	r3, [r7, #12]
 3439 13ee DA6A     		ldr	r2, [r3, #44]
 3440 13f0 1346     		mov	r3, r2
 3441 13f2 9B00     		lsls	r3, r3, #2
 3442 13f4 1344     		add	r3, r3, r2
 3443 13f6 9B00     		lsls	r3, r3, #2
 3444 13f8 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 3445 13fc C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 3446 1400 1A44     		add	r2, r2, r3
 3447 1402 FB68     		ldr	r3, [r7, #12]
 3448 1404 0433     		adds	r3, r3, #4
 3449 1406 1046     		mov	r0, r2
 3450 1408 1946     		mov	r1, r3
 3451 140a FFF7FEFF 		bl	vListInsertEnd
 3452 140e 07E0     		b	.L178
 3453              	.L183:
3213:../FreeRTOS/tasks.c **** 				}
3214:../FreeRTOS/tasks.c **** 				else
3215:../FreeRTOS/tasks.c **** 				{
3216:../FreeRTOS/tasks.c **** 					/* Just inherit the priority. */
3217:../FreeRTOS/tasks.c **** 					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 3454              		.loc 1 3217 0 is_stmt 1
 3455 1410 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3456 1414 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3457 1418 1B68     		ldr	r3, [r3]
 3458 141a DA6A     		ldr	r2, [r3, #44]
 3459 141c FB68     		ldr	r3, [r7, #12]
 3460 141e DA62     		str	r2, [r3, #44]
 3461              	.L178:
3218:../FreeRTOS/tasks.c **** 				}
3219:../FreeRTOS/tasks.c **** 
3220:../FreeRTOS/tasks.c **** 				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
3221:../FreeRTOS/tasks.c **** 			}
3222:../FreeRTOS/tasks.c **** 			else
3223:../FreeRTOS/tasks.c **** 			{
3224:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3225:../FreeRTOS/tasks.c **** 			}
3226:../FreeRTOS/tasks.c **** 		}
3227:../FreeRTOS/tasks.c **** 		else
3228:../FreeRTOS/tasks.c **** 		{
3229:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3230:../FreeRTOS/tasks.c **** 		}
3231:../FreeRTOS/tasks.c **** 	}
 3462              		.loc 1 3231 0
 3463 1420 1037     		adds	r7, r7, #16
 3464 1422 BD46     		mov	sp, r7
 3465              		@ sp needed
 3466 1424 80BD     		pop	{r7, pc}
 3467              		.cfi_endproc
 3468              	.LFE37:
 3470 1426 00BF     		.align	2
 3471              		.global	vTaskPriorityDisinherit
 3472              		.thumb
 3473              		.thumb_func
 3475              	vTaskPriorityDisinherit:
 3476              	.LFB38:
3232:../FreeRTOS/tasks.c **** 
3233:../FreeRTOS/tasks.c **** #endif /* configUSE_MUTEXES */
3234:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3235:../FreeRTOS/tasks.c **** 
3236:../FreeRTOS/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3237:../FreeRTOS/tasks.c **** 
3238:../FreeRTOS/tasks.c **** 	void vTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
3239:../FreeRTOS/tasks.c **** 	{
 3477              		.loc 1 3239 0
 3478              		.cfi_startproc
 3479              		@ args = 0, pretend = 0, frame = 16
 3480              		@ frame_needed = 1, uses_anonymous_args = 0
 3481 1428 80B5     		push	{r7, lr}
 3482              		.cfi_def_cfa_offset 8
 3483              		.cfi_offset 7, -8
 3484              		.cfi_offset 14, -4
 3485 142a 84B0     		sub	sp, sp, #16
 3486              		.cfi_def_cfa_offset 24
 3487 142c 00AF     		add	r7, sp, #0
 3488              		.cfi_def_cfa_register 7
 3489 142e 7860     		str	r0, [r7, #4]
3240:../FreeRTOS/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
 3490              		.loc 1 3240 0
 3491 1430 7B68     		ldr	r3, [r7, #4]
 3492 1432 FB60     		str	r3, [r7, #12]
3241:../FreeRTOS/tasks.c **** 
3242:../FreeRTOS/tasks.c **** 		if( pxMutexHolder != NULL )
 3493              		.loc 1 3242 0
 3494 1434 7B68     		ldr	r3, [r7, #4]
 3495 1436 002B     		cmp	r3, #0
 3496 1438 39D0     		beq	.L186
3243:../FreeRTOS/tasks.c **** 		{
3244:../FreeRTOS/tasks.c **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 3497              		.loc 1 3244 0
 3498 143a FB68     		ldr	r3, [r7, #12]
 3499 143c DA6A     		ldr	r2, [r3, #44]
 3500 143e FB68     		ldr	r3, [r7, #12]
 3501 1440 5B6C     		ldr	r3, [r3, #68]
 3502 1442 9A42     		cmp	r2, r3
 3503 1444 33D0     		beq	.L186
3245:../FreeRTOS/tasks.c **** 			{
3246:../FreeRTOS/tasks.c **** 				/* We must be the running task to be able to give the mutex back.
3247:../FreeRTOS/tasks.c **** 				Remove ourselves from the ready list we currently appear in. */
3248:../FreeRTOS/tasks.c **** 				if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 3504              		.loc 1 3248 0
 3505 1446 FB68     		ldr	r3, [r7, #12]
 3506 1448 0433     		adds	r3, r3, #4
 3507 144a 1846     		mov	r0, r3
 3508 144c FFF7FEFF 		bl	uxListRemove
3249:../FreeRTOS/tasks.c **** 				{
3250:../FreeRTOS/tasks.c **** 					taskRESET_READY_PRIORITY( pxTCB->uxPriority );
3251:../FreeRTOS/tasks.c **** 				}
3252:../FreeRTOS/tasks.c **** 				else
3253:../FreeRTOS/tasks.c **** 				{
3254:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3255:../FreeRTOS/tasks.c **** 				}
3256:../FreeRTOS/tasks.c **** 
3257:../FreeRTOS/tasks.c **** 				/* Disinherit the priority before adding the task into the new
3258:../FreeRTOS/tasks.c **** 				ready list. */
3259:../FreeRTOS/tasks.c **** 				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
3260:../FreeRTOS/tasks.c **** 				pxTCB->uxPriority = pxTCB->uxBasePriority;
 3509              		.loc 1 3260 0
 3510 1450 FB68     		ldr	r3, [r7, #12]
 3511 1452 5A6C     		ldr	r2, [r3, #68]
 3512 1454 FB68     		ldr	r3, [r7, #12]
 3513 1456 DA62     		str	r2, [r3, #44]
3261:../FreeRTOS/tasks.c **** 
3262:../FreeRTOS/tasks.c **** 				/* Only reset the event list item value if the value is not
3263:../FreeRTOS/tasks.c **** 				being used for anything else. */
3264:../FreeRTOS/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE 
 3514              		.loc 1 3264 0
 3515 1458 FB68     		ldr	r3, [r7, #12]
 3516 145a 9B69     		ldr	r3, [r3, #24]
 3517 145c 002B     		cmp	r3, #0
 3518 145e 05DB     		blt	.L188
3265:../FreeRTOS/tasks.c **** 				{
3266:../FreeRTOS/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( T
 3519              		.loc 1 3266 0
 3520 1460 FB68     		ldr	r3, [r7, #12]
 3521 1462 DB6A     		ldr	r3, [r3, #44]
 3522 1464 C3F10502 		rsb	r2, r3, #5
 3523 1468 FB68     		ldr	r3, [r7, #12]
 3524 146a 9A61     		str	r2, [r3, #24]
 3525              	.L188:
3267:../FreeRTOS/tasks.c **** 				}
3268:../FreeRTOS/tasks.c **** 				else
3269:../FreeRTOS/tasks.c **** 				{
3270:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3271:../FreeRTOS/tasks.c **** 				}
3272:../FreeRTOS/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
 3526              		.loc 1 3272 0
 3527 146c FB68     		ldr	r3, [r7, #12]
 3528 146e DA6A     		ldr	r2, [r3, #44]
 3529 1470 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 3530 1474 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 3531 1478 1B68     		ldr	r3, [r3]
 3532 147a 9A42     		cmp	r2, r3
 3533 147c 06D9     		bls	.L189
 3534              		.loc 1 3272 0 is_stmt 0 discriminator 1
 3535 147e FB68     		ldr	r3, [r7, #12]
 3536 1480 DA6A     		ldr	r2, [r3, #44]
 3537 1482 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 3538 1486 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 3539 148a 1A60     		str	r2, [r3]
 3540              	.L189:
 3541              		.loc 1 3272 0 discriminator 2
 3542 148c FB68     		ldr	r3, [r7, #12]
 3543 148e DA6A     		ldr	r2, [r3, #44]
 3544 1490 1346     		mov	r3, r2
 3545 1492 9B00     		lsls	r3, r3, #2
 3546 1494 1344     		add	r3, r3, r2
 3547 1496 9B00     		lsls	r3, r3, #2
 3548 1498 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 3549 149c C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 3550 14a0 1A44     		add	r2, r2, r3
 3551 14a2 FB68     		ldr	r3, [r7, #12]
 3552 14a4 0433     		adds	r3, r3, #4
 3553 14a6 1046     		mov	r0, r2
 3554 14a8 1946     		mov	r1, r3
 3555 14aa FFF7FEFF 		bl	vListInsertEnd
 3556              	.L186:
3273:../FreeRTOS/tasks.c **** 			}
3274:../FreeRTOS/tasks.c **** 			else
3275:../FreeRTOS/tasks.c **** 			{
3276:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3277:../FreeRTOS/tasks.c **** 			}
3278:../FreeRTOS/tasks.c **** 		}
3279:../FreeRTOS/tasks.c **** 		else
3280:../FreeRTOS/tasks.c **** 		{
3281:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3282:../FreeRTOS/tasks.c **** 		}
3283:../FreeRTOS/tasks.c **** 	}
 3557              		.loc 1 3283 0 is_stmt 1
 3558 14ae 1037     		adds	r7, r7, #16
 3559 14b0 BD46     		mov	sp, r7
 3560              		@ sp needed
 3561 14b2 80BD     		pop	{r7, pc}
 3562              		.cfi_endproc
 3563              	.LFE38:
 3565              		.align	2
 3566              		.global	uxTaskResetEventItemValue
 3567              		.thumb
 3568              		.thumb_func
 3570              	uxTaskResetEventItemValue:
 3571              	.LFB39:
3284:../FreeRTOS/tasks.c **** 
3285:../FreeRTOS/tasks.c **** #endif /* configUSE_MUTEXES */
3286:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3287:../FreeRTOS/tasks.c **** 
3288:../FreeRTOS/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
3289:../FreeRTOS/tasks.c **** 
3290:../FreeRTOS/tasks.c **** 	void vTaskEnterCritical( void )
3291:../FreeRTOS/tasks.c **** 	{
3292:../FreeRTOS/tasks.c **** 		portDISABLE_INTERRUPTS();
3293:../FreeRTOS/tasks.c **** 
3294:../FreeRTOS/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
3295:../FreeRTOS/tasks.c **** 		{
3296:../FreeRTOS/tasks.c **** 			( pxCurrentTCB->uxCriticalNesting )++;
3297:../FreeRTOS/tasks.c **** 		}
3298:../FreeRTOS/tasks.c **** 		else
3299:../FreeRTOS/tasks.c **** 		{
3300:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3301:../FreeRTOS/tasks.c **** 		}
3302:../FreeRTOS/tasks.c **** 	}
3303:../FreeRTOS/tasks.c **** 
3304:../FreeRTOS/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
3305:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3306:../FreeRTOS/tasks.c **** 
3307:../FreeRTOS/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
3308:../FreeRTOS/tasks.c **** 
3309:../FreeRTOS/tasks.c **** 	void vTaskExitCritical( void )
3310:../FreeRTOS/tasks.c **** 	{
3311:../FreeRTOS/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
3312:../FreeRTOS/tasks.c **** 		{
3313:../FreeRTOS/tasks.c **** 			if( pxCurrentTCB->uxCriticalNesting > 0U )
3314:../FreeRTOS/tasks.c **** 			{
3315:../FreeRTOS/tasks.c **** 				( pxCurrentTCB->uxCriticalNesting )--;
3316:../FreeRTOS/tasks.c **** 
3317:../FreeRTOS/tasks.c **** 				if( pxCurrentTCB->uxCriticalNesting == 0U )
3318:../FreeRTOS/tasks.c **** 				{
3319:../FreeRTOS/tasks.c **** 					portENABLE_INTERRUPTS();
3320:../FreeRTOS/tasks.c **** 				}
3321:../FreeRTOS/tasks.c **** 				else
3322:../FreeRTOS/tasks.c **** 				{
3323:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3324:../FreeRTOS/tasks.c **** 				}
3325:../FreeRTOS/tasks.c **** 			}
3326:../FreeRTOS/tasks.c **** 			else
3327:../FreeRTOS/tasks.c **** 			{
3328:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3329:../FreeRTOS/tasks.c **** 			}
3330:../FreeRTOS/tasks.c **** 		}
3331:../FreeRTOS/tasks.c **** 		else
3332:../FreeRTOS/tasks.c **** 		{
3333:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3334:../FreeRTOS/tasks.c **** 		}
3335:../FreeRTOS/tasks.c **** 	}
3336:../FreeRTOS/tasks.c **** 
3337:../FreeRTOS/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
3338:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3339:../FreeRTOS/tasks.c **** 
3340:../FreeRTOS/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) )
3341:../FreeRTOS/tasks.c **** 
3342:../FreeRTOS/tasks.c **** 	void vTaskList( char * pcWriteBuffer )
3343:../FreeRTOS/tasks.c **** 	{
3344:../FreeRTOS/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
3345:../FreeRTOS/tasks.c **** 	volatile UBaseType_t uxArraySize, x;
3346:../FreeRTOS/tasks.c **** 	char cStatus;
3347:../FreeRTOS/tasks.c **** 
3348:../FreeRTOS/tasks.c **** 		/*
3349:../FreeRTOS/tasks.c **** 		 * PLEASE NOTE:
3350:../FreeRTOS/tasks.c **** 		 *
3351:../FreeRTOS/tasks.c **** 		 * This function is provided for convenience only, and is used by many
3352:../FreeRTOS/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
3353:../FreeRTOS/tasks.c **** 		 * scheduler.
3354:../FreeRTOS/tasks.c **** 		 *
3355:../FreeRTOS/tasks.c **** 		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
3356:../FreeRTOS/tasks.c **** 		 * uxTaskGetSystemState() output into a human readable table that
3357:../FreeRTOS/tasks.c **** 		 * displays task names, states and stack usage.
3358:../FreeRTOS/tasks.c **** 		 *
3359:../FreeRTOS/tasks.c **** 		 * vTaskList() has a dependency on the sprintf() C library function that
3360:../FreeRTOS/tasks.c **** 		 * might bloat the code size, use a lot of stack, and provide different
3361:../FreeRTOS/tasks.c **** 		 * results on different platforms.  An alternative, tiny, third party,
3362:../FreeRTOS/tasks.c **** 		 * and limited functionality implementation of sprintf() is provided in
3363:../FreeRTOS/tasks.c **** 		 * many of the FreeRTOS/Demo sub-directories in a file called
3364:../FreeRTOS/tasks.c **** 		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
3365:../FreeRTOS/tasks.c **** 		 * snprintf() implementation!).
3366:../FreeRTOS/tasks.c **** 		 *
3367:../FreeRTOS/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
3368:../FreeRTOS/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
3369:../FreeRTOS/tasks.c **** 		 * through a call to vTaskList().
3370:../FreeRTOS/tasks.c **** 		 */
3371:../FreeRTOS/tasks.c **** 
3372:../FreeRTOS/tasks.c **** 
3373:../FreeRTOS/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
3374:../FreeRTOS/tasks.c **** 		*pcWriteBuffer = 0x00;
3375:../FreeRTOS/tasks.c **** 
3376:../FreeRTOS/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
3377:../FreeRTOS/tasks.c **** 		function is executing. */
3378:../FreeRTOS/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
3379:../FreeRTOS/tasks.c **** 
3380:../FreeRTOS/tasks.c **** 		/* Allocate an array index for each task. */
3381:../FreeRTOS/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
3382:../FreeRTOS/tasks.c **** 
3383:../FreeRTOS/tasks.c **** 		if( pxTaskStatusArray != NULL )
3384:../FreeRTOS/tasks.c **** 		{
3385:../FreeRTOS/tasks.c **** 			/* Generate the (binary) data. */
3386:../FreeRTOS/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
3387:../FreeRTOS/tasks.c **** 
3388:../FreeRTOS/tasks.c **** 			/* Create a human readable table from the binary data. */
3389:../FreeRTOS/tasks.c **** 			for( x = 0; x < uxArraySize; x++ )
3390:../FreeRTOS/tasks.c **** 			{
3391:../FreeRTOS/tasks.c **** 				switch( pxTaskStatusArray[ x ].eCurrentState )
3392:../FreeRTOS/tasks.c **** 				{
3393:../FreeRTOS/tasks.c **** 				case eReady:		cStatus = tskREADY_CHAR;
3394:../FreeRTOS/tasks.c **** 									break;
3395:../FreeRTOS/tasks.c **** 
3396:../FreeRTOS/tasks.c **** 				case eBlocked:		cStatus = tskBLOCKED_CHAR;
3397:../FreeRTOS/tasks.c **** 									break;
3398:../FreeRTOS/tasks.c **** 
3399:../FreeRTOS/tasks.c **** 				case eSuspended:	cStatus = tskSUSPENDED_CHAR;
3400:../FreeRTOS/tasks.c **** 									break;
3401:../FreeRTOS/tasks.c **** 
3402:../FreeRTOS/tasks.c **** 				case eDeleted:		cStatus = tskDELETED_CHAR;
3403:../FreeRTOS/tasks.c **** 									break;
3404:../FreeRTOS/tasks.c **** 
3405:../FreeRTOS/tasks.c **** 				default:			/* Should not get here, but it is included
3406:../FreeRTOS/tasks.c **** 									to prevent static checking errors. */
3407:../FreeRTOS/tasks.c **** 									cStatus = 0x00;
3408:../FreeRTOS/tasks.c **** 									break;
3409:../FreeRTOS/tasks.c **** 				}
3410:../FreeRTOS/tasks.c **** 
3411:../FreeRTOS/tasks.c **** 				sprintf( pcWriteBuffer, "%s\t\t%c\t%u\t%u\t%u\r\n", pxTaskStatusArray[ x ].pcTaskName, cStatus,
3412:../FreeRTOS/tasks.c **** 				pcWriteBuffer += strlen( pcWriteBuffer );
3413:../FreeRTOS/tasks.c **** 			}
3414:../FreeRTOS/tasks.c **** 
3415:../FreeRTOS/tasks.c **** 			/* Free the array again. */
3416:../FreeRTOS/tasks.c **** 			vPortFree( pxTaskStatusArray );
3417:../FreeRTOS/tasks.c **** 		}
3418:../FreeRTOS/tasks.c **** 		else
3419:../FreeRTOS/tasks.c **** 		{
3420:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3421:../FreeRTOS/tasks.c **** 		}
3422:../FreeRTOS/tasks.c **** 	}
3423:../FreeRTOS/tasks.c **** 
3424:../FreeRTOS/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) ) */
3425:../FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
3426:../FreeRTOS/tasks.c **** 
3427:../FreeRTOS/tasks.c **** #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) )
3428:../FreeRTOS/tasks.c **** 
3429:../FreeRTOS/tasks.c **** 	void vTaskGetRunTimeStats( char *pcWriteBuffer )
3430:../FreeRTOS/tasks.c **** 	{
3431:../FreeRTOS/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
3432:../FreeRTOS/tasks.c **** 	volatile UBaseType_t uxArraySize, x;
3433:../FreeRTOS/tasks.c **** 	uint32_t ulTotalTime, ulStatsAsPercentage;
3434:../FreeRTOS/tasks.c **** 
3435:../FreeRTOS/tasks.c **** 		#if( configUSE_TRACE_FACILITY != 1 )
3436:../FreeRTOS/tasks.c **** 		{
3437:../FreeRTOS/tasks.c **** 			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTime
3438:../FreeRTOS/tasks.c **** 		}
3439:../FreeRTOS/tasks.c **** 		#endif
3440:../FreeRTOS/tasks.c **** 
3441:../FreeRTOS/tasks.c **** 		/*
3442:../FreeRTOS/tasks.c **** 		 * PLEASE NOTE:
3443:../FreeRTOS/tasks.c **** 		 *
3444:../FreeRTOS/tasks.c **** 		 * This function is provided for convenience only, and is used by many
3445:../FreeRTOS/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
3446:../FreeRTOS/tasks.c **** 		 * scheduler.
3447:../FreeRTOS/tasks.c **** 		 *
3448:../FreeRTOS/tasks.c **** 		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
3449:../FreeRTOS/tasks.c **** 		 * of the uxTaskGetSystemState() output into a human readable table that
3450:../FreeRTOS/tasks.c **** 		 * displays the amount of time each task has spent in the Running state
3451:../FreeRTOS/tasks.c **** 		 * in both absolute and percentage terms.
3452:../FreeRTOS/tasks.c **** 		 *
3453:../FreeRTOS/tasks.c **** 		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
3454:../FreeRTOS/tasks.c **** 		 * function that might bloat the code size, use a lot of stack, and
3455:../FreeRTOS/tasks.c **** 		 * provide different results on different platforms.  An alternative,
3456:../FreeRTOS/tasks.c **** 		 * tiny, third party, and limited functionality implementation of
3457:../FreeRTOS/tasks.c **** 		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
3458:../FreeRTOS/tasks.c **** 		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
3459:../FreeRTOS/tasks.c **** 		 * a full snprintf() implementation!).
3460:../FreeRTOS/tasks.c **** 		 *
3461:../FreeRTOS/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
3462:../FreeRTOS/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
3463:../FreeRTOS/tasks.c **** 		 * through a call to vTaskGetRunTimeStats().
3464:../FreeRTOS/tasks.c **** 		 */
3465:../FreeRTOS/tasks.c **** 
3466:../FreeRTOS/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
3467:../FreeRTOS/tasks.c **** 		*pcWriteBuffer = 0x00;
3468:../FreeRTOS/tasks.c **** 
3469:../FreeRTOS/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
3470:../FreeRTOS/tasks.c **** 		function is executing. */
3471:../FreeRTOS/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
3472:../FreeRTOS/tasks.c **** 
3473:../FreeRTOS/tasks.c **** 		/* Allocate an array index for each task. */
3474:../FreeRTOS/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
3475:../FreeRTOS/tasks.c **** 
3476:../FreeRTOS/tasks.c **** 		if( pxTaskStatusArray != NULL )
3477:../FreeRTOS/tasks.c **** 		{
3478:../FreeRTOS/tasks.c **** 			/* Generate the (binary) data. */
3479:../FreeRTOS/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
3480:../FreeRTOS/tasks.c **** 
3481:../FreeRTOS/tasks.c **** 			/* For percentage calculations. */
3482:../FreeRTOS/tasks.c **** 			ulTotalTime /= 100UL;
3483:../FreeRTOS/tasks.c **** 
3484:../FreeRTOS/tasks.c **** 			/* Avoid divide by zero errors. */
3485:../FreeRTOS/tasks.c **** 			if( ulTotalTime > 0 )
3486:../FreeRTOS/tasks.c **** 			{
3487:../FreeRTOS/tasks.c **** 				/* Create a human readable table from the binary data. */
3488:../FreeRTOS/tasks.c **** 				for( x = 0; x < uxArraySize; x++ )
3489:../FreeRTOS/tasks.c **** 				{
3490:../FreeRTOS/tasks.c **** 					/* What percentage of the total run time has the task used?
3491:../FreeRTOS/tasks.c **** 					This will always be rounded down to the nearest integer.
3492:../FreeRTOS/tasks.c **** 					ulTotalRunTimeDiv100 has already been divided by 100. */
3493:../FreeRTOS/tasks.c **** 					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
3494:../FreeRTOS/tasks.c **** 
3495:../FreeRTOS/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
3496:../FreeRTOS/tasks.c **** 					{
3497:../FreeRTOS/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
3498:../FreeRTOS/tasks.c **** 						{
3499:../FreeRTOS/tasks.c **** 							sprintf( pcWriteBuffer, "%s\t\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskS
3500:../FreeRTOS/tasks.c **** 						}
3501:../FreeRTOS/tasks.c **** 						#else
3502:../FreeRTOS/tasks.c **** 						{
3503:../FreeRTOS/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
3504:../FreeRTOS/tasks.c **** 							printf() library can be used. */
3505:../FreeRTOS/tasks.c **** 							sprintf( pcWriteBuffer, "%s\t\t%u\t\t%u%%\r\n", pxTaskStatusArray[ x ].pcTaskName, ( unsigne
3506:../FreeRTOS/tasks.c **** 						}
3507:../FreeRTOS/tasks.c **** 						#endif
3508:../FreeRTOS/tasks.c **** 					}
3509:../FreeRTOS/tasks.c **** 					else
3510:../FreeRTOS/tasks.c **** 					{
3511:../FreeRTOS/tasks.c **** 						/* If the percentage is zero here then the task has
3512:../FreeRTOS/tasks.c **** 						consumed less than 1% of the total run time. */
3513:../FreeRTOS/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
3514:../FreeRTOS/tasks.c **** 						{
3515:../FreeRTOS/tasks.c **** 							sprintf( pcWriteBuffer, "%s\t\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskSt
3516:../FreeRTOS/tasks.c **** 						}
3517:../FreeRTOS/tasks.c **** 						#else
3518:../FreeRTOS/tasks.c **** 						{
3519:../FreeRTOS/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
3520:../FreeRTOS/tasks.c **** 							printf() library can be used. */
3521:../FreeRTOS/tasks.c **** 							sprintf( pcWriteBuffer, "%s\t\t%u\t\t<1%%\r\n", pxTaskStatusArray[ x ].pcTaskName, ( unsigne
3522:../FreeRTOS/tasks.c **** 						}
3523:../FreeRTOS/tasks.c **** 						#endif
3524:../FreeRTOS/tasks.c **** 					}
3525:../FreeRTOS/tasks.c **** 
3526:../FreeRTOS/tasks.c **** 					pcWriteBuffer += strlen( pcWriteBuffer );
3527:../FreeRTOS/tasks.c **** 				}
3528:../FreeRTOS/tasks.c **** 			}
3529:../FreeRTOS/tasks.c **** 			else
3530:../FreeRTOS/tasks.c **** 			{
3531:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3532:../FreeRTOS/tasks.c **** 			}
3533:../FreeRTOS/tasks.c **** 
3534:../FreeRTOS/tasks.c **** 			/* Free the array again. */
3535:../FreeRTOS/tasks.c **** 			vPortFree( pxTaskStatusArray );
3536:../FreeRTOS/tasks.c **** 		}
3537:../FreeRTOS/tasks.c **** 		else
3538:../FreeRTOS/tasks.c **** 		{
3539:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3540:../FreeRTOS/tasks.c **** 		}
3541:../FreeRTOS/tasks.c **** 	}
3542:../FreeRTOS/tasks.c **** 
3543:../FreeRTOS/tasks.c **** #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
3544:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3545:../FreeRTOS/tasks.c **** 
3546:../FreeRTOS/tasks.c **** TickType_t uxTaskResetEventItemValue( void )
3547:../FreeRTOS/tasks.c **** {
 3572              		.loc 1 3547 0
 3573              		.cfi_startproc
 3574              		@ args = 0, pretend = 0, frame = 8
 3575              		@ frame_needed = 1, uses_anonymous_args = 0
 3576              		@ link register save eliminated.
 3577 14b4 80B4     		push	{r7}
 3578              		.cfi_def_cfa_offset 4
 3579              		.cfi_offset 7, -4
 3580 14b6 83B0     		sub	sp, sp, #12
 3581              		.cfi_def_cfa_offset 16
 3582 14b8 00AF     		add	r7, sp, #0
 3583              		.cfi_def_cfa_register 7
3548:../FreeRTOS/tasks.c **** TickType_t uxReturn;
3549:../FreeRTOS/tasks.c **** 
3550:../FreeRTOS/tasks.c **** 	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 3584              		.loc 1 3550 0
 3585 14ba 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3586 14be C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3587 14c2 1B68     		ldr	r3, [r3]
 3588 14c4 9B69     		ldr	r3, [r3, #24]
 3589 14c6 7B60     		str	r3, [r7, #4]
3551:../FreeRTOS/tasks.c **** 
3552:../FreeRTOS/tasks.c **** 	/* Reset the event list item to its normal value - so it can be used with
3553:../FreeRTOS/tasks.c **** 	queues and semaphores. */
3554:../FreeRTOS/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES 
 3590              		.loc 1 3554 0
 3591 14c8 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3592 14cc C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3593 14d0 1A68     		ldr	r2, [r3]
 3594 14d2 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3595 14d6 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3596 14da 1B68     		ldr	r3, [r3]
 3597 14dc DB6A     		ldr	r3, [r3, #44]
 3598 14de C3F10503 		rsb	r3, r3, #5
 3599 14e2 9361     		str	r3, [r2, #24]
3555:../FreeRTOS/tasks.c **** 
3556:../FreeRTOS/tasks.c **** 	return uxReturn;
 3600              		.loc 1 3556 0
 3601 14e4 7B68     		ldr	r3, [r7, #4]
3557:../FreeRTOS/tasks.c **** }
 3602              		.loc 1 3557 0
 3603 14e6 1846     		mov	r0, r3
 3604 14e8 0C37     		adds	r7, r7, #12
 3605 14ea BD46     		mov	sp, r7
 3606              		@ sp needed
 3607 14ec 5DF8047B 		ldr	r7, [sp], #4
 3608 14f0 7047     		bx	lr
 3609              		.cfi_endproc
 3610              	.LFE39:
 3612              		.section	.rodata
 3613 0005 000000   		.align	2
 3616              	ucExpectedStackBytes.5263:
 3617 0008 A5       		.byte	-91
 3618 0009 A5       		.byte	-91
 3619 000a A5       		.byte	-91
 3620 000b A5       		.byte	-91
 3621 000c A5       		.byte	-91
 3622 000d A5       		.byte	-91
 3623 000e A5       		.byte	-91
 3624 000f A5       		.byte	-91
 3625 0010 A5       		.byte	-91
 3626 0011 A5       		.byte	-91
 3627 0012 A5       		.byte	-91
 3628 0013 A5       		.byte	-91
 3629 0014 A5       		.byte	-91
 3630 0015 A5       		.byte	-91
 3631 0016 A5       		.byte	-91
 3632 0017 A5       		.byte	-91
 3633 0018 A5       		.byte	-91
 3634 0019 A5       		.byte	-91
 3635 001a A5       		.byte	-91
 3636 001b A5       		.byte	-91
 3637              		.text
 3638              	.Letext0:
 3639              		.file 2 "c:\\program files (x86)\\codesourcery\\lib\\gcc\\arm-none-eabi\\4.8.3\\include\\stddef.h"
 3640              		.file 3 "c:\\program files (x86)\\codesourcery\\arm-none-eabi\\include\\stdint.h"
 3641              		.file 4 "D:\\workspace\\console800480\\FreeRTOS\\include/projdefs.h"
 3642              		.file 5 "D:\\workspace\\console800480\\FreeRTOS\\portable\\GCC\\ARM_CM3/portmacro.h"
 3643              		.file 6 "D:\\workspace\\console800480\\FreeRTOS\\include/list.h"
 3644              		.file 7 "D:\\workspace\\console800480\\FreeRTOS\\include/task.h"
DEFINED SYMBOLS
                            *ABS*:00000000 tasks.c
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:23     .bss:00000000 pxCurrentTCB
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:20     .bss:00000000 $d
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:26     .bss:00000004 pxReadyTasksLists
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:29     .bss:00000068 xDelayedTaskList1
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:32     .bss:0000007c xDelayedTaskList2
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:35     .bss:00000090 pxDelayedTaskList
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:38     .bss:00000094 pxOverflowDelayedTaskList
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:41     .bss:00000098 xPendingReadyList
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:44     .bss:000000ac xTasksWaitingTermination
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:47     .bss:000000c0 uxTasksDeleted
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:50     .bss:000000c4 xSuspendedTaskList
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:53     .bss:000000d8 uxCurrentNumberOfTasks
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:56     .bss:000000dc xTickCount
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:59     .bss:000000e0 uxTopReadyPriority
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:62     .bss:000000e4 xSchedulerRunning
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:65     .bss:000000e8 uxPendedTicks
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:68     .bss:000000ec xYieldPending
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:71     .bss:000000f0 xNumOfOverflows
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:74     .bss:000000f4 uxTaskNumber
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:77     .data:00000000 $d
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:80     .data:00000000 xNextTaskUnblockTime
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:84     .bss:000000f8 uxSchedulerSuspended
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:87     .text:00000000 $t
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:92     .text:00000000 xTaskGenericCreate
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:3012   .text:000011dc prvAllocateTCBAndStack
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:2652   .text:00000f98 prvInitialiseTCBVariables
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:2760   .text:00001028 prvInitialiseTaskLists
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:299    .text:0000017c vTaskDelete
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:3239   .text:000012d0 prvResetNextTaskUnblockTime
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:409    .text:00000234 vTaskDelayUntil
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:1355   .text:0000078c vTaskSuspendAll
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:2935   .text:00001154 prvAddCurrentTaskToDelayedList
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:1388   .text:000007b0 xTaskResumeAll
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:523    .text:000002d0 vTaskDelay
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:588    .text:00000324 uxTaskPriorityGet
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:642    .text:0000035c vTaskPrioritySet
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:843    .text:00000498 vTaskSuspend
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:1915   .text:00000b1c vTaskSwitchContext
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:962    .text:0000055c prvTaskIsTaskSuspended
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:1043   .text:000005bc vTaskResume
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:1143   .text:0000065c xTaskResumeFromISR
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:1252   .rodata:00000000 $d
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:1253   .rodata:00000000 .LC0
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:1261   .text:00000714 vTaskStartScheduler
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:2616   .text:00000f78 prvIdleTask
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:1324   .text:00000770 vTaskEndScheduler
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:1673   .text:00000958 xTaskIncrementTick
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:1563   .text:000008f4 xTaskGetTickCount
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:1602   .text:00000918 xTaskGetTickCountFromISR
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:1643   .text:00000940 uxTaskGetNumberOfTasks
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:3616   .rodata:00000008 ucExpectedStackBytes.5263
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:2078   .text:00000c54 vTaskPlaceOnEventList
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:2148   .text:00000cc4 vTaskPlaceOnUnorderedEventList
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:2226   .text:00000d48 xTaskRemoveFromEventList
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:2341   .text:00000e04 xTaskRemoveFromUnorderedEventList
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:2443   .text:00000ea4 vTaskSetTimeOutState
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:2484   .text:00000ed4 xTaskCheckForTimeOut
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:2587   .text:00000f60 vTaskMissedYield
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:2843   .text:000010c0 prvCheckTasksWaitingTermination
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:3204   .text:000012b0 prvDeleteTCB
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:3093   .text:00001240 prvTaskCheckFreeStackSpace
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:3150   .text:00001278 uxTaskGetStackHighWaterMark
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:3305   .text:00001328 xTaskGetCurrentTaskHandle
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:3341   .text:00001348 vTaskPriorityInherit
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:3475   .text:00001428 vTaskPriorityDisinherit
C:\Users\sagok\AppData\Local\Temp\ccYe3zSX.s:3570   .text:000014b4 uxTaskResetEventItemValue
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.1.7f551ac7fcad8b79b9df4bfdaa536673
                           .group:00000000 wm4.newlib.h.8.384a112feabb3bef7b573ae48cde2e3b
                           .group:00000000 wm4.features.h.22.6a4ca7cd053637cc1d0db6c16f39b2d7
                           .group:00000000 wm4.config.h.183.aa62afef667fb61d15fa64c48beb2f14
                           .group:00000000 wm4._ansi.h.23.5644b60c990a4800b02a6e654e88f93a
                           .group:00000000 wm4.stdlib.h.18.8bab2fb43ac4e90235390733c30a4530
                           .group:00000000 wm4.stddef.h.184.aa65fb7281d578229bbad41b91862635
                           .group:00000000 wm4._default_types.h.6.5e12cd604db8ce00b62bb2f02708eaf3
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4._types.h.59.db8450f33c1f6150c0372fa1091a887a
                           .group:00000000 wm4.stddef.h.348.9a99de77b6ba3b4278b57e9cc6d6e349
                           .group:00000000 wm4.reent.h.16.567d760e6ae9ad7f917851a308bd7a57
                           .group:00000000 wm4.alloca.h.8.dfc0c703c47ec3e69746825b17d9e66d
                           .group:00000000 wm4.stdlib.h.55.7091a050e07f1c4abd225630fe3d62f1
                           .group:00000000 wm4.stddef.h.39.d0197034aa5fd947cae140b9289e6734
                           .group:00000000 wm4.stdint.h.10.90b695f550ca6cc3fb08fa83baf01e05
                           .group:00000000 wm4.cdefs.h.56.efab90f4d89fbc41d6b3a5c5fb0d3d0f
                           .group:00000000 wm4.string.h.15.dab3980bf35408a4c507182805e2de3a
                           .group:00000000 wm4.stddef.h.158.a7efb00f6cbc6f43213b50e183c9830c
                           .group:00000000 wm4.string.h.126.6ff3aa59129e7f66b2c273baf353e066
                           .group:00000000 wm4.projdefs.h.67.1891ed3aab788f154f6e7a8ff42f2cfd
                           .group:00000000 wm4.FreeRTOSConfig.h.51.b259e2e835793b5f31e6fb224a543b76
                           .group:00000000 wm4.portmacro.h.68.b9ad41c1c2fd3fb36d97939d17ebacd9
                           .group:00000000 wm4.portable.h.325.a31e8973a246cd28421ddb595e37fd13
                           .group:00000000 wm4.mpu_wrappers.h.67.4bcfd12ce15e5313ce3efd77400f8168
                           .group:00000000 wm4.FreeRTOS.h.177.d801ec107caaf24697618049ed7605b1
                           .group:00000000 wm4.list.h.96.eaa3d29743bd681933f9f5e726c756a1
                           .group:00000000 wm4.task.h.84.ff846741c7bdac87bd4a7636d5320d68
                           .group:00000000 wm4.timers.h.92.7e7e1a9bf65701faf3dfc9cf90e720c0
                           .group:00000000 wm4.StackMacros.h.67.2381e84be29c766894f6198315959e14

UNDEFINED SYMBOLS
pxPortInitialiseStack
vPortEnterCritical
vListInsertEnd
vPortExitCritical
vPortYield
uxListRemove
ulPortSetInterruptMask
vPortClearInterruptMask
xPortStartScheduler
vPortEndScheduler
vApplicationStackOverflowHook
memcmp
vListInsert
vListInitialiseItem
vListInitialise
pvPortMalloc
vPortFree
memset
